<!DOCTYPE html>
<html>
<head>
    <title>release-tracking-with-filters-1.1.8</title>
    <!--  (c) 2019 Custom Agile.  All Rights Reserved. -->
    <!--  Build Date: Mon Nov 11 2019 15:12:22 GMT-0500 (Eastern Standard Time) -->

    <script type="text/javascript">
        var APP_BUILD_DATE = "Mon Nov 11 2019 15:12:22 GMT-0500 (Eastern Standard Time)";
        var CHECKSUM = 538053144584;
    </script>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/* globals Rally */
// Fix the PreliminaryEstimate renderer to sort by value
Rally.ui.renderer.GridEditorFactory.editorRenderers['PreliminaryEstimate'] = function(field) {
    return {
        xtype: 'rallyrecordcontexteditor',
        field: {
            xtype: 'rallycombobox',
            allowNoEntry: !field.required,
            editable: false,
            name: field.name,
            storeConfig: {
                autoLoad: true,
                model: field.name,
                remoteFilter: true,
                sorters: [{
                    property: "Value"
                }],
                listeners: {
                    load: function() {
                        return;
                    }
                }
            }
        }
    };
};

Ext.define('Utils.AncestorPiInlineFilter', {
    override: 'Rally.ui.inlinefilter.QuickFilterPanel',
    portfolioItemTypes: [],
    modelName: undefined,
    customFilterNamePrefix: "AncestorPiInlineFilter.",

    _hasPiAncestor: function(modelName) {
        return _.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName) || Ext.String.startsWith(modelName, 'portfolioitem');
    },

    _pisAbove: function(modelName) {
        var result = [];
        if (_.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName)) {
            result = this.portfolioItemTypes
        }
        else if (Ext.String.startsWith(modelName, 'portfolioitem')) {
            var startIndex = _.findIndex(this.portfolioItemTypes, function(piType) {
                return piType.get('TypePath').toLowerCase() === modelName;
            });
            if (startIndex >= 0 && startIndex < this.portfolioItemTypes.length - 1) {
                result = this.portfolioItemTypes.slice(startIndex + 1);
            }
        }
        return result;
    },

    initComponent: function() {
        if (!this.dataContext) {
            this.dataContext = Rally.getApp().getContext().getDataContext();
        }

        if (this.modelName) {
            this.modelName = this.modelName.toLowerCase();
        }
        var filterFactoryOverrides = {};
        var additionalFields = []
        if (this._hasPiAncestor(this.modelName)) {
            var pisAbove = this._pisAbove(this.modelName);
            _.each(pisAbove, function(piType) {
                var typePath = piType.get('TypePath');
                var customFilterName = this.customFilterNamePrefix + typePath;
                var displayName = 'Portfolio Item / ' + piType.get('Name');
                filterFactoryOverrides[customFilterName] = {
                    xtype: 'ancestorpisearchcombobox',
                    portfolioItemType: typePath, // The artifact type to search for
                    piTypesAbove: pisAbove, // List of portfolio item types
                    artifactTypeName: this.modelName, // The artifact type we are filtering
                    storeConfig: {
                        context: this.dataContext,
                        models: typePath,
                        autoLoad: true
                    },
                    allowNoEntry: true,
                    noEntryValue: null,
                    noEntryText: 'No ' + displayName,
                    emptyText: 'Search ' + displayName + 's...',
                    allowClear: false,
                    valueField: 'ObjectUUID', // Must use ObjectUUID to align with the state that is saved by inlinefilterbutton
                    forceSelection: false
                };
                additionalFields.push({
                    name: customFilterName,
                    displayName: displayName
                })
            }, this);

            // Add the additional fields to the quick filter config
            _.merge(this.addQuickFilterConfig, {
                additionalFields: additionalFields
            }, function(a, b) {
                if (_.isArray(a)) {
                    return _.uniq(a.concat(b), 'name') // Strip duplicates by name that can occur from state
                }
            });

            // Add the corresponding items to the FilterFieldFactory
            Ext.override(Rally.ui.inlinefilter.FilterFieldFactory, filterFactoryOverrides);
        }

        this.callParent(arguments);
    },

    _createFields: function() {
        // Strip out the custom filters from this.fields and this.initialFilters
        this.fields = _.filter(this.fields, function(field) {
            return this._filterInvalidAncestorFilters(field);
        }, this);
        this.initialFilters = _.filter(this.initialFilters, function(filter) {
            return this._filterInvalidAncestorFilters(filter.name);
        }, this);
        this.callParent(arguments);
    },

    /**
     * This will exclude any field restored from state that we didn't explicitly add into the Factory
     * for the current model type. This prevents changes in model types from trying to build an invalid filter
     * for that new model type.
     */
    _filterInvalidAncestorFilters: function(name) {
        return !Ext.String.startsWith(name, this.customFilterNamePrefix) || Rally.ui.inlinefilter.FilterFieldFactory.hasOwnProperty(name)
    }
});

Ext.define('Utils.AncestorPiSearchComboBox', {
    alias: 'widget.ancestorpisearchcombobox',
    extend: 'Rally.ui.combobox.ArtifactSearchComboBox',

    parentField: 'PortfolioItem.Parent.',

    artifactTypeName: undefined, // The name of the model that will be filtered
    piTypesAbove: [],
    statics: {
        UUID_REGEX: /([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})/
    },

    constructor: function(config) {
        if (config.value) {
            Ext.merge(config, {
                storeConfig: {
                    filters: Rally.data.wsapi.Filter.or([{
                            property: config.valueField, // Compensate for parent constructor assuming that filter value is OidFromRef
                            value: config.value
                        }
                        /*, {
                                                property: 'ObjectID',
                                                operator: '!=',
                                                value: 0
                                            }*/
                    ])
                }
            });
        }

        //this.callSuper(arguments);
        // Get super super method (skip the extended ArtifactSearchComboBox.constructor()
        return this.superclass.superclass['constructor'].apply(this, arguments);
    },

    initComponent: function() {
        this.on('change', function(cmp, newValue, oldValue) {
            if (newValue == "") {
                this.store.load({
                    filters: []
                })
            }
        }, this)
        return this.callParent(arguments);
    },

    setValue: function() {
        this.callParent(arguments);
    },

    getFilter: function() {

        var value = this.lastValue;
        var propertyPrefix = this.propertyPrefix();
        var filters = []
        // If the value is a UUID, then use it, otherwise ignore values the user might be typing in
        if (value && this.statics().UUID_REGEX.test(value)) {
            filters.push({
                property: propertyPrefix + ".ObjectUUID",
                value: value
            });
        }
        else {
            filters.push({
                property: propertyPrefix,
                value: null
            });
        }
        return Rally.data.wsapi.Filter.or(filters);
    },

    propertyPrefix: function() {
        var property;
        // Get the path between the selected artifact and the lowest level PI above it
        if (this.artifactTypeName === 'hierarchicalrequirement' || this.artifactTypeName === 'userstory') {
            property = this.piTypesAbove[0].get('Name');
        }
        else if (this.artifactTypeName === 'defect') {
            property = 'Requirement.' + this.piTypesAbove[0].get('Name');
        }
        else if (Ext.String.startsWith(this.artifactTypeName, 'portfolioitem')) {
            property = 'Parent';
        }

        if (property) {
            // Now add .Parent for every PI level above the lowest until we get to the
            // desired PI type
            _.forEach(this.piTypesAbove, function(piType) {
                if (piType.get('TypePath').toLowerCase() == this.portfolioItemType.toLowerCase()) {
                    return false;
                }
                else {
                    property = property + '.Parent'
                }
            }, this);
        }

        return property;
    }
});

Ext.define('Utils.AncestorPiAppFilter', {
    alias: 'plugin.UtilsAncestorPiAppFilter',
    mixins: [
        'Ext.AbstractPlugin',
        'Rally.Messageable'
    ],
    extend: 'Ext.Component',

    statics: {
        RENDER_AREA_ID: 'utils-ancestor-pi-app-filter',
        PANEL_RENDER_AREA_ID: 'multi-level-pi-app-filter-panel'
    },

    config: {
        /**
         * @cfg {Boolean}
         * The id of the component where the plugin will render its controls
         */
        renderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the filter button will render itself
         */
        btnRenderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the tabbed filter panel will render itself
         */
        panelRenderAreaId: 'multi-level-pi-app-filter-panel',

        /**
         * @cfg {Boolean}
         * Set to false to prevent app from displaying a multi-level PI filter
         */
        displayMultiLevelFilter: true,

        /**
         * @cfg {Boolean}
         * Set to true to indicate that this component is a publisher of events
         * to other apps using this plugin
         */
        publisher: false,

        /**
         * @cfg {Boolean}
         * Set to false to prevent the '-- None --' selection option if your app can't support
         * querying by a null ancestor (e.g. Lookback _ItemHierarchy)
         */
        allowNoEntry: true,

        /**
         * @cfg {Object}
         * Config applied to the app settings components
         */
        settingsConfig: {},

        /**
         * @cfg {Object}
         * Fetch list for PI Selector
         */
        defaultFetch: true,

        /**
         * @cfg {Array}
         * Whitelist array for inline filters
         */
        whiteListFields: ['Tags', 'Milstones'],

        /**
         * @cfg {Array}
         * Blacklist array for inline filters
         */
        blackListFields: [],

        /**
         * @cfg {Boolean}
         * Setting for inlineFilterButtonConfig
         */
        filterChildren: false,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker
         */
        ancestorLabel: 'With ancestor',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ancestorLabelWidth: 110,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown with the ancestor filter
         */
        ownerLabel: 'and owned by',

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown by itself
         */
        ownerOnlyLabel: 'Owned by',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ownerLabelWidth: 110,


        /**
         * @cfg {Number}
         * Style of the Portfolio Item Type picker label
         */
        labelStyle: 'font-size: medium',

        /**
         * @cfg {Number}
         * Minimum width for single row layout
         */
        singleRowMinWidth: 840,

        /**
         * @cfg {Array}
         * Field list for multi-level filter panel
         */
        defaultFilterFields: ['Owner'],

        /**
         * @cfg {Boolean}
         * Set to true to hide filters on load
         */
        filtersHidden: false,

        /**
         * @cfg {Boolean}
         * Set to true to hide advanced filters on load
         */
        advancedFilterCollapsed: false
    },
    filterControls: [],
    portfolioItemTypes: [],
    readyDeferred: null,
    piTypesDeferred: null,
    isSubscriber: false,
    changeSubscribers: [],
    publishedValue: {},

    constructor: function () {
        this.callParent(arguments);
        this._setupPubSub();
        Ext.tip.QuickTipManager.init();
    },

    initComponent: function () {
        this.callParent(arguments);
        this.addEvents('ready', 'select', 'change');
    },

    init: function (cmp) {
        this.cmp = cmp;

        this.cmp.on('resize', this._onCmpResize, this);

        // Get the area where plugin controls will render
        this.renderArea = this.cmp.down('#' + this.renderAreaId);

        // Get the area where filter button will render
        this.btnRenderArea = this.cmp.down('#' + this.btnRenderAreaId);

        // Get the area where tabbed filter panel will render
        this.panelRenderArea = this.cmp.down('#' + this.panelRenderAreaId);

        // Extend app settings fields
        var cmpGetSettingsFields = this.cmp.getSettingsFields;
        this.cmp.getSettingsFields = function () {
            return this._getSettingsFields(cmpGetSettingsFields.apply(cmp, arguments));
        }.bind(this);

        // Extend app default settings fields
        var appDefaults = this.cmp.defaultSettings;
        appDefaults['Utils.AncestorPiAppFilter.enableAncestorPiFilter2'] = false;
        appDefaults['Utils.AncestorPiAppFilter.projectScope'] = 'current';
        appDefaults['Utils.AncestorPiAppFilter.enableMultiLevelPiFilter'] = false;
        this.cmp.setDefaultSettings(appDefaults);

        Ext.override(Rally.ui.inlinefilter.InlineFilterPanel, {
            // We don't want chevrons in the tab panel
            _alignChevron: function () {
                if (this.chevron) { this.chevron.hide(); }
            },

            // Don't create the close buttons
            _createCloseButton: function () { }
        });

        // Add the control components then fire ready
        Rally.data.util.PortfolioItemHelper.getPortfolioItemTypes().then({
            scope: this,
            success: function (piTypes) {
                this.portfolioItemTypes = piTypes;
                Promise.all([this._addAncestorControls(), this._addFilters()]).then(
                    function () {
                        this._setReady();
                    }.bind(this),
                    function (error) {
                        Rally.ui.notify.Notifier.showError({ message: error });
                        this._setReady();
                    }.bind(this)
                );
            },
            failure: function () {
                Rally.ui.notify.Notifier.showError({ message: 'Failed to fetch portfolio item types for multi-level filter' });
            }
        });
    },

    notifySubscribers: function (changeType) {
        var data = this._getValue();
        data.changeType = changeType;
        _.each(this.changeSubscribers, function (subscriberName) {
            this.publish(subscriberName, data);
        }, this);
    },

    // Returns a filter that will ensure results are children of the
    // selected ancestor portfolio item. type is the TypeDefinition 
    // for the Portfolio Item level you wish to fetch.
    getAncestorFilterForType: function (type) {
        var filter;
        var modelName = type.toLowerCase();
        var currentValues = this._getValue();

        if (currentValues.piTypePath) {
            var selectedPiTypePath = currentValues.piTypePath;
            var selectedRecord = currentValues.isPiSelected;
            var selectedPi = currentValues.pi;
            var pisAbove = this._piTypeAncestors(modelName, selectedPiTypePath);
            if (selectedRecord && selectedPi !== null && pisAbove !== null) {
                var property = this._propertyPrefix(modelName, pisAbove);
                if (property) {
                    filter = new Rally.data.wsapi.Filter({
                        property: property,
                        value: selectedPi
                    });
                }
            }
            else if (selectedPi !== null) {
                // Filter out any items of this type because the ancestor pi filter is
                // enabled, but this type doesn't have any pi ancestor types
                filter = new Rally.data.wsapi.Filter({
                    property: 'ObjectID',
                    value: 0
                });
            }
        }

        return filter;
    },

    // Returns an array containing all of the filters applied in the
    // multi-level filter as well as the selected ancestor PI if one
    // is selected. 
    // type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getAllFiltersForType: async function (type, includeFiltersBelowType) {
        let ancestorFilter = this.getAncestorFilterForType(type);
        let filters = ancestorFilter ? [ancestorFilter] : [];
        let multiFilters = await this.getMultiLevelFiltersForType(type, includeFiltersBelowType);
        filters = filters.concat(multiFilters);

        return filters;
    },

    // Returns an array containing all of the filters applied in the multi-level filter for a given PI type. 
    // Type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getMultiLevelFiltersForType: async function (type, includeFiltersBelowType) {
        let filters = [];
        let modelName = type.toLowerCase();
        let multiLevelFilters = this.getMultiLevelFilters();
        let keys = Object.keys(multiLevelFilters);

        for (let i = 0; i < keys.length; i++) {
            let currentType = keys[i];
            let currentFilters = multiLevelFilters[currentType];

            if (currentFilters.length) {
                // If scoping all projects, filter releases by name instead of value
                await this._convertReleaseFilters(currentFilters);

                // If we're at the given level, just add the filters
                if (modelName === currentType.toLowerCase()) {
                    filters = filters.concat(currentFilters);
                }
                // If we're at a level above the given level, convert filters to fit given level
                else {
                    let parentFilters = await this._getParentFilters(modelName, currentType, currentFilters);
                    filters = filters.concat(parentFilters);
                }
            }
        }

        // If building a hierarchy from top level down, we don't need to include filters
        // below the given type (e.g. a timeline app). Otherwise if being used for an app
        // that only displays one PI type, we need to include those lower filters
        if (includeFiltersBelowType && Ext.String.startsWith(type.toLowerCase(), 'portfolioitem')) {
            let childFilter = await this._getChildFiltersForType(type, multiLevelFilters);
            if (childFilter) {
                filters.push(childFilter);
            }
        }

        return filters;
    },

    // Returns an array containing all of the filters applied to a specific PI level.
    // type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getFiltersOfSingleType: async function (type) {
        let filters = [];
        let modelName = type.toLowerCase();
        let multiLevelFilters = this.getMultiLevelFilters();
        let keys = Object.keys(multiLevelFilters);

        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let val = multiLevelFilters[key];
            if (modelName === key.toLowerCase()) {
                await this._convertReleaseFilters(val);
                filters = filters.concat(val);
            }
        }

        return filters;
    },

    // Returns an object containing all of the filters applied in the multi-level
    // filter. Keys are the type definition field and the resulting values are arrays
    // of filters
    getMultiLevelFilters: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filters;
        }

        var filters = {};
        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
            filters[typeName] = filterControl.inlineFilterButton.getFilters();
        });

        return filters;
    },

    // Starting at the lowest PI type, get a list of IDs that fit the given filter. 
    // Traverse up the PI hierarchy until reaching the given type and return a list of IDs
    // for that type that fit all filters from below
    // Returns an array of object IDs
    _getChildFiltersForType: async function (type, filters) {
        let idFilter;
        // PI types are in order lowest to highest
        for (let i = 0; i < this.portfolioItemTypes.length; i++) {
            let currentType = this.portfolioItemTypes[i].get('TypePath');
            let currentFilter = filters[currentType];
            if (currentType.toLowerCase() === type.toLowerCase()) {
                break;
            }
            if ((currentFilter && currentFilter.length) || idFilter) {
                if (!currentFilter) {
                    currentFilter = [];
                }
                if (idFilter) {
                    currentFilter.push(idFilter);
                }

                // To reduce the number of results returned, we include filters of higher level PI types
                for (let j = i + 1; j < this.portfolioItemTypes.length; j++) {
                    let parentType = this.portfolioItemTypes[j].get('TypePath');
                    let parentFilters = await this._getParentFilters(currentType, parentType, filters[parentType]);
                    currentFilter = currentFilter.concat(parentFilters);
                }

                let ancestor = this.getAncestorFilterForType(type);
                if (ancestor && ancestor.value) {
                    currentFilter.push(ancestor);
                }

                let records = await new Promise(function (resolve, reject) { this._getFilteredIds(currentFilter, currentType, resolve, reject); }.bind(this)).catch((e) => {
                    throw new Error(e);
                });

                if (records.length) {
                    let parents = _.map(records, function (id) { return (id.get('Parent') && id.get('Parent').ObjectID) || 0; });
                    idFilter = new Rally.data.wsapi.Filter({
                        property: 'ObjectID',
                        operator: 'in',
                        value: _.uniq(parents)
                    });
                }
                else {
                    idFilter = new Rally.data.wsapi.Filter({
                        property: 'ObjectID',
                        operator: '=',
                        value: 0
                    });
                }
            }
        }
        return idFilter;
    },

    // Given a type and a parent type and array of parent filters, convert the filters
    // to apply to the given type
    _getParentFilters: async function (type, parentType, parentFilters) {
        let pisAbove = this._piTypeAncestors(type, parentType);

        if (pisAbove !== null) {
            let parentProperty = this._propertyPrefix(type, pisAbove);
            if (parentProperty) {
                let currentLevelFilters = [];
                let hasCustomFieldFilters = this._hasCustomFilters(parentFilters);
                _.each(parentFilters, function (filter) {
                    let prop = filter.property;
                    if (!hasCustomFieldFilters) {
                        prop = `${parentProperty}.${prop}`;
                    }

                    currentLevelFilters.push(new Rally.data.wsapi.Filter({
                        property: prop,
                        operator: filter.operator,
                        value: filter.value
                    }));
                }.bind(this));

                // If filters on custom fields exist, lets get a list of IDs at that level and use those IDs as our filter
                if (hasCustomFieldFilters) {
                    let parentIDs = [];
                    try {
                        parentIDs = await new Promise(function (resolve, reject) { this._getFilteredIds(currentLevelFilters, parentType, resolve, reject); }.bind(this)).catch((e) => {
                            throw new Error(e);
                        });
                        if (parentIDs.length) {
                            return new Rally.data.wsapi.Filter({
                                property: parentProperty + '.ObjectID',
                                operator: 'in',
                                value: _.map(parentIDs, function (id) { return id.get('ObjectID'); })
                            });
                        }
                        else {
                            return new Rally.data.wsapi.Filter({
                                property: parentProperty + '.ObjectID',
                                operator: '=',
                                value: 0
                            });
                        }
                    }
                    catch (e) {
                        return [new Rally.data.wsapi.Filter({
                            property: parentProperty + '.ObjectID',
                            operator: '=',
                            value: 0
                        })];
                    }
                }
                else {
                    return currentLevelFilters;
                }
            }
        }
        return [];
    },

    _hasCustomFilters: function (filters) {
        for (let filter of filters) {
            // Rally has a hard time filtering on custom dropdown fields on parents (probably
            // not indexed) so we check to see if any are applied
            if (filter.property.indexOf('c_') !== -1 && typeof filter.value === 'string') {
                return true;
            }
        }
        return false;
    },

    // Takes an array of filters. If scoping across all projects, we need to update any release
    // filters to filter on the release name rather than the release value
    _convertReleaseFilters: async function (filters) {
        if (this.getIgnoreProjectScope()) {
            for (let i = 0; i < filters.length; i++) {
                if (filters[i].property === 'Release') {
                    let release = await this._getRelease(filters[i].value);
                    if (release) {
                        filters[i] = new Rally.data.wsapi.Filter({
                            property: 'Release.Name',
                            value: release.Name
                        });
                    }
                }
            }
        }
    },

    _getRelease: async function (releaseVal) {
        let deferred = Ext.create('Deft.Deferred');

        Ext.Ajax.request({
            url: Ext.String.format('/slm/webservice/v2.0{0}?fetch=Name', releaseVal),
            success(response) {
                if (response && response.responseText) {
                    let obj = Ext.JSON.decode(response.responseText);
                    if (obj && obj.Release) {
                        deferred.resolve(obj.Release);
                    }
                    else {
                        deferred.resolve(null);
                    }
                } else {
                    deferred.resolve(null);
                }
            }
        });

        return deferred.promise;
    },

    getSelectedPiRecord: function () {
        return this._getValue().piRecord;
    },

    getIgnoreProjectScope: function () {
        return this._getValue().ignoreProjectScope;
    },

    // Returns an object of states for all of the inline filters
    // Used for getting and setting shared views
    getMultiLevelFilterStates: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filterStates;
        }

        var states = {};
        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
            states[typeName] = filterControl.inlineFilterButton.getState();
        });

        return states;
    },

    getModels: function () {
        return this.models;
    },

    getPortfolioItemTypes: function () {
        return this.portfolioItemTypes;
    },

    // Sets the states of the inline filters
    // Used when applying a shared view to the filters
    setMultiLevelFilterStates: function (states) {
        if (!this._isSubscriber()) {
            this.tabPanel.removeAll();
            for (let key in states) {
                if (states.hasOwnProperty(key)) {
                    for (let i = 0; i < this.filterControls.length; i++) {
                        let typeName = (this.filterControls[i].inlineFilterButton.modelNames) || 'unknown';
                        if (typeName === key) {
                            this.filterControls[i].inlineFilterButton.applyState(states[key]);
                        }
                    }
                }
            }
            setTimeout(function () { this.tabPanel.setActiveTab(0); }.bind(this), 1500);
        }
    },

    // Returns an array of records fitting the given filters
    _getFilteredIds: function (filters, model, resolve, reject) {
        let dataContext = Rally.getApp().getContext().getDataContext();
        if (this.getIgnoreProjectScope()) {
            dataContext.project = null;
        }

        let ancestor = this.getAncestorFilterForType(model);
        if (ancestor && ancestor.value) {
            filters.push(ancestor);
        }

        let store = Ext.create('Rally.data.wsapi.Store', {
            autoLoad: false,
            context: dataContext,
            filters,
            model,
            fetch: ['ObjectID', 'Parent'],
            limit: Infinity,
            enablePostGet: true
        });

        store.load().then({
            scope: this,
            success: function (records) {
                resolve(records);
            },
            failure: function () {
                //Rally.ui.notify.Notifier.showError({ message: 'Multi-level filter failed while filtering out items above or below selected portfolio item type. Result set was probably too large.' });
                reject('Multi-level filter failed while filtering out items above or below selected portfolio item type. Result set was probably too large.');
                //resolve([]);
                // reject('Multi-level filter failed while filtering out items above or below selected portfolio item type. Result set was probably too large.'); // TODO REJECT!!!!!
            }
        });
    },

    _getLowestFilteredOrdinal: function () {

    },

    _setupPubSub: function () {
        if (this.publisher) {
            this.subscribe(this, 'registerChangeSubscriber', function (subscriberName) {
                // Register new unique subscribers
                if (!_.contains(this.changeSubscribers, subscriberName)) {
                    this.changeSubscribers.push(subscriberName);
                }
                this.publish(subscriberName, this._getValue());
            }, this);
            // Ask any existing subscribers to re-register
            this.publish('reRegisterChangeSubscriber');
        }
        else {
            this.subscriberEventName = Rally.getApp().getAppId() + this.$className;
            // Subscribe to a channel dedicated to this app
            this.subscribe(this, this.subscriberEventName, function (data) {
                if (this.intervalTimer) {
                    clearInterval(this.intervalTimer);
                    delete this.intervalTimer;
                }
                if (!this.isSubscriber) {
                    this.isSubscriber = true;
                    this._hideControlCmp();
                }
                this.publishedValue = data;

                // Default to an ancestor change event for backwards compatibility
                if (data.changeType === 'ancestor' || !data.changeType) {
                    this._onSelect();
                }
                else {
                    this._onChange();
                }
            }, this);
            // Attempt to register with a publisher (if one exists)
            this.publish('registerChangeSubscriber', this.subscriberEventName);
            this.intervalTimer = setInterval(function () {
                this.publish('registerChangeSubscriber', this.subscriberEventName);
            }.bind(this), 500);
            this.subscribe(this, 'reRegisterChangeSubscriber', function () {
                this.publish('registerChangeSubscriber', this.subscriberEventName);
            }, this);
        }
    },

    _getValue: function () {
        var result = {};
        if (this._isSubscriber()) {
            result = this.publishedValue || {};
        }
        else {
            if (this.piTypeSelector) {
                var selectedPiType = this.piTypeSelector.getRecord();
                if (selectedPiType && this.piSelector) {
                    var selectedPiTypePath = selectedPiType.get('TypePath');
                    var selectedRecord = this.piSelector.getRecord();
                    var selectedPi = this.piSelector.getValue();
                    _.merge(result, {
                        piTypePath: selectedPiTypePath,
                        isPiSelected: !!selectedPi,
                        pi: selectedPi,
                        piRecord: selectedRecord
                    });
                }
            }
            result.ignoreProjectScope = this._ignoreProjectScope();
            result.filters = this.getMultiLevelFilters();
            result.filterStates = this.getMultiLevelFilterStates();
        }
        return result;
    },

    _setReady: function () {
        this._updateReleaseValues();

        this.ready = true;

        if (this._isSubscriber() && this.tabPanel) {
            this.tabPanel.hide();
        }

        if (this._isSubscriber() && this.showFiltersBtn) {
            this.showFiltersBtn.hide();
        }

        this.fireEvent('ready', this);
    },

    // Ancestor filter dropdowns have been selected
    _onSelect: function () {
        if (this.ready) {
            this.fireEvent('select', this);
        }
    },

    // Multi-level filters have changed
    _onChange: function () {
        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    _getSettingsFields: function (fields) {
        var currentSettings = Rally.getApp().getSettings();
        if (!currentSettings.hasOwnProperty('Utils.AncestorPiAppFilter.projectScope')) {
            currentSettings['Utils.AncestorPiAppFilter.projectScope'] = 'user';
        }
        var pluginSettingsFields = [{
            xtype: 'rallycheckboxfield',
            id: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            name: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            fieldLabel: 'Filter artifacts by ancestor portfolio item',
        }, {
            xtype: 'rallyportfolioitemtypecombobox',
            id: 'Utils.AncestorPiAppFilter.defaultPiType',
            name: 'Utils.AncestorPiAppFilter.defaultPiType',
            fieldLabel: "Default Portfolio Item type",
            valueField: 'TypePath',
            allowNoEntry: false,
            defaultSelectionPosition: 'last',
            // Disable the preference enabled combo box plugin so that this control value is app specific
            plugins: []
        },
        {
            xtype: 'radiogroup',
            fieldLabel: 'Show artifacts from',
            columns: 1,
            vertical: true,
            allowBlank: false,
            items: [{
                boxLabel: "User's current project(s).",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'current',
                checked: 'current' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            }, {
                boxLabel: "All projects in workspace.",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'workspace',
                checked: 'workspace' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            }, {
                boxLabel: 'User selectable (either current project(s) or all projects in workspace).',
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'user',
                checked: 'user' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            },],
            listeners: {
                scope: this,
                change: function () {
                    return;
                }
            }
        },
        {
            xtype: 'rallycheckboxfield',
            id: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            name: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            fieldLabel: 'Enable multi-level portfolio item filter',
        }
        ];
        pluginSettingsFields = _.map(pluginSettingsFields, function (pluginSettingsField) {
            return _.merge(pluginSettingsField, this.settingsConfig);
        }, this);
        // apply any settings config to each field added by the plugin
        return pluginSettingsFields.concat(fields || []);
    },

    // When changing projects, if a release filter was previously applied, the inline filter state remembers the release
    // filter, but fails to populate the comobobox with the release name, which becomes misleading to 
    // the end user. This hack finds the release name and shoves it into the combobox.
    _updateReleaseValues: function () {
        _.each(this.filterControls, function (filter) {
            _.each(filter.inlineFilterButton.inlineFilterPanel.advancedFilterPanel.advancedFilterRows.rows, function (row) {
                if (row.name === 'Release' && row._valueFieldIsValid()) {
                    _.each(row.items.items, function (rowItem) {
                        if (rowItem.xtype === 'rallyreleasecombobox') {
                            this._getRelease(rowItem.originalValue).then(function (release) {
                                if (release) {
                                    rowItem.rawValue = release.Name;
                                }
                            });
                        }
                    }, this);
                }
            }, this);
        }, this);
    },

    // Requires that app settings are available (e.g. from 'beforelaunch')
    _addAncestorControls: function () {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        var ownerLabelWidth = this.ownerLabelWidth;
        if (this.cmp.getWidth() < this.singleRowMinWidth) {
            controlsLayout = 'vbox';
            ownerLabelWidth = this.ancestorLabelWidth;
        }
        var scopeControlByItself = false;
        if (this._showAncestorFilter() === false && this._showIgnoreProjectScopeControl() === true) {
            scopeControlByItself = true;
        }
        var controls = {
            xtype: 'container',
            id: 'controlsArea',
            overflowX: 'auto',
            layout: {
                type: 'hbox',
                align: 'top'
            },
            items: [{
                xtype: 'container',
                id: 'pubSubIndicatorArea',
                width: 25,
                padding: '6 5 0 0',
                hidden: !this.publisher && !this._isSubscriber(),
                items: [{
                    xtype: 'component',
                    id: 'publisherIndicator',
                    html: '<span class="icon-bullhorn icon-large"></span>',
                    hidden: !this.publisher
                },
                {
                    xtype: 'component',
                    id: 'subscriberIndicator',
                    html: '<span class="icon-link icon-large"></span>',
                    hidden: !this._isSubscriber()
                },
                ]
            }, {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: [{
                    xtype: 'container',
                    id: 'ancestorFilterArea',
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'container',
                        id: 'piTypeArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle'
                        },
                    },
                    {
                        xtype: 'container',
                        id: 'piSelectorArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle',
                            padding: '0 0 0 5'
                        },
                    }
                    ]
                }, {
                    xtype: 'container',
                    itemId: 'scopeControlArea',
                    id: 'scopeControlArea',
                    width: 250,
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'rallycombobox',
                        itemId: 'ignoreScopeControl',
                        id: 'ignoreScopeControl',
                        stateful: true,
                        stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.ignoreProjectScopeControl'),
                        stateEvents: ['select'],
                        hidden: this._isSubscriber() || !this._showIgnoreProjectScopeControl(),
                        displayField: 'text',
                        valueField: 'value',
                        labelStyle: this.labelStyle,
                        labelWidth: ownerLabelWidth,
                        fieldLabel: scopeControlByItself ? this.ownerOnlyLabel : this.ownerLabel,
                        // Don't set initial value with this component or it will override the state
                        storeConfig: {
                            fields: ['text', 'value'],
                            data: [{
                                text: "Current Project(s)",
                                value: false
                            }, {
                                text: "Any Project",
                                value: true
                            }]
                        },
                        listeners: {
                            scope: this,
                            change: function () {
                                this._onSelect();
                            }
                        },
                    }]
                }]
            }]
        };

        if (this.renderArea) {
            // Without this, the components are clipped on narrow windows
            this.renderArea.setOverflowXY('auto', 'auto');
            this.renderArea.add(controls);
        }

        this._addTooltips();

        // Need to get pi types sorted by ordinal lowest to highest for the filter logic to work
        return new Promise(function (resolve) {
            if (!this._isSubscriber() && this._showAncestorFilter()) {
                // Now create the pi type selector
                this._addPiTypeSelector().then(function () {
                    this._addPiSelector(this.piTypeSelector.getValue(), null).then(
                        function () {
                            resolve();
                        }.bind(this)
                    );
                }.bind(this));
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _addPiTypeSelector: function (initialValue) {
        return new Promise(function (resolve) {
            this.piTypeSelector = Ext.create('Rally.ui.combobox.PortfolioItemTypeComboBox', {
                xtype: 'rallyportfolioitemtypecombobox',
                id: 'Utils.AncestorPiAppFilter.piType',
                name: 'Utils.AncestorPiAppFilter.piType',
                width: 250,
                // Disable the preference enabled combo box plugin so that this control value is app specific
                plugins: [],
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piType'),
                stateEvents: ['select'],
                fieldLabel: this.ancestorLabel,
                labelWidth: this.ancestorLabelWidth,
                labelStyle: this.labelStyle,
                valueField: 'TypePath',
                value: initialValue || this._defaultPortfolioItemType(),
                allowNoEntry: false,
                defaultSelectionPosition: 'first',
                listeners: {
                    scope: this,
                    ready: function (combobox) {
                        // Unfortunately we cannot use the combobox store of PI types for our filter
                        // logic because it is sorted by ordinal from highest to lowest so that the
                        // picker options have a an order familiar to the user.

                        // Don't add the change listener until ready. This prevents us
                        // from adding and removing the pi selector multiple times during
                        // startup which causes a null ptr exception in that component
                        combobox.addListener({
                            scope: this,
                            change: this._onPiTypeChange
                        });
                        resolve();
                    }
                }
            });
            this.renderArea.down('#piTypeArea').add(this.piTypeSelector);
        }.bind(this));
    },

    _addTooltips: function () {
        Ext.tip.QuickTipManager.register({
            target: 'publisherIndicator',
            text: 'This app broadcasts filter settings to any enabled ancestor filtered apps (indicated with <span class="icon-link icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        Ext.tip.QuickTipManager.register({
            target: 'subscriberIndicator',
            text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        if (this._isSubscriber()) {
            Ext.tip.QuickTipManager.register({
                target: 'subscriberFilterIndicator',
                text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
                showDelay: 50,
                border: true
            });
        }
    },

    _onCmpResize: function (cmp, width) {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        if (width < this.singleRowMinWidth) {
            controlsLayout = {
                type: 'vbox'
            };
        }
        var filtersArea = this.renderArea.down('#filtersArea');
        if (filtersArea) {
            var controlsArea = this.renderArea.down('#controlsArea');
            var filters = filtersArea.removeAll(false);
            var newFiltersArea = {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: filters,
                hidden: filtersArea.isHidden()
            };
            controlsArea.remove(filtersArea, false);
            controlsArea.add(newFiltersArea);
        }
    },

    _hideControlCmp: function () {
        if (this.renderArea) {
            this.renderArea.down('#pubSubIndicatorArea').show();
            this.renderArea.down('#subscriberIndicator').show();
            this.renderArea.down('#filtersArea').hide();
        }
    },

    _onPiTypeChange: function (piTypeSelector, newValue) {
        if (newValue) {
            let currentPi = this._getValue().pi;
            this._removePiSelector();
            this._addPiSelector(newValue).then(
                function () {
                    this._setReady();
                    // If an ancestor was selected it has now been cleared, so fire select event
                    if (currentPi) {
                        this._onSelect();
                    }
                }.bind(this)
            );
        }
    },

    _removePiSelector: function () {
        this.renderArea.down('#piSelectorArea').removeAll(true);
    },

    _addPiSelector: function (piType, initialValue) {
        return new Promise(function (resolve) {
            this.piSelector = Ext.create('Rally.ui.combobox.ArtifactSearchComboBox', {
                id: 'Utils.AncestorPiAppFilter.piSelector',
                width: 250,
                labelAlign: 'top',
                storeConfig: {
                    models: piType,
                    autoLoad: true,
                    fetch: this.defaultFetch,
                    context: {
                        project: null
                    }
                },
                queryDelay: 2000,
                typeAhead: false,
                validateOnChange: false,
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piSelector'),
                stateEvents: ['select'],
                valueField: '_ref',
                allowClear: true,
                clearValue: null,
                allowNoEntry: this.allowNoEntry,
                noEntryValue: '',
                value: initialValue || '',
                // forceSelection: false,
                defaultSelectionPosition: null,
                listeners: {
                    scope: this,
                    select: function () {
                        this._onSelect();
                    },
                    ready: function () {
                        resolve();
                    }
                }
            });
            // Allow this combobox to save null state (which is default behavior of
            // stateful mixin, but for some reason was overridden in combobox)
            Ext.override(this.piSelector, {
                saveState: function () {
                    var me = this,
                        id = me.stateful && me.getStateId(),
                        hasListeners = me.hasListeners,
                        state;

                    if (id) {
                        state = me.getState() || {}; //pass along for custom interactions
                        if (!hasListeners.beforestatesave || me.fireEvent('beforestatesave', me, state) !== false) {
                            Ext.state.Manager.set(id, state);
                            if (hasListeners.statesave) {
                                me.fireEvent('statesave', me, state);
                            }
                        }
                    }
                }
            });
            this.renderArea.down('#piSelectorArea').add(this.piSelector);
        }.bind(this));
    },

    _setPiSelector: function (piType, pi) {
        return new Promise(function (resolve) {
            this.piTypeSelector.suspendEvents(false);
            this.piTypeSelector.setValue(piType);
            this._removePiSelector();
            this._addPiSelector(piType, pi).then(function () {
                this.piSelector.setValue(pi);
                this.piTypeSelector.resumeEvents();
                resolve();
            }.bind(this));
        }.bind(this));
    },

    _showAncestorFilter: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.enableAncestorPiFilter2');
    },

    _showIgnoreProjectScopeControl: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'user';
    },

    _ignoreProjectScope: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.ignoreProjectScope;
        }

        var result = false;
        if (this._showIgnoreProjectScopeControl()) {
            // If the control is shown, that values overrides the ignoreScope app setting
            result = this.renderArea.down('#ignoreScopeControl').getValue();
        }
        else if (this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'workspace') {
            result = true;
        }
        return result;
    },

    _isSubscriber: function () {
        return this.isSubscriber;
    },

    _defaultPortfolioItemType: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.defaultPiType');
    },

    _propertyPrefix: function (typeName, piTypesAbove) {
        var property;
        if (typeName === 'hierarchicalrequirement' || typeName === 'userstory') {
            property = piTypesAbove[0].get('Name');
        }
        else if (typeName === 'defect') {
            property = 'Requirement.' + piTypesAbove[0].get('Name');
        }
        else if (Ext.String.startsWith(typeName.toLowerCase(), 'portfolioitem')) {
            property = 'Parent';
        }

        if (property) {
            // property already gets us to the lowest pi level above the current type
            // for each additional level, add a 'Parent' term, except for the last
            // type in the list which is the currently selected pi type ancestor
            _.forEach(piTypesAbove.slice(1), function () {
                property = property + '.Parent';
            }, this);
        }

        return property;
    },

    /**
     * Return a list of portfolio item types AT or below the selected pi type,
     * that are an ancestor of the given model, or null if there are no pi type
     * ancestors for the given model.
     */
    _piTypeAncestors: function (modelName, selectedPiTypePath) {
        var result = null;
        var selectedPiTypeIndex;
        var modelNamePiTypeIndex;

        if (_.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName)) {
            selectedPiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === selectedPiTypePath.toLowerCase();
            });
            result = this.portfolioItemTypes.slice(0, selectedPiTypeIndex + 1);
        }
        else if (Ext.String.startsWith(modelName.toLowerCase(), 'portfolioitem')) {
            modelNamePiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === modelName.toLowerCase();
            });
            selectedPiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === selectedPiTypePath.toLowerCase();
            });

            if (modelNamePiTypeIndex < selectedPiTypeIndex) {
                // Don't include the current model pi in the list of ancestors
                // Include the selcted pi type ancestor
                result = this.portfolioItemTypes.slice(modelNamePiTypeIndex + 1, selectedPiTypeIndex + 1);
            }
        }

        return result;
    },

    /*
        Multi-Level Filter functions
    */
    _showMultiLevelFilter: function () {
        return this.cmp.getSetting('Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter');
    },

    _addFilters: function () {
        return new Promise(function (resolve, reject) {
            var promises = [];
            if (this._showMultiLevelFilter() && !this._isSubscriber()) {
                if (this.btnRenderArea) {
                    if (!this._isSubscriber()) {
                        this.showFiltersBtn = this.btnRenderArea.add(
                            {
                                xtype: 'rallybutton',
                                cls: this.filtersHidden ? 'secondary' : 'primary' + ' rly-small',
                                iconCls: 'icon-filter',
                                toolTipText: + this.filtersHidden ? 'Show' : 'Hide' + ' Filters',
                                handler: this._toggleFilters,
                                scope: this
                            }
                        );

                        var piTypePaths = _.map(this.portfolioItemTypes, function (piType) {
                            return piType.get('TypePath');
                        });
                        piTypePaths.reverse();

                        Rally.data.ModelFactory.getModels({
                            types: piTypePaths,
                            context: this.cmp.getContext(),
                            scope: this,
                            success: function (models) {
                                this.models = models;

                                this.tabPanel = this.panelRenderArea.add({
                                    xtype: 'tabpanel',
                                    width: '98%',
                                    cls: 'blue-tabs',
                                    minTabWidth: 100,
                                    plain: true,
                                    autoRender: true,
                                    hidden: this._isSubscriber(),
                                    hideMode: 'offsets',
                                    items: []
                                });

                                this.filterControls = [];
                                let clearAdvancedButtonConfig = {};
                                let matchTypeConfig = {};
                                let advancedFilterRowsFlex = 1;
                                let propertyFieldConfig = {
                                    blackListFields: this.blackListFields,
                                    whiteListFields: this.whiteListFields
                                };

                                if (this.cmp.getWidth() < this.singleRowMinWidth) {
                                    clearAdvancedButtonConfig = {
                                        text: 'Clear'
                                    };
                                    matchTypeConfig = {
                                        fieldLabel: 'Match',
                                        width: 65
                                    };
                                    propertyFieldConfig.width = 100;
                                    advancedFilterRowsFlex = 2;
                                }

                                _.each(models, function (model, key) {
                                    promises.push(new Promise(function (newResolve) {
                                        let filterName = `inlineFilter${key}`;
                                        this.filterControls.push(Ext.create('Rally.ui.inlinefilter.InlineFilterControl', {
                                            xtype: 'rallyinlinefiltercontrol',
                                            name: filterName,
                                            autoRender: true,
                                            stateful: true,
                                            stateId: this.cmp.getContext().getScopedStateId(`multi-${filterName}-control`),
                                            itemId: filterName,
                                            context: this.cmp.getContext(),
                                            inlineFilterButtonConfig: {
                                                stateful: true,
                                                stateId: this.cmp.getContext().getScopedStateId(`multi-${filterName}`),
                                                context: this.cmp.getContext(),
                                                modelNames: key,
                                                filterChildren: this.filterChildren,
                                                inlineFilterPanelConfig: {
                                                    autoRender: true,
                                                    name: `${filterName}-panel`,
                                                    itemId: `${filterName}-panel`,
                                                    model: model,
                                                    padding: 5,
                                                    width: '98%',
                                                    context: this.cmp.getContext(),
                                                    quickFilterPanelConfig: {
                                                        defaultFields: this.defaultFilterFields,
                                                        addQuickFilterConfig: {
                                                            whiteListFields: this.whiteListFields,
                                                            blackListFields: this.blackListFields
                                                        }
                                                    },
                                                    advancedFilterPanelConfig: {
                                                        collapsed: this.advancedFilterCollapsed,
                                                        advancedFilterRowsConfig: {
                                                            propertyFieldConfig,
                                                            flex: advancedFilterRowsFlex
                                                        },
                                                        matchTypeConfig,
                                                        clearAdvancedButtonConfig
                                                    }
                                                },
                                                listeners: {
                                                    inlinefilterchange: this._onFilterChange,
                                                    inlinefilterready: function (panel) {
                                                        this._onFilterReady(panel);
                                                        newResolve();
                                                    },
                                                    scope: this
                                                }
                                            }
                                        }));
                                    }.bind(this)));
                                }, this);

                                Promise.all(promises).then(function () {
                                    if (!this._isSubscriber()) {
                                        this.clearAllButton = Ext.widget({
                                            xtype: 'rallybutton',
                                            itemId: 'clearAllButton',
                                            cls: 'secondary rly-small clear-all-filters-button',
                                            text: 'Clear All',
                                            margin: '3 9 3 0',
                                            hidden: !this._hasFilters(),
                                            listeners: {
                                                click: this._clearAllFilters,
                                                scope: this
                                            }
                                        });

                                        this.btnRenderArea.add(this.clearAllButton);
                                        this.tabPanel.setActiveTab(0);
                                        if (this.filtersHidden) {
                                            this.tabPanel.hide();
                                        }

                                        // Without this, the components are clipped on narrow windows
                                        this.btnRenderArea.setOverflowXY('auto', 'auto');
                                    }
                                    resolve();
                                }.bind(this));
                            },
                            failure: function () {
                                reject('Failed to fetch models for multi-level filter');
                            }
                        });
                    }
                    else {
                        this.btnRenderArea.add({
                            xtype: 'container',
                            id: 'filterSubIndicatorArea',
                            width: 25,
                            padding: '6 5 0 0',
                            items: [
                                {
                                    xtype: 'component',
                                    id: 'subscriberFilterIndicator',
                                    html: '<span class="icon-link icon-large"></span>'
                                }
                            ]
                        });
                        resolve();
                    }
                } else {
                    reject('Unable to find button render area for multi-level filter');
                }
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _clearAllFilters: function () {
        this.suspendEvents(false);
        this.suspendLayouts();

        // The quick filters don't properly clear if the filter isn't displayed
        let activeTab = this.tabPanel.getActiveTab();

        _.each(this.filterControls, function (filterControl) {
            try {
                this.tabPanel.setActiveTab(filterControl.tab);
                filterControl.inlineFilterButton.clearAllFilters();
            }
            catch (e) {
                console.log(e);
            }
        }.bind(this));

        this.tabPanel.setActiveTab(activeTab);

        if (this.clearAllButton) {
            this.clearAllButton.hide();
        }

        this.resumeEvents();
        this.resumeLayouts(false);
        this.updateLayout();
        this.fireEvent('change', this.getMultiLevelFilters());
    },

    _hasFilters: function () {
        var filters = this.getMultiLevelFilters();
        var returnVal = false;

        _.each(filters, function (filter) {
            if (filter.length) {
                returnVal = true;
            }
        });

        return returnVal;
    },

    _onFilterReady: function (panel) {
        panel.expand();
        let filterCount = panel.quickFilterPanel.getFilters().length + panel.advancedFilterPanel.getFilters().length;
        let modelName = (panel.model && panel.model.elementName) || 'unknown';

        let tab = this.tabPanel.add({
            title: modelName + (filterCount ? ` (${filterCount})` : ''),
            html: '',
            itemId: `${modelName}-tab`,

        });

        tab.add({
            xtype: 'container',
            layout: 'hbox',
            items: [panel]
        });

        panel.tab = tab;
    },

    _applyFilters: function () {
        this.suspendEvents(false);
        this.suspendLayouts();
        _.each(this.filterControls, function (filterControl) {
            filterControl.inlineFilterButton._applyFilters();
        });
        this.resumeEvents();
        this.resumeLayouts(false);
        this.updateLayout();
    },

    _onFilterChange: function () {
        if (this.clearAllButton) {
            if (this._hasFilters()) {
                this.clearAllButton.show();
            }
            else {
                this.clearAllButton.hide();
            }
        }

        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.inlineFilterPanel.model.elementName) || 'unknown';
            this._setTabText(typeName, filterControl.inlineFilterButton.getFilters().length);
        }, this);

        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    _setTabText: function (typeName, filterCount) {
        var titleText = filterCount ? `${typeName} (${filterCount})` : typeName;
        var tab = this.tabPanel.child(`#${typeName}-tab`);

        if (tab) { tab.setTitle(titleText); }
    },

    _toggleFilters: function (btn) {
        if (this.tabPanel.isHidden()) {
            this.tabPanel.show();
            btn.setToolTipText('Hide Filters');
            btn.addCls('primary');
            btn.removeCls('secondary');
        } else {
            this.tabPanel.hide();
            btn.setToolTipText('Show Filters');
            btn.addCls('secondary');
            btn.removeCls('primary');
        }
    }
});
Ext.override(Rally.ui.gridboard.SharedViewComboBox, {
    /**
     * This override fixes a bug in the SharedViewComboBox which prevents a newly created
     * view from appearing in the view picker until after an app reload
     */
    _isViewPreference: function(record) {
        return record.self.typePath === 'preference' &&
            record.get('Type') === 'View' &&
            // This is fix. Must use '==' not '===' for this to return true
            record.get('AppId') == this.getContext().getAppId();
    },

    /**
     * This override allows the `enableUrlSharing` option to work.
     * Must override `window.location` with `parent.location`.
     */
    getSharedViewParam: function() {
        var hash = parent.location.hash,
            matches = hash.match(/sharedViewId=(\d+)/);

        return matches && matches[1];
    },

    /**
     * Override to avoid a race condition when restoring columns when using
     * `enableUrlSharing`
     * _ensureLatestView is called out of the constructor after initComponent before store.load(), but store.load() is called immediately after
     * by the parent combobox. The asynchronous store.model.load() here will race with store.load() invoked by the parent. If
     * the store.load returns first, this function would miss the load event and never apply the latest view columns.
     * 
     * Ensure we don't miss the store.load() event by registering an event handler now (before the parent calls store.load()) and
     * that handler can act on the store.model.load() promise when it resolves. This allows both loads to proceed in parallel without
     * possibly missing the load event.
     */
    _ensureLatestView: function(state) {
        if (state.objectId && state.versionId) {
            var modelLoadDeferred = Ext.create('Deft.Deferred');
            this.store.model.load(state.objectId, {
                fetch: ['VersionId', 'Value'],
                success: function(record) {
                    modelLoadDeferred.resolve(record);
                }
            });
            this.store.on('load', function() {
                modelLoadDeferred.promise.then({
                    success: function(record) {
                        if (record && record.get('VersionId') !== state.versionId) {
                            this._applyView(this._decodeValue(record));
                        }
                    },
                    scope: this
                })
            }, this, { single: true });
        }
    },
})

Ext.define('Constants', {
    statics: {
        FEATURE_FETCH: ['ObjectID', 'FormattedID', 'Name', 'PercentDoneByStoryCount', 'PercentDoneByStoryPlanEstimate', 'Project', 'DisplayColor', 'Predecessors', 'Successors'],
        STORIES_FETCH: ['ObjectID', 'FormattedID', 'Name', 'Iteration', 'Project', 'StartDate', 'EndDate', 'Predecessors', 'Successors', 'AcceptedDate'],
        STORY_COLUMNS: ['FormattedID', 'Name', 'PlanEstimate', 'ScheduleState'],
        RELEASE_CONTROL_LABEL: 'Release Tracking',
        RELEASE_CONTROL_LABEL_CLASS: 'ts-page-label',
        UNSCHEDULED: 'Unscheduled',
        START_DATE: 'Iterations from',
        END_DATE: 'to',
        PORTFOLIO_ITEMS: 'Portfolio Items'
    }
})

/* global Ext */
Ext.define('FeatureStoriesDependenciesPopover', {
    extend: Rally.ui.popover.DependenciesPopover,

    titleIconCls: null,
    title: 'Stories With Dependencies',

    constructor: function (config) {
        var numPredecessors = 0,
            numSuccessors = 0;
        _.each(config.stories, function (story) {
            var predecessorsAndSuccessors = story.get('PredecessorsAndSuccessors');
            if (predecessorsAndSuccessors) {
                numPredecessors += predecessorsAndSuccessors.Predecessors;
                numSuccessors += predecessorsAndSuccessors.Successors;
            }
            if (numPredecessors || numSuccessors) {
                return false; // No need to keep counting
            }
        }, this);

        config.items = [{
            xtype: 'tabpanel',
            activeTab: numPredecessors === 0 && numSuccessors > 0 ? 1 : 0,
            items: [{
                title: 'Predecessors',
                html: 'Loading...',
                tabConfig: {
                    width: 160
                },
            },
            {
                title: 'Successors',
                html: 'Loading...',
                tabConfig: {
                    width: 160
                }
            }
            ],
            listeners: {
                afterRender: this._onAfterRender,
                tabChange: this._onAfterRender,
                scope: this
            }
        }];

        this.loaded = {};
        //this.callSuper(arguments);
        // Get super super method (skip the extended DependenciesPopover.constructor()
        return this.superclass.superclass['constructor'].apply(this, arguments);
    },

    // fireEvent: function (eventName) {
    //     console.log(eventName);
    //     this.callParent(arguments);
    // },

    _loadData: function (tabTitle) {
        var promises = _.map(this.stories, function (story) {
            return story.getCollection(tabTitle, {
                fetch: this.fetchFields[this._getType(story)],
                requester: this
            }).load().then({
                scope: this,
                success: function (records) {
                    story.get(tabTitle)['Stories'] = records;
                    return story;
                }
            });
        }, this);

        Deft.promise.Promise.all(promises).then({
            scope: this,
            success: this._onDataRetrieved
        });
    },

    _buildContent: function (stories) {
        var html = [],
            fieldName = this._getTabPanel().getActiveTab().title;

        _.each(stories, function (story) {
            story.tplType = this._getType(story);
            var dependencies = story.get(fieldName).Stories;
            if (dependencies && dependencies.length) {
                // Add a row for the story
                html.push(this.rowTpl.apply(story));
                // Add a row for each story dependency
                _.each(dependencies, function (dependentStory) {
                    dependentStory.set('_dependencyType', fieldName);
                    html.push(this.depRowTpl.apply(dependentStory));
                }, this);
            }
            else {
                // Don't show stories with no dependencies

                // Add a "None" row
                html.push(this.noneRowTpl.apply({
                    _dependencyType: fieldName
                }));

            }
        }, this);

        return '<div class="outer-container">' + html.join("\n") + '</div>';
    },

    rowTpl: Ext.create('Ext.XTemplate',
        '<div class="dependency-row">',
        '<div class="identifier">',
        '{[this.getFormattedIdTemplate(values.data)]} <span class="object-name dependency-title">{[this.trimText(values.data, 40, "")]}</span>',
        '</div>',
        '<div class="status">',
        '<tpl if="this.isUserStory(values)">',
        '{[this.getScheduleState(values)]}',
        '</div>',
        '<span class="field-label">Iteration:</span> <span class="object-name iteration">{[this.trimText(values.data.Iteration, 25, "Unscheduled")]}</span>',
        '<tpl else>',
        '<div class="percent-done-wrapper">{[this.getPercentDoneByStoryCount(values)]}</div>',
        '</div>',
        '<tpl if="this.hasReleaseAttr(values.data)">',
        '<span class="field-label">Release:</span>  <span class="object-name release">{[this.trimText(values.data.Release, 25, "Unscheduled")]}</span>',
        '<tpl else>',
        '<span>&nbsp;</span>',
        '</tpl>',
        '</tpl>',
        '</div>', {
        isUserStory: function (record) {
            return record.tplType === 'hierarchicalrequirement';
        },
        getFormattedIdTemplate: function (data) {
            return Ext.create('Rally.ui.renderer.template.FormattedIDTemplate', {
                showIcon: true,
                showHover: false
            }).apply(data);
        },
        getScheduleState: function (record) {
            return Ext.create('Rally.ui.renderer.template.ScheduleStateTemplate', {
                field: record.getField('ScheduleState')
            }).apply(record.data);
        },
        getPercentDoneByStoryCount: function (record) {
            return Ext.create('Rally.ui.renderer.template.progressbar.PercentDoneByStoryCountTemplate', {
                field: record.getField('PercentDoneByStoryCount'),
                record: record
            }).apply(record.data);
        },
        trimText: function (data, max, defaultValue) {
            return data && data.Name ? Ext.String.ellipsis(data.Name, max) : defaultValue;
        },
        hasReleaseAttr: function (data) {
            return data.hasOwnProperty('Release');
        }
    }
    ),

    depRowTpl: Ext.create('Ext.XTemplate',
        '<div class="dependency-row ts-dependent-story">',
        '<div class="identifier">',
        '<span class="{[this.getDependencyIconClass(values.data)]}"></span>',
        '{[this.getFormattedIdTemplate(values.data)]} <span class="object-name dependency-title">{[this.trimText(values.data, 40, "")]}</span>',
        '</div>',
        '<div class="status">',
        '<tpl if="this.isUserStory(values)">',
        '{[this.getScheduleState(values)]}',
        '</div>',
        '<span class="field-label">Iteration:</span> <span class="object-name iteration">{[this.trimText(values.data.Iteration, 25, "Unscheduled")]}</span>',
        '<tpl else>',
        '<div class="percent-done-wrapper">{[this.getPercentDoneByStoryCount(values)]}</div>',
        '</div>',
        '<tpl if="this.hasReleaseAttr(values.data)">',
        '<span class="field-label">Release:</span>  <span class="object-name release">{[this.trimText(values.data.Release, 25, "Unscheduled")]}</span>',
        '<tpl else>',
        '<span>&nbsp;</span>',
        '</tpl>',
        '</tpl>',
        '</div>', {
        getDependencyIconClass: function (record) {
            return record._dependencyType == 'Predecessors' ? 'icon-predecessor' : 'icon-successor'
        },
        isUserStory: function (record) {
            return true;
        },
        getFormattedIdTemplate: function (data) {
            return Ext.create('Rally.ui.renderer.template.FormattedIDTemplate', {
                showIcon: true,
                showHover: false
            }).apply(data);
        },
        getScheduleState: function (record) {
            return Ext.create('Rally.ui.renderer.template.ScheduleStateTemplate', {
                field: record.getField('ScheduleState')
            }).apply(record.data);
        },
        getPercentDoneByStoryCount: function (record) {
            return Ext.create('Rally.ui.renderer.template.progressbar.PercentDoneByStoryCountTemplate', {
                field: record.getField('PercentDoneByStoryCount'),
                record: record
            }).apply(record.data);
        },
        trimText: function (data, max, defaultValue) {
            return data && data.Name ? Ext.String.ellipsis(data.Name, max) : defaultValue;
        },
        hasReleaseAttr: function (data) {
            return data.hasOwnProperty('Release');
        }
    }
    ),

    noneRowTpl: Ext.create('Ext.XTemplate',
        '<div class="dependency-row ts-dependent-story">',
        '<div class="identifier">',
        // '<span class="{[this.getDependencyIconClass(values)]}"></span>',
        'No {[this.getDependencyType(values)]}',
        '</div>',
        '</div>', {
        getDependencyIconClass: function (record) {
            return record._dependencyType == 'Predecessors' ? 'icon-predecessor' : 'icon-successor';
        },
        getDependencyType: function (record) {
            return record._dependencyType;
        },
    }
    ),
});

/* globals Ext */
Ext.define('StoryFeatureCard', {
    extend: 'Rally.ui.cardboard.Card',
    alias: 'widget.storyfeaturecard',
    hidden: false,
    lowestPiTypeName: 'Feature',

    initComponent: function () {
        this.hidden = this.isHiddenFunc(this);
        this.callParent(arguments);
        this.feature = this.record.get(this.lowestPiTypeName);
        if (!this.hidden) {
            this.on('ready', this._onReady, this);
        }
    },

    setupPlugins: function () {
        return [
            { ptype: 'rallycardpopover' },
        ];
    },

    reRender: function (highlight) {
        // Convert reRender calls into a re-render of the primary feature card
        if (this.hidden) {
            var primaryCard = this.getVisibleCard(this);
            primaryCard.reRender(highlight);
            primaryCard._onReady(primaryCard);
        }
        else {
            this.callParent(arguments);
            this._onReady(this);
        }
    },

    _onReady: function (card) {
        var stories = this.getAllFeatureStories(this);
        this.storyCount = stories.length;
        this.acceptedStoryCount = 0;
        this.storiesHaveDependencies = false;
        _.each(stories, function (story) {
            if (story.get('AcceptedDate')) {
                this.acceptedStoryCount = this.acceptedStoryCount + 1;
            }

            var predSuc = story.get('PredecessorsAndSuccessors');
            if (predSuc && predSuc.Count) {
                this.storiesHaveDependencies = true;
            }
        }, this);
        this.update(this._buildFinalHtml());
        this._addFinalListeners();
    },

    _getFeatureColor: function () {
        var artifactColorDiv = {
            tag: 'div',
            cls: 'ts-artifact-color'
        };
        if (this.feature.DisplayColor) {
            artifactColorDiv.style = {
                backgroundColor: this.feature.DisplayColor
            };
        }
        return Ext.DomHelper.createHtml(artifactColorDiv);
    },

    _buildHtml: function () {
        return this._buildInitialHtml();
    },

    _buildInitialHtml: function () {
        var record = this.getRecord();
        var html = [];
        html.push('<div class="ts-card-table-ct"><table class="ts-card-table"><tr>');
        html.push('<td class="ts-card-content">' + this._getFeatureColor() + '</td>');
        html.push('<td class="ts-card-content"><div class="field-content">' + this.feature.FormattedID + '</div></td>');
        html.push('</tr></table>');
        return html.join('\n');
    },

    _buildFinalHtml: function (stories) {
        var record = this.getRecord();
        var feature = record.get(this.lowestPiTypeName);
        var html = [];
        html.push('<div class="ts-card-table-ct"><table class="ts-card-table"><tr>');

        html.push('<td class="ts-card-content">' + this._getFeatureColor() + '</td>');
        html.push('<td class="ts-card-content ts-formatted-id"><div class="field-content">' + this.feature.FormattedID + '</div></td>');
        html.push('<td class="ts-card-content ts-card-icons">');
        if (this.storiesHaveDependencies) {
            html.push('<span class="field-content FeatureStoriesPredecessorsAndSuccessors icon-children"></span>');
            html.push('<span class="field-content FeatureStoriesPredecessorsAndSuccessorsCancel icon-cancel"></span>');
        }
        var featurePred = feature.Predecessors;
        var featureSucc = feature.Successors;
        if ((featurePred && featurePred.Count) || (featureSucc && featureSucc.Count)) {
            html.push('<span class="field-content FeaturePredecessorsAndSuccessors icon-predecessor"></span>');
        }
        html.push('</td>');
        html.push('<td class="ts-card-content ts-accepted-count"><span class="field-content">' + this.acceptedStoryCount + ' / ' + this.storyCount + '</span></td>');
        html.push('</tr></table>');
        return html.join('\n');
    },

    _addFinalListeners: function () {
        var el = this.getEl();
        var table = el.down('.ts-card-table')
        if (table) {
            table.on('click', function (event, target, options) {
                this.fireEvent('story', this);
            }, this);
        }
        var predSucIcon = el.down('.FeatureStoriesPredecessorsAndSuccessors');
        if (predSucIcon) {
            predSucIcon.on('click', function (event, target, options) {
                this.fireEvent('fieldclick', 'FeatureStoriesPredecessorsAndSuccessors', this);
                return false;
            }, this, {
                card: this,
                stopPropagation: true // Prevent stories popup from also showing
            });
        }
        var featurePredSucIcon = el.down('.FeaturePredecessorsAndSuccessors');
        if (featurePredSucIcon) {
            featurePredSucIcon.on('click', function () {
                this.fireEvent('fieldclick', 'FeaturePredecessorsAndSuccessors', this);
                return false;
            }, this, {
                card: this,
                stopPropagation: true // Prevent stories popup from also showing
            });
        }
        var cancelIcon = el.down('.FeatureStoriesPredecessorsAndSuccessorsCancel');
        if (cancelIcon) {
            cancelIcon.on('click', function (event, target, options) {
                this.fireEvent('fieldclick', 'FeatureStoriesPredecessorsAndSuccessorsCancel', this);
                return false;
            }, this, {
                card: this,
                stopPropagation: true // Prevent stories popup from also showing
            });

            cancelIcon.setStyle('display', 'none');
        }
    }
});

Ext.define('Rally.technicalservices.HierarchyExporter', {

    mixins: {
        observable: 'Ext.util.Observable'
    },

    records: undefined,

    constructor: function (config) {
        this.mixins.observable.constructor.call(this, config);
        this.modelName = config.modelName;
        this.records = [];
        this.fileName = config.fileName || "export.csv";
        this.columns = config.columns || [{ dataIndex: 'FormattedID', text: 'ID' }, { dataIndex: 'Name', text: 'Name' }];
        this.portfolioItemTypeObjects = config.portfolioItemTypeObjects || [];
    },
    setRecords: function (type, records) {
        this.records = (this.records || []).concat(records);
    },
    export: function () {

        this.fireEvent('exportupdate', "Preparing export data");

        //var columns = _.filter(this.columns, function(c){ return c.dataIndex !== "FormattedID"; }),
        var columns = this.columns,
            hierarchicalData = this._buildHierarchy(),
            exportData = this._getExportableHierarchicalData(hierarchicalData, columns);

        var ancestorType = this.modelName.toLowerCase();
        if (hierarchicalData.length > 0) {
            ancestorType = hierarchicalData[0]._type;
        }
        columns = this._getAncestorTypeColumns(ancestorType).concat(columns);

        var csv = this._transformDataToDelimitedString(exportData, columns);

        this.saveCSVToFile(csv, this.fileName);
        this.fireEvent('exportcomplete');

    },
    _buildHierarchy: function () {
        var rootItems = [];

        var objectHash = _.reduce(this.records, function (objHash, record) {
            var oid = record.get('ObjectID');
            objHash[oid] = record.getData();
            objHash[oid].loadedChildren = [];
            return objHash;
        }, {});

        this.records = null;

        for (var key in objectHash) {
            /*
             * guess at parent based on populated field.  it is
             * possible for an item to have two parents (e.g., a defect
             * might have a story and a test case related "above" it
             * this will default to the first it finds
             */
            var obj = objectHash[key],
                parent = obj.Parent && obj.Parent.ObjectID ||
                    obj.PortfolioItem && obj.PortfolioItem.ObjectID ||
                    obj.WorkProduct && obj.WorkProduct.ObjectID ||
                    obj.Requirement && obj.Requirement.ObjectID ||
                    obj.TestCase && obj.TestCase.ObjectID;

            //   if (obj._type === 'task') { console.log('obj',parent, obj._type, obj)};
            if (parent && objectHash[parent]) {
                objectHash[parent].loadedChildren.push(obj);
            }
            else {
                var grandParent = obj.Parent && obj.Parent.Parent && obj.Parent.Parent.ObjectID || null;
                if (grandParent && objectHash[grandParent]) {
                    objectHash[grandParent].loadedChildren.push(obj);
                }
                else {
                    rootItems.push(obj);
                }
            }
        }
        return rootItems;
    },
    _transformDataToDelimitedString: function (data, columns) {
        var csvArray = [],
            delimiter = ",",
            rowDelimiter = "\r\n",
            re = new RegExp(delimiter + '|\"|\r|\n', 'g'),
            reHTML = new RegExp('<\/?[^>]+>', 'g'),
            reNbsp = new RegExp('&nbsp;', 'ig');

        var column_keys = _.map(columns, function (c) { return c.dataIndex; }),
            column_headers = _.pluck(columns, 'text');

        csvArray.push(column_headers.join(delimiter));

        Ext.Array.each(data, function (obj) {
            var data = [];
            Ext.Array.each(column_keys, function (key) {
                var val = obj[key];

                if (key === "Parent") {
                    val = obj[key] || obj['PortfolioItem'];
                }

                if (val) {
                    if (reHTML.test(val)) {
                        val = val.replace('<br>', '\r\n');
                        val = Ext.util.Format.htmlDecode(val);
                        val = Ext.util.Format.stripTags(val);
                    }
                    if (reNbsp.test(val)) {
                        val = val.replace(reNbsp, ' ');
                    }

                    if (re.test(val)) { //enclose in double quotes if we have the delimiters
                        val = val.replace(/\"/g, '\"\"');
                        val = Ext.String.format("\"{0}\"", val);
                    }

                }
                data.push(val);
            }, this);
            csvArray.push(data.join(delimiter));
        }, this);

        return csvArray.join(rowDelimiter);
    },
    /**
     * Returns an array of hash rollup data
     *
     * @param rootObjectIDs
     * @param columns - the data index of the columns that we want to export.
     * @param rollupData
     * @returns {Array}
     * @private
     */
    _getExportableHierarchicalData: function (hierarchyData, columns) {

        var exportData = [];

        _.each(hierarchyData, function (r) {
            var ancestors = {};
            var rec = this._getExportDataRow(r, columns, ancestors);
            exportData.push(rec);
            this._addExportChildren(r, exportData, columns, ancestors);
        }, this);

        return exportData;
    },
    _addExportChildren: function (record, exportData, columns, ancestors) {
        var new_ancestors = Ext.clone(ancestors),
            me = this;

        if (Ext.isEmpty(new_ancestors[record._type])) {
            new_ancestors[record._type] = record.FormattedID;
        }

        var children = record.loadedChildren;
        if (children && children.length > 0) {
            _.each(children, function (c) {
                var row = this._getExportDataRow(c, columns, new_ancestors);
                // if this is a descendant of a story, set the field that
                // represents the User Story column to be the first level
                // level story
                var child_type = row._type;
                if (!Ext.isEmpty(new_ancestors[child_type])) {
                    row[child_type] = new_ancestors[child_type];
                }
                exportData.push(row);
                me._addExportChildren(c, exportData, columns, new_ancestors);
            }, this);
        }

        return;
    },
    getTypePathDisplayName: function (modelName) {
        if (modelName.toLowerCase() === 'hierarchicalrequirement') {
            return 'User Story';
        }
        if (modelName.toLowerCase() === 'task') {
            return 'Task';
        }
        if (modelName.toLowerCase() === 'defect') {
            return 'Defect';
        }
        if (modelName.toLowerCase() === 'testcase') {
            return 'Test Case';
        }

        var displayName = '';
        Ext.Array.each(this.portfolioItemTypeObjects, function (p) {
            if (p.get('TypePath').toLowerCase() === modelName.toLowerCase()) {
                displayName = p.get('Name');
                return false;
            }
        });
        return displayName;
    },
    _getExportDataRow: function (recData, columns, ancestors) {
        var rec = Ext.clone(ancestors),
            type = recData._type; //obj.getData('type');

        rec[type] = recData.FormattedID;
        rec.type = this.getTypePathDisplayName(recData._type);
        rec._type = recData._type;

        _.each(columns, function (c) {
            var field = c.dataIndex || null;
            if (field) {
                var data = recData[field];

                if (field === "Predecessors" || field === "Successors") {
                    data = recData[field].Count || 0;
                }
                else if (field === "Parent") {
                    data = recData[field] || recData["PortfolioItem"];
                }

                if (Ext.isObject(data)) {
                    if (data._tagsNameArray && data._tagsNameArray.length > 0) {
                        var names = _.pluck(data._tagsNameArray, 'Name');
                        rec[field] = names.join(',');
                    }
                    else if (data.FormattedID) {
                        rec[field] = data.FormattedID + ": " + data._refObjectName;
                    }
                    else {
                        rec[field] = data._refObjectName;
                    }
                }
                else if (Ext.isDate(data)) {
                    rec[field] = Rally.util.DateTime.formatWithDefaultDateTime(data);
                }
                else {
                    rec[field] = data;
                }
            }
        });

        return rec;
    },
    _getAncestorTypeColumns: function (rootModel) {
        var modelName = rootModel.toLowerCase();
        var columns = [];
        if (modelName == 'hierarchicalrequirement' || Ext.String.startsWith(modelName, 'portfolioitem')) {
            var piTypes = this.portfolioItemTypeObjects,
                piIdx = -1;

            Ext.Array.each(piTypes, function (piObj, idx) {
                if (piObj.get('TypePath').toLowerCase() === rootModel.toLowerCase()) {
                    piIdx = idx;
                }
            });

            columns.push({
                dataIndex: 'hierarchicalrequirement',
                text: 'User Story'
            });

            if (piIdx >= 0) {
                columns = columns.concat(Ext.Array.map(piTypes.slice(0, piIdx + 1), function (piObj) {
                    return {
                        dataIndex: piObj.get('TypePath').toLowerCase(),
                        text: piObj.get('Name')
                    };
                }));
                columns.push({
                    dataIndex: 'type',
                    text: 'Artifact Type'
                });

            }
            columns.reverse();
        }
        return columns;
    },
    saveCSVToFile: function (csv, file_name, type_object) {
        if (type_object === undefined) {
            type_object = { type: 'text/csv;charset=utf-8' };
        }
        this.saveAs(csv, file_name, type_object);
    },
    saveAs: function (textToWrite, fileName) {
        if (Ext.isIE9m) {
            Rally.ui.notify.Notifier.showWarning({ message: "Export is not supported for IE9 and below." });
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], { type: 'text/plain' });
        }
        catch (e) {
            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder && e.name == 'TypeError') {
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob) {
            Rally.ui.notify.Notifier.showWarning({ message: "Export is not supported for this browser." });
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p) {
            window.navigator.msSaveOrOpenBlob(textFileAsBlob, fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url) {
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink) {
                downloadLink.download = fileNameToSaveAs;
            }
            else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome) {
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        }
        else {
            Rally.ui.notify.Notifier.showError({ message: "Export is not supported " });
        }

    },
    createObjectURL: function (file) {
        if (window.webkitURL) {
            return window.webkitURL.createObjectURL(file);
        }
        else if (window.URL && window.URL.createObjectURL) {
            return window.URL.createObjectURL(file);
        }
        else {
            return null;
        }
    },
    destroyClickedElement: function (event) {
        document.body.removeChild(event.target);
    }
});

Ext.define('Rally.technicalservices.HierarchyLoader', {

    storyModelName: 'hierarchicalrequirement',
    taskModelName: 'task',

    mixins: {
        observable: 'Ext.util.Observable'
    },

    model: undefined,
    filters: undefined,
    fetch: undefined,
    childModels: undefined,
    sorters: undefined,

    maxParallelCalls: 6,

    constructor: function(config) {
        this.mixins.observable.constructor.call(this, config);
        this.portfolioItemTypes = config.portfolioItemTypes || [];
        this.model = config.model || null;
        this.fetch = config.fetch || [];
        this.filters = config.filters || [];
        this.loadChildModels = config.loadChildModels || [];
        this.sorters = config.sorters || [];
    },
    load: function() {

        if (!this.model) {
            this.fireEvent('hierarchyloaderror', "No model specified.");
            return;
        }
        if (this.portfolioItemTypes.length === 0) {
            this.fireEvent('hierarchyloaderror', "Portfolio Item Types not initialized.");
            return;
        }
        if (!(this.loadChildModels instanceof Array)) {
            this.fireEvent('hierarchyloaderror', "No child models specified.");
            return;
        }

        var fns = [];
        for (var i = 0; i < this.loadChildModels.length + 4; i++) {
            fns.push(this.fetchNextLevel);
        }

        Deft.Chain.pipeline(fns, this).then({
            success: function() {
                this.fireEvent('hierarchyloadcomplete');
            },
            failure: function(msg) {
                this.fireEvent('hierarchyloaderror', msg);
            },
            scope: this
        });
    },
    fetchNextLevel: function(args) {
        if (!args) {
            return this.fetchRoot();
        }

        args = _.flatten(args);

        if (args.length > 0 && Ext.isFunction(args[0].get)) {
            var type = args[0].get('_type');
            var types = Ext.Array.unique(Ext.Array.map(args, function(arg) { return arg.get('_type'); }));

            this.fireEvent('hierarchyloadartifactsloaded', type, args);

            var portfolioItemTypePaths = _.map(this.portfolioItemTypes, function(type) {
                    return type.get('TypePath').toLowerCase();
                }),
                portfolioItemOrdinal = _.indexOf(portfolioItemTypePaths, type);

            if (portfolioItemOrdinal === 0 && Ext.Array.contains(this.loadChildModels, this.storyModelName)) {
                return this.fetchUserStories(args);
            }
            if (portfolioItemOrdinal > 0 && Ext.Array.contains(this.loadChildModels, portfolioItemTypePaths[portfolioItemOrdinal - 1])) {
                return this.fetchPortfolioItems(portfolioItemTypePaths[portfolioItemOrdinal - 1], args);
            }

            return this.fetchChildrenFromMultipleTypes(types, args);
            // if (type === this.storyModelName ) {
            // this.getAllowedChildTypes(type);
            // return this.fetchTasks(args);
            //}
        }
        return [];
    },

    fetchRoot: function() {
        var fetch = this.fetch.concat(this.getRequiredFetchFields(this.model));
        this.fireEvent('statusupdate', "Loading artifacts");
        var config = {
            model: this.model,
            fetch: fetch,
            filters: this.filters,
            sorters: this.sorters,
            context: this.context
        };

        return this.fetchWsapiRecords(config);
    },
    fetchPortfolioItems: function(type, parentRecords) {

        var fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            chunks = this._getChunks(parentRecords, 'Children', 'Count');

        return this.fetchChunks(type, fetch, chunks, "Parent.ObjectID", Ext.String.format("Please Wait... Loading Children for {0} Portfolio Items", parentRecords.length));
    },
    _getChunks: function(parentRecords, countField, countFieldAttribute) {

        var chunks = [],
            childCount = 0,
            maxListSize = 100,
            childCountTarget = 200,
            idx = 0;

        chunks[idx] = [];
        _.each(parentRecords, function(r) {
            var count = r.get(countField);
            if (countFieldAttribute && count) {
                count = count[countFieldAttribute];
            }
            if (count > 0) { //using story count because it is a more accurate gauge of the number of user stories for a feature than UserStories.Count is, evne though it may not match exactly.
                childCount += count;
                if (childCount > childCountTarget || chunks[idx].length >= maxListSize) {
                    idx++;
                    chunks[idx] = [];
                    childCount = 0;
                }
                chunks[idx].push(r.get('ObjectID'));
            }
        });

        return chunks;
    },
    fetchUserStories: function(parentRecords) {
        var type = this.storyModelName,
            fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            chunks = this._getChunks(parentRecords, 'LeafStoryCount'),
            featureParentName = this.portfolioItemTypes[0].get('Name').replace(/\s/g, '') + ".ObjectID";

        return this.fetchChunks(type, fetch, chunks, featureParentName, Ext.String.format("Please Wait... Loading User Stories for {0} Portfolio Items", parentRecords.length));
    },

    fetchChildrenFromMultipleTypes: function(types, parentRecords) {

        var promises = [];
        Ext.Array.map(types, function(type) {
            child_types = this.getAllowedChildTypes(type);
            if (child_types.length > 0) {
                var parents = Ext.Array.filter(parentRecords, function(parent) {
                    return (parent.get('_type') == type);
                }, this);
                promises.push(function() {
                    return this.fetchChildrenOfMultipleTypes(parents);
                });
            }
        }, this);

        if (promises.length === 0) { return []; }
        return Deft.Chain.sequence(promises, this);
    },
    fetchChildrenOfMultipleTypes: function(parentRecords) {
        var parent_type = parentRecords[0].get('_type');
        var child_types = this.getAllowedChildTypes(parent_type);
        var promises = Ext.Array.map(child_types, function(type) {
            return function() { return this.fetchChildren(type, parentRecords); }
        }, this);

        return Deft.Chain.sequence(promises, this);
    },

    fetchChildren: function(type, parentRecords) {
        var fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            parentType = parentRecords[0].get('_type'),
            childField = this.getChildFieldFor(parentType, type),
            chunks = this._getChunks(parentRecords, childField, 'Count'),
            parentField = this.getParentFieldFor(type, parentType);

        return this.fetchChunks(type, fetch, chunks, parentField + ".ObjectID",
            Ext.String.format("Please Wait... Loading {0} for {1} items", childField, parentRecords.length));
    },

    // fetchTasks: function(parentRecords){
    //     var type = this.taskModelName,
    //         fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
    //         chunks = this._getChunks(parentRecords, 'Tasks', 'Count');
    //
    //     return this.fetchChunks(type, fetch, chunks, "WorkProduct.ObjectID", Ext.String.format("Please Wait... Loading Tasks for {0} User Stories", parentRecords.length));
    // },
    fetchChunks: function(type, fetch, chunks, chunkProperty, statusString) {

        if (!chunks || chunks.length === 0) {
            return [];
        }
        if (chunks[0].length === 0) {
            return [];
        }

        this.fireEvent('statusupdate', statusString);

        var promises = [];
        _.each(chunks, function(c) {
            var filters = _.map(c, function(ids) { return { property: chunkProperty, value: ids }; }),
                config = {
                    model: type,
                    fetch: fetch,
                    sorters: [
                        { property: 'TaskIndex', direction: 'ASC' },
                        { property: 'DragAndDropRank', direction: 'ASC' }
                    ],
                    filters: Rally.data.wsapi.Filter.or(filters),
                    context: { project: null }
                };
            promises.push(function() { return this.fetchWsapiRecords(config); });
        });

        return this.throttle(promises, this.maxParallelCalls, this);
    },
    fetchWsapiRecords: function(config) {
        var deferred = Ext.create('Deft.Deferred');

        config.compact = false;
        config.limit = "Infinity";
        config.allowPostGet = true;

        Ext.create('Rally.data.wsapi.Store', config).load({
            callback: function(records, operation) {
                if (operation.wasSuccessful()) {
                    deferred.resolve(records);
                }
                else {
                    deferred.reject('fetchWsapiRecords error: ' + operation.error.errors.join(','));
                }
            },
            scope: this
        });
        return deferred;
    },

    getChildFieldFor: function(parent_type, child_type) {
        if (parent_type.toLowerCase() === "hierarchicalrequirement" || parent_type.toLowerCase() === "userstory") {
            if (child_type.toLowerCase() == "task") { return 'Tasks'; }
            if (child_type.toLowerCase() == "defect") { return 'Defects'; }
            if (child_type.toLowerCase() == "testcase") { return 'TestCases'; }
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'Children'; }
        }
        if (parent_type.toLowerCase() === "defect") {
            if (child_type.toLowerCase() == "task") { return 'Tasks'; }
            if (child_type.toLowerCase() == "testcase") { return 'TestCases'; }
        }
        if (parent_type.toLowerCase() === "testcase") {
            if (child_type.toLowerCase() == "defect") { return 'Defects'; }
        }
        if (/portfolioitem/.test(parent_type.toLowerCase())) {
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'UserStories'; }
        }
        return null;
    },

    getParentFieldFor: function(child_type, parent_type) {
        if (parent_type.toLowerCase() === "hierarchicalrequirement" || parent_type.toLowerCase() === "userstory") {
            if (child_type.toLowerCase() == "task") { return 'WorkProduct'; }
            if (child_type.toLowerCase() == "defect") { return 'Requirement'; }
            if (child_type.toLowerCase() == "testcase") { return 'WorkProduct'; }
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'Parent'; }
        }
        if (parent_type.toLowerCase() === "defect") {
            if (child_type.toLowerCase() == "task") { return 'WorkProduct'; }
            if (child_type.toLowerCase() == "testcase") { return 'WorkProduct'; }
        }
        if (parent_type.toLowerCase() === "testcase") {
            if (child_type.toLowerCase() == "defect") { return 'TestCase'; }
        }
        if (/portfolioitem/.test(parent_type.toLowerCase())) {
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'PortfolioItem'; }
        }
        return null;

    },
    getAllowedChildTypes: function(type) {
        var allowed_types = [];
        var given_types = this.loadChildModels;

        if (type.toLowerCase() === this.storyModelName.toLowerCase()) {
            allowed_types = ['task', 'defect', 'testcase', this.storyModelName.toLowerCase()];
        }
        if (type.toLowerCase() === 'defect') {
            allowed_types = ['task', 'testcase'];
        }
        if (type.toLowerCase() === 'testcase') {
            allowed_types = ['defect'];
        }

        var types_in_both = Ext.Array.intersect(allowed_types, given_types);
        return types_in_both;
    },

    getRequiredFetchFields: function(type) {
        if (/^portfolioitem/.test(type.toLowerCase())) {
            return ['Children', 'LeafStoryCount', 'Parent', 'ObjectID', 'UserStories'];
        }

        if (type.toLowerCase() === this.storyModelName) {
            return ['FormattedID', 'Children', 'Tasks', 'Parent', 'PortfolioItem', 'HasParent', 'ObjectID', 'TestCases', 'Defects'];
        }

        return ['ObjectID', 'WorkProduct', 'Defects', 'Tasks', 'TestCases', 'Requirement', 'TestCase', 'FormattedID'];
    },
    throttle: function(fns, maxParallelCalls, scope) {

        if (maxParallelCalls <= 0 || fns.length < maxParallelCalls) {
            return Deft.promise.Chain.parallel(fns, scope);
        }


        var parallelFns = [],
            fnChunks = [],
            idx = -1;

        for (var i = 0; i < fns.length; i++) {
            if (i % maxParallelCalls === 0) {
                idx++;
                fnChunks[idx] = [];
            }
            fnChunks[idx].push(fns[i]);
        }

        _.each(fnChunks, function(chunk) {
            parallelFns.push(function() {
                return Deft.promise.Chain.parallel(chunk, scope);
            });
        });

        return Deft.Promise.reduce(parallelFns, function(groupResults, fnGroup) {
            return Deft.Promise.when(fnGroup.call(scope)).then(function(results) {
                groupResults = groupResults.concat(results || []);
                return groupResults;
            });
        }, []);
    }

});

// Remove 'Actuals' from the blacklist
Ext.override(Rally.ui.gridboard.plugin.GridBoardFieldPicker, {
    gridFieldBlackList: [
        // 'Actuals',
        'Changesets',
        'Children',
        // 'Description',
        // 'Notes',
        'ObjectID',
        'Predecessors',
        'RevisionHistory',
        'Subscription',
        'Successors',
        'TaskIndex',
        'Workspace',
        'VersionId'
    ]
});

Ext.override(Rally.ui.inlinefilter.PropertyFieldComboBox, {
    /**
     * @cfg {String[]} whiteListFields
     * field names that should be included from the filter row field combobox
     */
    defaultWhiteListFields: ['Milestones', 'Tags']
});

/**
 * Remove the buffer when responding to 'viewstatesave' events
 */
Ext.override(Rally.ui.gridboard.SharedViewComboBox, {
    initComponent: function () {
        this.callParent(arguments);
        this.cmp.un('viewstatesave', this._onCmpViewStateSave, this);
        this.cmp.on('viewstatesave', this._onCmpViewStateSave, this);
    },
});

Ext.override(Rally.ui.cardboard.plugin.CardPopover, {
    showFeaturePredecessorsAndSuccessors: function () {
        return this._createPopover({
            field: 'PredecessorsAndSuccessors',
            title: 'Portfolio Item Dependencies',
            //width: 750,
            record: this.card.getFeature(this.card),
            offsetFromTarget: [{ x: 0, y: -8 }, { x: 15, y: 0 }, { x: 5, y: 15 }, { x: -15, y: 0 }],
            target: this.card.getEl()// .down('.field-content.FeaturePredecessorsAndSuccessors')
        });
    },

    showFeatureStoriesPredecessorsAndSuccessors: function () {
        var stories = this.card.getAllFeatureStories(this.card);
        return this._createPopover({
            field: 'FeatureStoriesDependenciesPopover',
            //width: 750,
            record: this.card.getRecord(),
            stories: stories,
            offsetFromTarget: [{ x: 0, y: -8 }, { x: 15, y: 0 }, { x: 5, y: 15 }, { x: -15, y: 0 }],
            target: this.card.getEl()// .down('.field-content.FeatureStoriesPredecessorsAndSuccessors')
        });
    }
});

Rally.ui.popover.PopoverFactory.popovers['FeatureStoriesDependenciesPopover'] = function (config) {
    return Ext.create('FeatureStoriesDependenciesPopover', this._getConfig(config));
}

Ext.define('TsExportGrid', {

    extend: 'Ext.Component',

    getExportMenuItems: function () {
        var result = [];
        var models = [this.model];
        result = [{
            text: 'Export Portfolio Items...',
            handler: this._export,
            scope: this,
            childModels: models
        }, {
            text: 'Export Portfolio Items and User Stories...',
            handler: this._export,
            scope: this,
            childModels: models.concat(['hierarchicalrequirement'])
        }, {
            text: 'Export Portfolio Items, User Stories and Tasks...',
            handler: this._export,
            scope: this,
            childModels: models.concat(['hierarchicalrequirement', 'task'])
        }, {
            text: 'Export Portfolio Items and Child Items...',
            handler: this._export,
            scope: this,
            childModels: models.concat(['hierarchicalrequirement', 'task', 'defect', 'testcase'])
        }];

        return result;
    },

    _getGrid: function () {
        return Rally.getApp().down('#' + this.gridId);
    },

    _export: function (args) {
        var columns = this._getExportColumns(),
            fetch = this._getExportFetch(),
            filters = this._getExportFilters(),
            modelName = this.model,
            childModels = args.childModels,
            sorters = this._getExportSorters();

        var exporter = Ext.create('Rally.technicalservices.HierarchyExporter', {
            modelName: modelName,
            fileName: 'hierarchy-export.csv',
            columns: columns,
            portfolioItemTypeObjects: this.portfolioItemTypes

        });
        exporter.on('exportupdate', this._showStatus, this);
        exporter.on('exporterror', this._showError, this);
        exporter.on('exportcomplete', this._showStatus, this);

        var hierarchyLoader = Ext.create('Rally.technicalservices.HierarchyLoader', {
            model: modelName,
            fetch: fetch,
            filters: filters,
            sorters: sorters,
            loadChildModels: childModels,
            portfolioItemTypes: this.portfolioItemTypes,
            context: this.dataContext
        });
        hierarchyLoader.on('statusupdate', this._showStatus, this);
        hierarchyLoader.on('hierarchyloadartifactsloaded', exporter.setRecords, exporter);
        hierarchyLoader.on('hierarchyloadcomplete', exporter.export, exporter);
        hierarchyLoader.on('hierarchyloaderror', this._showError, this)
        hierarchyLoader.load();
    },
    _getExportColumns: function () {
        var grid = this._getGrid();
        if (grid) {
            let filteredColumns = [];

            _.each(grid.getGridOrBoard().columns, function (item) {
                // PredecessorsAndSuccessors column is generated via a template, not from
                // a specific WSAPI attribute. For exporting this data we have to split
                // this column back into 2 separate columns/data points
                if (item.dataIndex === 'PredecessorsAndSuccessors') {
                    let predCol = Ext.create('Rally.ui.grid.FieldColumn', {
                        dataIndex: 'Predecessors',
                        text: 'Predecessors'
                    });

                    let succCol = Ext.create('Rally.ui.grid.FieldColumn', {
                        dataIndex: 'Successors',
                        text: 'Successors'
                    });

                    filteredColumns.push(predCol);
                    filteredColumns.push(succCol);
                }
                else if (item.dataIndex &&
                    item.dataIndex != "DragAndDropRank" &&
                    item.xtype &&
                    item.xtype != "rallytreerankdraghandlecolumn" &&
                    item.xtype != "rallyrowactioncolumn" &&
                    item.text != "&#160;") {
                    filteredColumns.push(item);
                }
            });

            return filteredColumns;
        }
    },
    _getExportFilters: function () {
        var grid = this._getGrid(),
            filters = [],
            query = Rally.getApp().getSetting('query');

        if (grid.currentCustomFilter && grid.currentCustomFilter.filters) {
            // Concat any current custom filters (don't assign as we don't want to modify the currentCustomFilter array)
            filters = filters.concat(grid.currentCustomFilter.filters);
        }

        if (query) {
            filters.push(Rally.data.wsapi.Filter.fromQueryString(query));
        }

        var timeboxScope = this.context.getTimeboxScope();
        if (timeboxScope && timeboxScope.isApplicable(grid.getGridOrBoard().store.model)) {
            filters.push(timeboxScope.getQueryFilter());
        }

        return filters;
    },
    _getExportFetch: function () {
        var fetch = _.pluck(this._getExportColumns(), 'dataIndex');
        if (Ext.Array.contains(fetch, 'TaskActualTotal')) {
            fetch.push('Actuals');
        }

        return fetch;
    },
    _getExportSorters: function () {
        var grid = this._getGrid();
        if (grid) {
            return grid.getGridOrBoard().getStore().getSorters();
        }
    },

    _showError: function (msg) {
        Rally.ui.notify.Notifier.showError({ message: msg });
    },
    _showStatus: function (message) {
        if (message) {
            Rally.ui.notify.Notifier.showStatus({
                message: message,
                showForever: true,
                closable: false,
                animateShowHide: false
            });
        }
        else {
            Rally.ui.notify.Notifier.hide();
        }
    },
});

/* global Ext _ Rally Constants Deft Utils */
Ext.define("release-tracking-with-filters", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    layout: 'border',
    items: [{
        id: 'filter-area',
        region: 'north',
        xtype: 'panel',
        minHeight: 290,
        overflowY: 'auto',
        collapsible: true,
        margins: '0 0 10 0',
        header: {
            cls: 'ts-panel-header',
            padding: '0 0 15 0'
        },
        cls: 'grid-area',
        title: 'FILTERS',
        flex: 1,
        layout: {
            type: 'vbox',
            align: 'stretch'
        },
        items: [{
            id: Utils.AncestorPiAppFilter.RENDER_AREA_ID,
            xtype: 'container',
            layout: {
                type: 'hbox',
                align: 'middle',
                defaultMargins: 5,
            }
        }, {
            id: 'sharedViewsContainer',
            xtype: 'container',
            layout: {
                type: 'hbox',
                align: 'middle',
                defaultMargins: 5,
            }
        }, {
            id: Utils.AncestorPiAppFilter.PANEL_RENDER_AREA_ID,
            xtype: 'container',
            layout: {
                type: 'hbox',
                align: 'middle',
                defaultMargins: 5,
            }
        }]
    }, {
        id: 'left-area',
        region: 'west',
        xtype: 'panel',
        split: true,
        header: {
            cls: 'ts-panel-header',
            padding: '0 0 15 0'
        },
        cls: 'grid-area',
        title: Constants.PORTFOLIO_ITEMS,
        flex: 1,
        layout: {
            type: 'vbox',
            align: 'stretch'
        },
        items: [{
            id: 'grid-area',
            xtype: 'container',
            flex: 1,
            layout: {
                type: 'vbox',
                align: 'stretch'
            },
        }]
    },
    {
        id: 'right-area',
        region: 'center',
        xtype: 'container',
        flex: 2,
        type: 'vbox',
        align: 'stretch',
        overflowX: 'auto',
        overflowY: 'auto',
        items: [{
            id: 'date-range-area',
            xtype: 'container',
            layout: 'hbox',
            minWidth: 700,
            padding: '15 0 15 20',
        }, {
            id: 'board-area',
            xtype: 'container',
            flex: 1,
            type: 'vbox',
            align: 'stretch',
            margin: '0 0 0 20'
        }]
    }
    ],
    config: {
        defaultSettings: {
            // 'ReleaseTrackingWithFilters.dependencyLines': 'noDependencyLines'
        },
    },

    integrationHeaders: {
        name: "release-tracking-with-filters"
    },

    launch: function () {
        Rally.data.wsapi.Proxy.superclass.timeout = 120000;

        Ext.override(Rally.ui.cardboard.CardBoard, {
            getCards: function () {
                let cards = [];
                _.each(this.columnDefinitions, function (column) {
                    cards = cards.concat(column.getCards());
                });
                return cards;
            },
            // fireEvent: function (name) {
            //     console.log(name);
            //     this.callParent(arguments);
            // }
        });

        this.down('#right-area').on('resize', this.onCardboardResize, this);

        let dateRangeArea = this.down('#date-range-area');
        dateRangeArea.add([{
            xtype: 'rallydatefield',
            id: 'start-date-picker',
            fieldLabel: Constants.START_DATE,
            labelWidth: 120,
            labelCls: 'date-label',
            width: 220,
            margin: '0 10 0 0',
            listeners: {
                scope: this,
                change: function (cmp, newValue) {
                    this.timeboxStart = newValue;
                    this._update();
                }
            }
        }, {
            xtype: 'rallydatefield',
            id: 'end-date-picker',
            fieldLabel: Constants.END_DATE,
            labelWidth: 30,
            width: 130,
            labelCls: 'date-label',
            margin: '0 10 0 0',
            listeners: {
                scope: this,
                change: function (cmp, newValue) {
                    this.timeboxEnd = newValue;
                    this._update();
                }
            }
        }, {
            xtype: 'checkbox',
            boxLabel: 'Show Story Dependencies',
            boxLabelCls: 'date-label dependency-label',
            labelWidth: 180,
            width: 235,
            name: 'dependencies',
            inputValue: true,
            itemId: 'storyDependencyCheckbox',
            cls: 'dependency-checkbox',
            margin: '0 10 0 20',
            listeners: {
                scope: this,
                change: function (cmp, showLines) {
                    if (this.previousCancelIcon) {
                        this.previousDepIcon.setStyle('display', 'inline');
                        this.previousCancelIcon.setStyle('display', 'none');
                        this.previousDepIcon = null;
                        this.previousCancelIcon = null;
                    }

                    this.removeDependencyLines();

                    if (showLines) {
                        this.showAllStoryDependencyLines();
                    }
                }
            }
        }]);

        let timeboxScope = this.getContext().getTimeboxScope();
        this._onTimeboxScopeChange(timeboxScope);

        this.ancestorFilterPlugin = Ext.create('Utils.AncestorPiAppFilter', {
            ptype: 'UtilsAncestorPiAppFilter',
            pluginId: 'ancestorFilterPlugin',
            settingsConfig: {},
            whiteListFields: [
                'Tags',
                'Milestones'
            ],
            filtersHidden: false,
            listeners: {
                scope: this,
                ready(plugin) {
                    plugin.addListener({
                        scope: this,
                        select: this._update,
                        change: this._update
                    });
                    this.portfolioItemTypes = plugin.portfolioItemTypes;
                    this.lowestPi = this.portfolioItemTypes[0];
                    this.lowestPiTypePath = this.lowestPi.get('TypePath');
                    this.lowestPiTypeName = this.lowestPi.get('Name');
                    this.modelNames = [this.lowestPiTypePath];
                    Rally.data.wsapi.ModelFactory.getModel({
                        type: this.lowestPiTypePath
                    }).then({
                        scope: this,
                        success: async function (model) {
                            this.lowestPiModel = model;
                            await this._addSharedViewsCombo();
                            this._update();
                        }
                    });
                },
            }
        });

        this.down('#filter-area').on('collapse', this.onResize, this);
        this.down('#filter-area').on('expand', this.onResize, this);

        this.addPlugin(this.ancestorFilterPlugin);
    },

    _addSharedViewsCombo: function () {
        return new Promise(function (resolve) {
            this.down('#sharedViewsContainer').add([
                {
                    xtype: 'rallysharedviewcombobox',
                    title: 'Shared Views',
                    itemId: 'releaseTrackingSharedViewCombobox',
                    enableUrlSharing: true,
                    context: this.getContext(),
                    cmp: this,
                    listeners: {
                        ready: function (combo) {
                            combo.setValue(null);
                            resolve();
                        }
                    }
                }
            ]);
        }.bind(this));
    },

    getCurrentView: function () {
        let ancestorData = Rally.getApp().ancestorFilterPlugin._getValue();

        // Delete piRecord to avoid recursive stack overflow error
        delete ancestorData.piRecord;

        let gridView = this.down('rallygridboard').getCurrentView();
        let views = Ext.apply(gridView, ancestorData);

        return views;
    },

    setCurrentView: function (view) {
        let app = Rally.getApp();
        this.setLoading('Loading View...');
        Ext.suspendLayouts();
        app.settingView = true;
        if (app.ancestorFilterPlugin) {
            if (app.ancestorFilterPlugin.renderArea.down('#ignoreScopeControl')) {
                app.ancestorFilterPlugin.renderArea.down('#ignoreScopeControl').setValue(view.ignoreProjectScope);
            }
            app.ancestorFilterPlugin.setMultiLevelFilterStates(view.filterStates);
            app.ancestorFilterPlugin._setPiSelector(view.piTypePath, view.pi);
        }
        this.down('rallygridboard').setCurrentView(view);

        setTimeout(async function () {
            Ext.resumeLayouts(true);
            app.settingView = false;
            this.setLoading(false);
            app._update();
        }.bind(this), 400);
    },

    _update: async function () {
        if (this.down('#releaseTrackingSharedViewCombobox')) {
            this.down('#releaseTrackingSharedViewCombobox').setValue(null);
        }
        this.setLoading(true);
        this.currentIterations = await this._updateIterationsStore();
        await this._updatePisStore();

        if (!this.loadingFailed) {
            this._addPisGrid(this.piStore);
        } else {
            this.setLoading(false);
        }
    },

    //setLoading: function (loading) {
    // this.setLoading(loading);
    // this.down('#board-area').setLoading(loading);
    // if (this.grid) {
    //     let treegrid = this.grid.down('rallytreegrid');
    //     if (treegrid) {
    //         treegrid.setLoading(loading);
    //     }
    // }
    // },

    // Usual monkey business to size gridboards
    onResize: function () {
        this.callParent(arguments);
        let gridArea = this.down('#grid-area');
        let grid = this.down('rallygridboard');
        if (gridArea && grid) {
            grid.setHeight(gridArea.getHeight());
        }
        return;
    },

    _updatePisStore: async function () {
        this.loadingFailed = false;
        this.currentDataContext = this.getContext().getDataContext();
        if (this.searchAllProjects()) {
            this.currentDataContext.project = null;
        }

        this.currentPiQueries = await this._getPiQueries();

        if (this.loadingFailed) {
            return;
        }

        this.piStore = await Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: [this.lowestPiTypePath],
            autoLoad: false,
            fetch: Constants.FEATURE_FETCH,
            filters: this.currentPiQueries,
            enableHierarchy: true,
            remoteSort: true,
            context: this.currentDataContext,
            enablePostGet: true,
            enableRootLevelPostGet: true,
            clearOnLoad: false

        });
    },

    _getPiQueries: async function () {
        let queries = [];

        switch (this.timeboxType) {
            case 'release':
                queries.push({
                    property: 'Release',
                    value: this.timebox ? this.timebox.get('_ref') : null
                });
                break;
            case 'iteration':
                if (this.timebox) {
                    queries.push({
                        property: 'UserStories.Iteration.Name',
                        value: this.timebox.get('Name')
                    });
                    queries.push({
                        property: 'UserStories.Iteration.StartDate',
                        value: this.timebox.get('StartDate')
                    });
                    queries.push({
                        property: 'UserStories.Iteration.EndDate',
                        value: this.timebox.get('EndDate')
                    });
                }
                else {
                    queries.push({
                        property: 'UserStories.Iteration',
                        value: null
                    });
                }
                break;
            case 'milestone':
                queries.push({
                    property: 'Milestones.ObjectID',
                    value: this.timebox ? this.timebox.get('ObjectID') : null
                });
                break;
            default:
                break;
        }

        if (this.ancestorFilterPlugin) {
            let filters = await this.ancestorFilterPlugin.getAllFiltersForType(this.lowestPiTypePath, false).catch((e) => {
                Rally.ui.notify.Notifier.showError({ message: (e.message || e) });
                this.loadingFailed = true;
            });

            if (filters) {
                queries = queries.concat(filters);
            }
        }

        return queries;
    },

    _updateIterationsStore: async function () {
        let filter = Rally.data.wsapi.Filter.and([{
            property: 'EndDate',
            operator: '>=',
            value: this.timeboxStart
        }, {
            property: 'StartDate',
            operator: '<=',
            value: this.timeboxEnd
        }]);
        this.iterationsStore = Ext.create('Rally.data.wsapi.Store', {
            model: 'Iteration',
            autoLoad: false,
            filters: filter,
            context: this.getContext().getDataContext()
        });
        let iterations = await this.iterationsStore.load();
        return iterations;
    },

    _getDefects: function () {
        // TODO (tj) needed?
    },

    _addPisGrid: function (store) {
        let gridArea = this.down('#grid-area');
        if (gridArea) {
            gridArea.removeAll();
        }
        let currentModelName = this.modelNames[0];
        let allProjectsContext = this.getContext().getDataContext();
        allProjectsContext.project = null;
        let gridExporter = Ext.create('TsExportGrid', {
            model: this.lowestPiTypePath,
            gridId: 'pisGrid',
            context: this.getContext(),
            dataContext: this.currentDataContext,
            portfolioItemTypes: this.portfolioItemTypes,
        });
        this.grid = gridArea.add({
            xtype: 'rallygridboard',
            id: 'pisGrid',
            context: this.getContext(),
            modelNames: this.modelNames,
            toggleState: 'grid',
            height: gridArea.getHeight(),
            listeners: {
                scope: this,
                viewchange: this._update,
                load: function (grid) {
                    this._onGridLoad(grid);
                }
            },
            plugins: [{
                ptype: 'rallygridboardinlinefiltercontrol',
                inlineFilterButtonConfig: {
                    stateful: true,
                    stateId: this.getContext().getScopedStateId('CA.releaseTrackingWithFilters'),
                    hidden: true,
                    modelNames: this.modelNames,
                    inlineFilterPanelConfig: {
                        quickFilterPanelConfig: {
                            dataContext: allProjectsContext,
                            portfolioItemTypes: this.portfolioItemTypes,
                            modelName: this.lowestPiTypePath,
                            whiteListFields: [
                                'Tags',
                                'Milestones'
                            ]
                        }
                    }
                }
            },
            {
                ptype: 'rallygridboardfieldpicker',
                headerPosition: 'left',
                margin: '0 9 0 9',
                modelNames: this.modelNames,
                stateful: true,
                stateId: this.getModelScopedStateId(currentModelName, 'fields'),
            },
            {
                ptype: 'rallygridboardactionsmenu',
                menuItems: gridExporter.getExportMenuItems(),
                buttonConfig: {
                    iconCls: 'icon-export'
                }
            },
            ],
            gridConfig: {
                shouldShowRowActionsColumn: false,
                enableBulkEdit: false,
                enableEditing: false,
                enableColumnMove: false,
                enableInlineAdd: false,
                enableRanking: true,
                store: store,
                storeConfig: {
                    context: this.currentDataContext,
                    filters: this.currentPiQueries,
                    enablePostGet: true,
                    pageSize: 2000,
                    limit: Infinity
                },
                columnCfgs: [{
                    dataIndex: 'FormattedID',
                    text: 'ID'
                }, {
                    dataIndex: 'Name',
                    text: 'Name'
                }],
                listeners: {
                    scope: this,
                    // TODO (tj) support multi item selection
                    /*
                    itemclick: function(grid, record, item, index) {
                        // Ignore clicks on non root items
                        if (record.get('_type') == this.lowestPiTypePath.toLowerCase()) {
                            this._onPiSelected(record);
                        }
                    }
                    */
                }
            }
        });
    },

    _onGridLoad: function (grid) {
        let store = grid.getGridOrBoard().getStore();
        let root = store.getRootNode();

        if (root.childNodes && root.childNodes.length) {
            let oids = _.map(root.childNodes, function (pi) {
                return pi.get('ObjectID');
            }, this).join(',');

            // Performance may be better by using 'in' instead of a collection of ORs
            let query = Ext.create('Rally.data.wsapi.Filter', {
                property: this.lowestPiTypeName + '.ObjectID',
                operator: 'in',
                value: oids
            });

            this.storiesFilter = query;
        }
        else {
            // If there are no PIs, then explicitly filter out all stories
            this.storiesFilter = Rally.data.wsapi.Filter.and({
                property: 'ObjectID',
                value: 0
            });
        }

        // Only consider direct Feature children (not nested stories)
        this.storiesFilter = this.storiesFilter.and({
            property: 'Parent',
            value: null
        });

        let boardPromise = this._addPisBoard(this.storiesFilter, this.currentIterations).then({
            scope: this,
            success: function (board) {
                for (let def of board.rowDefinitions) {
                    def.on('collapse', this.onCardboardResize, this);
                    def.on('expand', this.onCardboardResize, this);
                }

                if (this._shouldShowStoryDependencies()) {
                    this.showAllStoryDependencyLines();
                }
                else {
                    this.setLoading(false);
                }
            }
        });
        return boardPromise;
    },

    _onPiSelected: function (pi) {
        let filter;
        if (this.selectedPi === pi) {
            // Unselecting the pi
            filter = this.storiesFilter;
            delete this.selectedPi;
        }
        else {
            this.selectedPi = pi;
            filter = Rally.data.wsapi.Filter({
                property: this.lowestPiTypeName,
                operator: '=',
                value: pi.get('_ref')
            });
        }
        this.buckets = {};
        this.board.refresh({
            storeConfig: {
                filters: filter,
                enablePostGet: true,
                pageSize: 2000,
                limit: Infinity
            }
        });
    },

    _addPisBoard: function (filter, iterations) {
        let boardDeferred = Ext.create('Deft.Deferred');
        let boardArea = this.down('#board-area');
        boardArea.removeAll();

        this.buckets = {};

        // Create a column for each iteration shared by the projects
        let endDateSorted = _.sortBy(iterations, function (i) {
            return i.get('EndDate');
        });
        let uniqueIterations = _.unique(endDateSorted, function (i) {
            return this._getIterationKey(i);
        }, this);

        let columns = _.map(uniqueIterations, function (iteration) {
            let startDate = iteration.get('StartDate').toLocaleDateString();
            let endDate = iteration.get('EndDate').toLocaleDateString();
            let headerTemplate = new Ext.XTemplate('<div class="iteration-name">{name}</div><div class="iteration-dates">{start} - {end}</dev>').apply({
                name: iteration.get('Name'),
                start: startDate,
                end: endDate
            });
            return {
                xtype: 'rallycardboardcolumn',
                columnHeaderConfig: {
                    headerTpl: headerTemplate,
                    cls: 'cardboard-column-header'
                },
                fields: [this.lowestPiTypeName],
                value: iteration.get('_ref'), // AM TODO, needed to add this, but will it affect dragging and dropping cards?
                additionalFetchFields: Constants.STORIES_FETCH,
                getStoreFilter: function () {
                    // Don't return this column 'value' as a filter
                    return [{
                        property: 'Iteration.StartDate',
                        value: iteration.get('StartDate')
                    },
                    {
                        property: 'Iteration.EndDate',
                        value: iteration.get('EndDate')
                    }
                    ];
                },
                isMatchingRecord: function () {
                    return true;
                }
            };
        }, this);
        // Add a column for unscheduled stories
        columns.push({
            xtype: 'rallycardboardcolumn',
            value: null,
            columnHeaderConfig: {
                headerTpl: Constants.UNSCHEDULED
            },
            fields: [this.lowestPiTypeName],
            additionalFetchFields: Constants.STORIES_FETCH
        });

        this.board = boardArea.add({
            xtype: 'rallycardboard',
            itemId: 'releaseGridboard',
            type: ['HierarchicalRequirement'],
            attribute: 'Iteration',
            storeConfig: {
                filters: filter,
                fetch: [this.lowestPiTypeName].concat(Constants.STORIES_FETCH),
                groupField: this.lowestPiTypeName,
                context: this.currentDataContext,
                enablePostGet: true,
                pageSize: 2000,
                limit: Infinity
            },
            listeners: {
                scope: this,
                load: function (board) {
                    boardDeferred.resolve(board);
                }
            },
            rowConfig: {
                field: 'Project',
                enableCrossRowDragging: false
            },
            columns: columns,
            cardConfig: {
                xtype: 'storyfeaturecard',
                lowestPiTypeName: this.lowestPiTypeName,
                draggable: false,
                isHiddenFunc: this._isCardHidden.bind(this),
                getFeature: function (card) {
                    let story = card.getRecord();
                    let featureRef = story.get(this.lowestPiTypeName);
                    let feature = this.piStore.getById(featureRef);
                    return feature;
                }.bind(this),
                getAllFeatureStories: function (card) {
                    let cards = this._getCardsForCard(card);
                    return _.map(cards, function (card) {
                        return card.getRecord();
                    });
                }.bind(this),
                getVisibleCard: function (card) {
                    let cards = this._getCardsForCard(card);
                    return cards[0];
                }.bind(this),
                listeners: {
                    scope: this,
                    fieldclick: function (fieldName, card) {
                        let depIcon = card.el.down('.FeatureStoriesPredecessorsAndSuccessors');
                        let cancelIcon = card.el.down('.FeatureStoriesPredecessorsAndSuccessorsCancel');

                        if (fieldName === 'FeaturePredecessorsAndSuccessors') {
                            // Show feature to feature dependencies?
                        }
                        else if (fieldName === 'FeatureStoriesPredecessorsAndSuccessors') {
                            if (depIcon && cancelIcon) {
                                depIcon.setStyle('display', 'none');
                                cancelIcon.setStyle('display', 'inline');
                            }

                            if (this.previousDepIcon && this.previousDepIcon !== depIcon) {
                                this.previousDepIcon.setStyle('display', 'inline');
                                this.previousCancelIcon.setStyle('display', 'none');
                            }

                            this.showStoryDependencyLinesForCard(card);
                        }
                        else if (fieldName === 'FeatureStoriesPredecessorsAndSuccessorsCancel') {
                            if (depIcon && cancelIcon) {
                                depIcon.setStyle('display', 'inline');
                                cancelIcon.setStyle('display', 'none');
                            }

                            if (this.previousDepIcon && this.previousDepIcon !== depIcon) {
                                this.previousDepIcon.setStyle('display', 'inline');
                                this.previousCancelIcon.setStyle('display', 'none');
                            }

                            if (this._shouldShowStoryDependencies()) {
                                this.showAllStoryDependencyLines();
                            }
                            else {
                                this.removeDependencyLines();
                            }
                        }
                        this.previousDepIcon = depIcon;
                        this.previousCancelIcon = cancelIcon;
                    },
                    story: function (card) {
                        // TODO (tj) move into StoryFeatureCard
                        let story = card.getRecord();
                        let featureRef = story.get(this.lowestPiTypeName);
                        let feature = this.piStore.getById(featureRef);
                        let context = this.getContext().getDataContext();
                        context.project = story.get('Project')._ref;
                        let iteration = story.get('Iteration');
                        let filters = [];
                        if (iteration) {
                            filters = [{
                                property: 'Iteration.Name',
                                value: iteration.Name
                            }, {
                                property: 'Iteration.StartDate',
                                value: iteration.StartDate
                            }, {
                                property: 'Iteration.EndDate',
                                value: iteration.EndDate
                            }];
                        }
                        else {
                            filters = [{
                                property: 'Iteration',
                                value: null
                            }];
                        }
                        filters.push({
                            property: 'Project',
                            value: context.project
                        });
                        Rally.ui.popover.PopoverFactory.bake({
                            field: 'UserStory',
                            record: feature,
                            target: card.getEl(),
                            context: context,
                            listViewConfig: {
                                gridConfig: {
                                    storeConfig: {
                                        filters: filters,
                                        context: context,
                                        enablePostGet: true
                                    },
                                    columnCfgs: Constants.STORY_COLUMNS,
                                }
                            }
                        });
                    },
                }
            }
        });
        return boardDeferred.promise;
    },

    showAllStoryDependencyLines: function () {
        let def = Ext.create('Deft.Deferred');
        let board = this.down('#releaseGridboard');

        if (board) {
            this.removeDependencyLines();

            this.setLoading('Drawing Dependencies');

            this.getAllStoryPredecessors(board).then({
                scope: this,
                success: function (storyPredObjArray) {
                    if (storyPredObjArray.length) {
                        let lines = [];

                        _.each(storyPredObjArray, function (storyPredObj) {
                            let successorCard = storyPredObj.card.getVisibleCard(storyPredObj.card);

                            _.each(storyPredObj.predecessors, function (pred) {
                                let key = this._getRecordBucketKey(pred);

                                if (this.buckets.hasOwnProperty(key)) {
                                    let predecessorCard = this.buckets[key][0];

                                    // Skip self-dependencies
                                    if (predecessorCard === successorCard) {
                                        return;
                                    }

                                    lines = lines.concat(this.generateDependencyLine(predecessorCard, successorCard));
                                }
                            }, this);
                        }, this);

                        this.drawDependencies(lines);
                    }

                    this.setLoading(false);
                    def.resolve();
                },
                failure: function () {
                    Rally.ui.notify.Notifier.showError({ message: 'Failed to add dependency lines for user stories' });
                    this.setLoading(false);
                    def.resolve();
                }
            });

        }
        else {
            def.resolve();
        }

        return def.promise;
    },

    showStoryDependencyLinesForCard: function (clickedCard) {
        let items = [];
        this.removeDependencyLines();

        // Get list of all cards for this card (1 for each story for this feature + iteration + project)
        let cards = this._getCardsForCard(clickedCard);

        let promises = _.map(cards, function (item) {
            let story = item.getRecord();

            let promise = this.getPredecessorsAndSuccessors(story).then({
                scope: this,
                success: function (predecessorsSuccessors) {
                    _.each(predecessorsSuccessors[0], function (predecessor) {
                        let key = this._getRecordBucketKey(predecessor);
                        if (this.buckets.hasOwnProperty(key)) {
                            let visibleCard = this.buckets[key][0];

                            // Skip self-dependencies
                            if (visibleCard === clickedCard) {
                                return;
                            }

                            items = items.concat(this.generateDependencyLine(visibleCard, clickedCard));
                        }
                    }, this);

                    _.each(predecessorsSuccessors[1], function (successor) {
                        let key = this._getRecordBucketKey(successor);
                        if (this.buckets.hasOwnProperty(key)) {
                            let visibleCard = this.buckets[key][0];

                            // Skip self-dependencies
                            if (visibleCard === clickedCard) {
                                return;
                            }

                            items = items.concat(this.generateDependencyLine(clickedCard, visibleCard));
                        }
                    }, this);
                }
            });

            return promise;
        }, this);

        Deft.promise.Promise.all(promises).then({
            scope: this,
            success: function () {
                this.drawDependencies(items);
            }
        });
    },

    generateDependencyLine: function (predecessorCard, successorCard) {
        // If a project swimlane is collapsed, the card isn't hidden, but it's coordinates will be 0,0
        if (!predecessorCard.getY() || !successorCard.getY()) {
            return [];
        }

        let items = [];
        let angle = 0;
        let stroke = "grey"; // "#D1D1D1";
        let circleRadius = 3;
        let cardHeight = predecessorCard.getHeight();
        let cardWidth = predecessorCard.getWidth();
        let predX = predecessorCard.getX();
        let predY = predecessorCard.getY();
        let succX = successorCard.getX();
        let succY = successorCard.getY();
        let rightAreaEl = this.down('#right-area').getEl();
        let rightAreaScroll = rightAreaEl.getScroll();
        let boardArea = this.down('#board-area');

        // Yellow line if the dependencies are in the same iteration
        if (predX === succX) {
            stroke = "#FAD200";
        }
        // Red line if:
        //     - The predecessor is scheduled for an iteration after the successor's scheduled iteration
        //     OR
        //     - The successor is scheduled for an iteration but the predecessor is not
        else if ((predX > succX) || (!predecessorCard.record.get('Iteration') && successorCard.record.get('Iteration'))) {
            stroke = "#F66349";
        }

        let xOffset = -boardArea.getX() + boardArea.getEl().getMargin().left;
        let yOffset = -rightAreaEl.getY() + rightAreaScroll.top;

        if (predY === succY) {
            predY += cardHeight / 2 + yOffset;
            succY += cardHeight / 2 + yOffset;
        }
        else if (predY > succY) {
            succY += cardHeight + yOffset;
            predY += yOffset;
            angle = -60;
        }
        else {
            predY += cardHeight + yOffset;
            succY += yOffset;
            angle = 60;
        }

        predX += cardWidth + circleRadius + xOffset;
        succX += xOffset - circleRadius;

        // Half Circle
        // items.push({
        //     type: "path",
        //     path: Ext.String.format("M{0} {1} A{2},{2} 0 0,0,{0},0",
        //         p.x, p.y, circleRadius
        //     ),
        //     fill: 'grey'
        // });

        // Dashed line connecting dependencies
        items.push({
            type: "path",
            path: Ext.String.format("M{0} {1} L {2} {3}",
                predX, predY, succX, succY,
            ),
            fill: "transparent",
            stroke,
            "stroke-width": "1",
            "stroke-dasharray": "3",
        });

        // Circle from predecessor
        items.push({
            type: "circle",
            stroke,
            fill: "#f6f6f6",
            "stroke-width": "2",
            radius: circleRadius,
            x: predX,
            y: predY
        });

        // Arrow pointing to successor

        let arrow = Ext.create('Ext.draw.Sprite', {
            type: "path",
            fill: '#f6f6f6',
            stroke,
            "stroke-width": "2",
            transformText: Ext.String.format("rotate(35 {0} {1})",
                succX, succY
            ),
            path: Ext.String.format("M {0} {1} L {2} {3} L {4} {5} z",
                succX,
                succY - circleRadius,
                succX + (circleRadius * 2),
                succY,
                succX,
                succY + circleRadius,
            )
        });

        // let angle = Math.atan2(predY - succY, predX - succX) * 180 / Math.PI;
        // if (angle < 0) {
        //     angle += 360;
        // }
        arrow.setAttributes({
            rotate: {
                degrees: angle
            }
        }, false);

        items.push(arrow);

        return items;
    },

    getAllStoryPredecessors: function (board) {
        let def = Ext.create('Deft.Deferred');
        let cards = board.getCards();

        if (cards.length) {
            let promises = [];

            for (let card of cards) {
                let storyCards = this._getCardsForCard(card);

                _.each(storyCards, function (item) {
                    let story = item.getRecord();

                    if (story.get('Predecessors').Count) {
                        promises.push(this.getPredecessorsForRecord(story, [this.lowestPiTypeName].concat(Constants.STORIES_FETCH)).then({
                            success: function (predecessors) {
                                return { card: item, predecessors };
                            }
                        }));
                    }
                }, this);
            }

            if (!promises.length) {
                def.resolve([]);
            }

            Deft.promise.Promise.all(promises).then({
                scope: this,
                success: function (preds) {
                    // let results = _.flatten(preds);
                    def.resolve(preds);
                },
                failure: function (e) {
                    console.log(e);
                    def.reject();
                }
            });
        }
        else {
            def.resolve([]);
        }

        return def.promise;
    },

    getPredecessorsForRecord: function (record, fetch) {
        let filters = [{ property: 'Feature', operator: '!=', value: null }];

        return record.getCollection('Predecessors', { fetch, filters }).load().then({
            scope: this,
            success: function (predecessors) {
                return predecessors;
            }
        });
    },

    getSuccessorsForRecord: function (record, fetch) {
        let filters = [{ property: 'Feature', operator: '!=', value: null }];

        return record.getCollection('Successors', { fetch, filters }).load().then({
            scope: this,
            success: function (successors) {
                return successors;
            }
        });
    },

    getPredecessorsAndSuccessors: function (record) {
        let fetch = [this.lowestPiTypeName].concat(Constants.STORIES_FETCH);

        let predecessorsPromise = this.getPredecessorsForRecord(record, fetch);
        let successorsPromise = this.getSuccessorsForRecord(record, fetch);

        return Deft.promise.Promise.all([predecessorsPromise, successorsPromise]);
    },

    drawDependencies: function (items) {
        let boardArea = this.down('#board-area');
        let gridboard = this.down('#releaseGridboard');

        this.drawComponent = Ext.create('Ext.draw.Component', {
            style: Ext.String.format('position:absolute; top:{0}px; left:{1}px;z-index:1000;pointer-events:none', 0, 0),
            itemId: 'dependencies',
            id: 'dep',
            viewBox: false,
            floating: false,
            height: gridboard.getHeight(),
            width: gridboard.getWidth() + 40,
            items: items
        });

        boardArea.add(this.drawComponent);
        this.drawComponent.show();
    },

    _getCardBucketKey: function (card) {
        let record = card.getRecord();
        return this._getRecordBucketKey(record);
    },

    _getRecordBucketKey: function (record) {
        let iterationKey = this._getIterationKey(record.get('Iteration'));
        let projectId = record.get('Project').ObjectID;
        let featureId = record.get('Feature').ObjectID;
        return [featureId, projectId, iterationKey].join('-');
    },

    _getIterationKey: function (iteration) {
        let result = '';
        if (iteration) {
            if (iteration.get) {
                result = iteration.get('Name') + iteration.get('StartDate').toISOString() + iteration.get('EndDate').toISOString();
            }
            else {
                result = iteration.Name + iteration.StartDate + iteration.EndDate;
            }
        }
        return result;
    },


    _isCardHidden: function (card) {
        let result = false;
        let key = this._getCardBucketKey(card);
        if (this.buckets.hasOwnProperty(key)) {
            this.buckets[key].push(card);
            result = true;
        }
        else {
            this.buckets[key] = [card];
        }
        return result;
    },

    _getCardsForCard: function (card) {
        let key = this._getCardBucketKey(card);
        let result = this.buckets[key];

        return result;
    },

    getModelScopedStateId: function (modelName, id) {
        return this.getContext().getScopedStateId(modelName + '-' + id);
    },

    getSettingsFields: function () {
        // let currentSettings = Rally.getApp().getSettings();
        // if (!currentSettings.hasOwnProperty('ReleaseTrackingWithFilters.dependencyLines')) {
        //     currentSettings['ReleaseTrackingWithFilters.dependencyLines'] = 'noDependencyLines';
        // }

        // Need at least 1 setting in order to add multi-level filter settings
        return [
            {
                xtype: 'text'
            }
            // {
            //     xtype: 'radiogroup',
            //     fieldLabel: 'Dependencies',
            //     columns: 1,
            //     vertical: true,
            //     allowBlank: false,
            //     items: [{
            //         boxLabel: "Don't show",
            //         name: 'ReleaseTrackingWithFilters.dependencyLines',
            //         inputValue: 'noDependencyLines',
            //         checked: 'noDependencyLines' === currentSettings['ReleaseTrackingWithFilters.dependencyLines']
            //     }, {
            //         boxLabel: "Show single dependency upon clicking a card",
            //         name: 'ReleaseTrackingWithFilters.dependencyLines',
            //         inputValue: 'showSingleDependency',
            //         checked: 'showSingleDependency' === currentSettings['ReleaseTrackingWithFilters.dependencyLines']
            //     }, {
            //         boxLabel: 'Show all story dependencies',
            //         name: 'ReleaseTrackingWithFilters.dependencyLines',
            //         inputValue: 'showDependencyLines',
            //         checked: 'showDependencyLines' === currentSettings['ReleaseTrackingWithFilters.dependencyLines']
            //     },],
            //     // listeners: {
            //     //     scope: this,
            //     //     change: function () {
            //     //         return;
            //     //     }
            //     // }
            // }
        ];
    },

    searchAllProjects: function () {
        return this.ancestorFilterPlugin.getIgnoreProjectScope();
        // return this.scopeControlPlugin.getValue();
    },

    onCardboardResize: function () {
        let board = this.down('#releaseGridboard');

        if (board) {
            this.removeDependencyLines();

            if (this.previousCancelIcon) {
                this.previousDepIcon.setStyle('display', 'inline');
                this.previousCancelIcon.setStyle('display', 'none');
                this.previousDepIcon = null;
                this.previousCancelIcon = null;
            }

            if (this._shouldShowStoryDependencies()) {
                // With many dependencies drawn, the loading mask doesn't properly display
                // and it looks like the app freezes... Not an ideal user experience.
                // A timeout helps everything render properly before redrawing the dependencies
                setTimeout(() => {
                    this.showAllStoryDependencyLines().then({
                        scope: this,
                        success: function () {
                            this.setLoading(false);
                        }
                    });
                }, 500);
            }
        }
    },

    removeDependencyLines: function () {
        if (this.drawComponent) {
            this.down('#board-area').remove(this.drawComponent);
        }
    },

    _shouldShowStoryDependencies: function () {
        return this.down('#storyDependencyCheckbox').getValue();
    },

    onTimeboxScopeChange: function (newTimeboxScope) {
        this.callParent(arguments);
        this._onTimeboxScopeChange(newTimeboxScope);
        this._update();
    },

    _onTimeboxScopeChange: function (timeboxScope) {
        if (timeboxScope) {
            this.timeboxType = timeboxScope.getType();
            this.timebox = timeboxScope.getRecord();
            if (this.timeboxType === 'release') {
                this.timeboxStart = this.timebox ? this.timebox.get('ReleaseStartDate') : new Date();
                this.timeboxEnd = this.timebox ? this.timebox.get('ReleaseDate') : new Date();
            }
            else if (this.timeboxType === 'milestone') {
                this.timeboxStart = this.timebox ? this.timebox.get('TargetDate') : new Date();
                this.timeboxEnd = this.timebox ? this.timebox.get('TargetDate') : new Date();
            }
            else if (this.timeboxType === 'iteration') {
                this.timeboxStart = this.timebox ? this.timebox.get('StartDate') : new Date();
                this.timeboxEnd = this.timebox ? this.timebox.get('EndDate') : new Date();
            }
        }
        else {
            this.timeboxStart = new Date();
            this.timeboxEnd = new Date();
        }

        this._updateDateControls();
    },

    _updateDateControls: function () {
        let startDatePicker = this.down('#start-date-picker');
        startDatePicker.suspendEvents();
        startDatePicker.setValue(this.timeboxStart);
        startDatePicker.resumeEvents();
        let endDatePicker = this.down('#end-date-picker');
        endDatePicker.suspendEvents();
        endDatePicker.setValue(this.timeboxEnd);
        endDatePicker.resumeEvents();
    }
});


               Rally.launchApp('release-tracking-with-filters', {
                   name: 'release-tracking-with-filters'
               });
        });
    </script>

    <style type="text/css">

.app {}

.tsinfolink {
    position: absolute;
    right: 0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.ts-page-label {
    font-weight: bold;
    font-size: medium;
}

.iteration-name {
    font-size: medium;
}

.iteration-dates {
    font-size: x-small;
    font-weight: normal;
}

.cardboard-column-header {
    margin-left: unset;
    margin-right: unset;
}

.date-label {
    font-size: 13px;
    font-weight: bold;
    font-family: ProximaNova, Helvetica, Arial;
    text-transform: uppercase;
}

.dependency-label {
    margin-left: 20px;
}

.dependency-checkbox input {
    margin-top: 1px;
}

.grid-area {
    background-color: rgb(244, 244, 244);
    padding: 10px;
    border: rgb(213, 213, 213);
    border-width: thin;
    border-style: solid;
    border-radius: 4px;
}

.ts-panel-header {
    background-color: rgb(244, 244, 244);
}

.x-panel-header-collapsed {
    background-color: rgb(244, 244, 244);
    padding: 10px;
    border: rgb(213, 213, 213);
    border-width: thin;
    border-style: solid;
    border-radius: 4px;
}

.ts-panel-header .x-panel-header-text {
    font-weight: bold;
}

.ts-artifact-color {
    width: 5px;
    height: 20px;
}

.ts-card-table div {
    font-weight: bold;
    font-size: 1.1em;
    color: #666;
}

.ts-scope-control {
    margin-top: 3px;
    margin-right: 9px;
}

.line {
    z-index: 10000;
    border-bottom-width: 2px;
    border-color: #000000;
    border-bottom-style: solid;
}

.line.predecessor {
    border-color: #FF0000;
    border-bottom-style: solid;
}

.line.successor {
    border-color: #00FF00;
    border-bottom-style: dashed;
}

.dependency-row.ts-dependent-story {
    padding-left: 40px !important;
}

.ts-dependent-story .icon-story {
    display: none;
}

.ts-card-content.ts-card-icons {
    min-width: 50px;
    text-align: center;
    cursor: pointer;
}

.ts-card-content.ts-accepted-count {
    width: 100%;
    color: #888;
    text-align: right;
    cursor: pointer;
}

.x-border-layout-ct {
    background-color: white;
}
.blue-tabs .x-tab-bar .x-tab-default {
    background-color: white;
    border-radius: 4px 4px 0 0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
    color: #00a9e0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-active {
    background-color: #00a9e0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-active .x-tab-inner {
    color: white;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
    text-overflow: initial;
    -o-text-overflow: initial;
    overflow: initial;
  }
  
  .blue-tabs .x-tab-bar .x-tab-inner {
    width: 100%;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-icon-el {
    color: white;
  }
    </style>

</head>
<body></body>
</html>