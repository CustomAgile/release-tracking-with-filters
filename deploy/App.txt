<!DOCTYPE html>
<html>

<head>
    <title>release-tracking-with-filters-1.3.6</title>
    <!--  (c) 2019 Custom Agile.  All Rights Reserved. -->
    <!--  Build Date: Wed Jun 17 2020 16:56:22 GMT-0400 (Eastern Daylight Time) -->
    <!--  Repository: https://github.com/CustomAgile/release-tracking-with-filters -->
    <script type="text/javascript">
        var APP_BUILD_DATE = "Wed Jun 17 2020 16:56:22 GMT-0400 (Eastern Daylight Time)";
        var CHECKSUM = 1326471925410;
    </script>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
             
/* globals Rally */
// Fix the PreliminaryEstimate renderer to sort by value
Rally.ui.renderer.GridEditorFactory.editorRenderers['PreliminaryEstimate'] = function(field) {
    return {
        xtype: 'rallyrecordcontexteditor',
        field: {
            xtype: 'rallycombobox',
            allowNoEntry: !field.required,
            editable: false,
            name: field.name,
            storeConfig: {
                autoLoad: true,
                model: field.name,
                remoteFilter: true,
                sorters: [{
                    property: "Value"
                }],
                listeners: {
                    load: function() {
                        return;
                    }
                }
            }
        }
    };
};

Ext.define('Utils.AncestorPiInlineFilter', {
    override: 'Rally.ui.inlinefilter.QuickFilterPanel',
    portfolioItemTypes: [],
    modelName: undefined,
    customFilterNamePrefix: "AncestorPiInlineFilter.",

    _hasPiAncestor: function(modelName) {
        return _.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName) || Ext.String.startsWith(modelName, 'portfolioitem');
    },

    _pisAbove: function(modelName) {
        var result = [];
        if (_.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName)) {
            result = this.portfolioItemTypes
        }
        else if (Ext.String.startsWith(modelName, 'portfolioitem')) {
            var startIndex = _.findIndex(this.portfolioItemTypes, function(piType) {
                return piType.get('TypePath').toLowerCase() === modelName;
            });
            if (startIndex >= 0 && startIndex < this.portfolioItemTypes.length - 1) {
                result = this.portfolioItemTypes.slice(startIndex + 1);
            }
        }
        return result;
    },

    initComponent: function() {
        if (!this.dataContext) {
            this.dataContext = Rally.getApp().getContext().getDataContext();
        }

        if (this.modelName) {
            this.modelName = this.modelName.toLowerCase();
        }
        var filterFactoryOverrides = {};
        var additionalFields = []
        if (this._hasPiAncestor(this.modelName)) {
            var pisAbove = this._pisAbove(this.modelName);
            _.each(pisAbove, function(piType) {
                var typePath = piType.get('TypePath');
                var customFilterName = this.customFilterNamePrefix + typePath;
                var displayName = 'Portfolio Item / ' + piType.get('Name');
                filterFactoryOverrides[customFilterName] = {
                    xtype: 'ancestorpisearchcombobox',
                    portfolioItemType: typePath, // The artifact type to search for
                    piTypesAbove: pisAbove, // List of portfolio item types
                    artifactTypeName: this.modelName, // The artifact type we are filtering
                    storeConfig: {
                        context: this.dataContext,
                        models: typePath,
                        autoLoad: true
                    },
                    allowNoEntry: true,
                    noEntryValue: null,
                    noEntryText: 'No ' + displayName,
                    emptyText: 'Search ' + displayName + 's...',
                    allowClear: false,
                    valueField: 'ObjectUUID', // Must use ObjectUUID to align with the state that is saved by inlinefilterbutton
                    forceSelection: false
                };
                additionalFields.push({
                    name: customFilterName,
                    displayName: displayName
                })
            }, this);

            // Add the additional fields to the quick filter config
            _.merge(this.addQuickFilterConfig, {
                additionalFields: additionalFields
            }, function(a, b) {
                if (_.isArray(a)) {
                    return _.uniq(a.concat(b), 'name') // Strip duplicates by name that can occur from state
                }
            });

            // Add the corresponding items to the FilterFieldFactory
            Ext.override(Rally.ui.inlinefilter.FilterFieldFactory, filterFactoryOverrides);
        }

        this.callParent(arguments);
    },

    _createFields: function() {
        // Strip out the custom filters from this.fields and this.initialFilters
        this.fields = _.filter(this.fields, function(field) {
            return this._filterInvalidAncestorFilters(field);
        }, this);
        this.initialFilters = _.filter(this.initialFilters, function(filter) {
            return this._filterInvalidAncestorFilters(filter.name);
        }, this);
        this.callParent(arguments);
    },

    /**
     * This will exclude any field restored from state that we didn't explicitly add into the Factory
     * for the current model type. This prevents changes in model types from trying to build an invalid filter
     * for that new model type.
     */
    _filterInvalidAncestorFilters: function(name) {
        return !Ext.String.startsWith(name, this.customFilterNamePrefix) || Rally.ui.inlinefilter.FilterFieldFactory.hasOwnProperty(name)
    }
});

Ext.define('Utils.AncestorPiSearchComboBox', {
    alias: 'widget.ancestorpisearchcombobox',
    extend: 'Rally.ui.combobox.ArtifactSearchComboBox',

    parentField: 'PortfolioItem.Parent.',

    artifactTypeName: undefined, // The name of the model that will be filtered
    piTypesAbove: [],
    statics: {
        UUID_REGEX: /([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})/
    },

    constructor: function(config) {
        if (config.value) {
            Ext.merge(config, {
                storeConfig: {
                    filters: Rally.data.wsapi.Filter.or([{
                            property: config.valueField, // Compensate for parent constructor assuming that filter value is OidFromRef
                            value: config.value
                        }
                        /*, {
                                                property: 'ObjectID',
                                                operator: '!=',
                                                value: 0
                                            }*/
                    ])
                }
            });
        }

        //this.callSuper(arguments);
        // Get super super method (skip the extended ArtifactSearchComboBox.constructor()
        return this.superclass.superclass['constructor'].apply(this, arguments);
    },

    initComponent: function() {
        this.on('change', function(cmp, newValue, oldValue) {
            if (newValue == "") {
                this.store.load({
                    filters: []
                })
            }
        }, this)
        return this.callParent(arguments);
    },

    setValue: function() {
        this.callParent(arguments);
    },

    getFilter: function() {

        var value = this.lastValue;
        var propertyPrefix = this.propertyPrefix();
        var filters = []
        // If the value is a UUID, then use it, otherwise ignore values the user might be typing in
        if (value && this.statics().UUID_REGEX.test(value)) {
            filters.push({
                property: propertyPrefix + ".ObjectUUID",
                value: value
            });
        }
        else {
            filters.push({
                property: propertyPrefix,
                value: null
            });
        }
        return Rally.data.wsapi.Filter.or(filters);
    },

    propertyPrefix: function() {
        var property;
        // Get the path between the selected artifact and the lowest level PI above it
        if (this.artifactTypeName === 'hierarchicalrequirement' || this.artifactTypeName === 'userstory') {
            property = this.piTypesAbove[0].get('Name');
        }
        else if (this.artifactTypeName === 'defect') {
            property = 'Requirement.' + this.piTypesAbove[0].get('Name');
        }
        else if (Ext.String.startsWith(this.artifactTypeName, 'portfolioitem')) {
            property = 'Parent';
        }

        if (property) {
            // Now add .Parent for every PI level above the lowest until we get to the
            // desired PI type
            _.forEach(this.piTypesAbove, function(piType) {
                if (piType.get('TypePath').toLowerCase() == this.portfolioItemType.toLowerCase()) {
                    return false;
                }
                else {
                    property = property + '.Parent'
                }
            }, this);
        }

        return property;
    }
});

Ext.override(Rally.ui.inlinefilter.FilterFieldFactory, {
    _getBaseEditorConfig: function (fieldDef, context) {
        if (fieldDef.name === "CreatedBy") {
            let editorConfig = {
                xtype: "rallyusersearchcombobox",
                fieldLabel: fieldDef.displayName,
                allowNoEntry: false,
                valueField: '_uuidRef',
                storeConfig: {
                    models: [fieldDef.attributeDefinition.AllowedValueType._refObjectName],
                    context: {
                        workspace: context.getDataContext().workspace,
                        project: null
                    }
                }
            };

            return editorConfig;
        }

        return this.callParent(arguments);
    }
});

Ext.override(Rally.ui.inlinefilter.InlineFilterPanel, {
    // We don't want chevrons in the tab panel
    _alignChevron: function () {
        if (this.chevron) { this.chevron.hide(); }
    },

    // Don't create the close buttons
    _createCloseButton: function () { }
});

Ext.override(Ext.form.field.ComboBox, {
    select: function (r) {
        if (r && !r.get('ObjectID') && r.get('_uuidRef') === '/allowedattributevalue/') {
            return;
        }
        this.callParent(arguments);
    }
});

Ext.override(Rally.ui.inlinefilter.QuickFilterPanel, {
    getFilters: function () {
        var filters = [];
        _.each(this.fields, function (field, index) {
            if (field.name === 'ModelType') {
                return;
            }

            if (!Ext.isEmpty(field.lastValue) && !field.hasActiveError()) {

                var lastValue = field.lastValue;

                var isRefUri = Rally.util.Ref.isRefUri(lastValue);
                var isRefOid = _.isNumber(Rally.util.Ref.getOidFromRef(lastValue));
                if (isRefUri && isRefOid && field.valueField === '_ref' && field.noEntryValue !== lastValue) {
                    var record = field.getRecord();
                    if (record) {
                        var uuidRef = record.get('_uuidRef');
                        if (uuidRef) {
                            lastValue = uuidRef;
                        }
                    }
                }

                var filter = _.isFunction(field.getFilter) ? field.getFilter() : Rally.data.wsapi.Filter.fromExtFilter({
                    property: field.name,
                    operator: field.operator,
                    value: lastValue
                });

                if (filter && filter.value !== '/allowedattributevalue/') {

                    if (field.allowNoEntry && field.noEntryValue === lastValue) {
                        filter.value = null;
                    }

                    Ext.apply(filter, {
                        name: field.name,
                        rawValue: lastValue,
                        filterIndex: index + 1
                    });

                    filters.push(filter);
                }
            }
        }, this);
        return filters;
    }
});
Ext.define('CustomAgile.multilevelfilter.ToggleButton', {
    extend: 'Rally.ui.Button',
    alias: 'widget.multifiltertogglebtn',

    stateful: true,

    config: {
        iconCls: 'icon-filter'
    },

    constructor: function (config) {
        this.mergeConfig(config);
        this.callParent([this.config]);
    },

    getState: function () {
        return {
            filtersHidden: this.filtersHidden
        };
    },

    setFiltersHidden: function (filtersHidden) {
        this.filtersHidden = filtersHidden;
        this.saveState();
    }
});
Ext.define('CustomAgile.ui.tutorial.MultiLevelFilterTutorial', {
    singleton: true,

    welcomeHtml: `
        <h3>This component enables filters to be applied to user stories and all levels within the portfolio item hierarchy, regardless of the artifact 
        type displayed in the app.</h3>

        <h3><b>Note:</b> For grid apps that allow expanding individual rows to see child artifacts, these filters are only applied to the top-level artifact type. 
        Child artifacts will not be filtered.</h3>
    `,

    defaultOffset: [
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 }
    ],

    defaultChevronOffset: [
        { x: 0, y: -14 },
        { x: 14, y: 0 },
        { x: 0, y: 14 },
        { x: -8, y: 0 }
    ],

    showWelcomeDialog: function (app) {
        this.app = app;
        this.steps = this.getSteps();

        if (this.app.showFiltersBtn && this.app.showFiltersBtn.filtersHidden) {
            this.app._toggleFilters(this.app.showFiltersBtn);
        }

        let appHeight = Rally.getApp().getHeight() - 25;

        this.welcomeDialog = Ext.create('Rally.ui.dialog.Dialog', {
            autoShow: true,
            layout: 'fit',
            componentCls: 'rly-popover dark-container',
            width: 500,
            height: appHeight < 300 ? appHeight : 300,
            closable: true,
            autoDestroy: true,
            buttonAlign: 'center',
            autoScroll: true,
            title: 'Using the Multi-Level Filter',
            items: {
                xtype: 'component',
                html: this.welcomeHtml,
                padding: 10,
                style: 'font-size:12px;'
            },
            buttons: [
                {
                    xtype: "rallybutton",
                    text: 'Close',
                    cls: 'secondary rly-small',
                    listeners: {
                        click: () => {
                            this.welcomeDialog.close();
                        },
                        scope: this
                    }
                }, {
                    xtype: "rallybutton",
                    text: 'Next',
                    cls: 'primary rly-small',
                    listeners: {
                        click: function () {
                            this.showNextStep(0);
                            this.welcomeDialog.close();
                        },
                        scope: this
                    }
                }
            ]
        });
    },

    showNextStep: function (stepIndex) {
        if (this.popover) {
            Ext.destroy(this.popover);
        }

        if (stepIndex >= this.steps.length) {
            return;
        }

        if (stepIndex === -1) {
            this.showWelcomeDialog(this.app);
            return;
        }

        let currentStep = this.steps[stepIndex];

        if (currentStep.handler) {
            currentStep.handler();
        }

        let buttons = [{
            xtype: "rallybutton",
            text: 'Close',
            cls: 'secondary rly-small',
            listeners: {
                click: () => {
                    this.popover.close();
                },
                scope: this
            }
        }];

        buttons.push({
            xtype: "rallybutton",
            text: 'Previous',
            cls: 'primary rly-small',
            listeners: {
                click: function () {
                    this.showNextStep(stepIndex - 1);
                },
                scope: this
            }
        });

        if (stepIndex < this.steps.length - 1) {
            buttons.push({
                xtype: "rallybutton",
                text: 'Next',
                cls: 'primary rly-small',
                listeners: {
                    click: function () {
                        this.showNextStep(stepIndex + 1);
                    },
                    scope: this
                }
            });
        }

        let appHeight = Rally.getApp().getHeight() - 25;

        this.popover = Ext.create('Rally.ui.popover.Popover', {
            target: Rally.getApp().down(currentStep.target).getEl(),
            placement: currentStep.placement || ['bottom', 'left', 'top', 'right'],
            chevronOffset: currentStep.chevronOffset || this.defaultChevronOffset,
            offsetFromTarget: currentStep.offset || this.defaultOffset,
            overflowY: 'auto',
            maxWidth: 550,
            maxHeight: appHeight < 700 ? appHeight : 700,
            toFront: Ext.emptyFn,
            buttonAlign: 'center',
            title: currentStep.title,
            listeners: {
                destroy: function () {
                    this.popover = null;
                },
                scope: this
            },
            html: `<div class="tutorial-popover-body">${currentStep.html}</div>`,
            buttons
        });
    },

    getSteps: function () {
        let steps = [];

        if (this.app.publisher) {
            steps.push({
                target: '#pubSubIndicatorArea',
                placement: 'right',
                title: 'Broadcaster Indicator',
                offset: [
                    { x: 0, y: 0 },
                    { x: 0, y: 0 },
                    { x: 14, y: 0 },
                    { x: 0, y: 0 }
                ],
                chevronOffset: [
                    { x: 0, y: -14 },
                    { x: 14, y: -40 },
                    { x: 0, y: 14 },
                    { x: -8, y: 0 }
                ],
                html: `
           <p><span class="icon-bullhorn icon-large"></span> This bullhorn icon indicates that the app is broadcasting the selected filters to any apps on the page
         that are listening for filter changes.</p>
            `
            });
        }

        if (this.app._showAncestorFilter()) {
            steps.push({
                target: '#ancestorFilterArea',
                placement: 'bottom',
                title: 'Ancestor Filter',
                html: `
         <p>The ancestor filter allows you to filter the data to show only artifacts that are descendants of the selected artifact. 
         Use the PI Type dropdown to choose which type of Portfolio Item you want the ancestor artifact to be.</p> 
            `
            });
        }

        if (this.app._showIgnoreProjectScopeControl()) {
            let scopeOffsetX = this.app._showAncestorFilter() ? 0 : -250;
            steps.push({
                target: '#ignoreScopeControl',
                placement: 'bottom',
                title: 'Scope Control',
                offset: [
                    { x: 0, y: 0 },
                    { x: 0, y: 0 },
                    { x: 0, y: 15 },
                    { x: 0, y: 0 }
                ],
                chevronOffset: [
                    { x: 0, y: -14 },
                    { x: 14, y: 0 },
                    { x: scopeOffsetX, y: 14 },
                    { x: -8, y: 0 }
                ],
                html: `
           <p>This dropdown controls whether the filters and resulting data will be scoped to the current project (Obeying the user's 
        Project Scope Down and Project Scope Up settings) or scoped across all projects within the workspace.</p>
        <p>Depending upon the app and the filters, scoping across all projects may result in performance issues or timeout errors from the server. To ensure 
        timely performance, use filters that will return a manageable number of results.</p>
            `
            });
        }

        let buttonOffsetX = !this.app._showAncestorFilter() && !this.app._showIgnoreProjectScopeControl() ? -225 : 0;

        steps.push({
            target: 'multifiltertogglebtn',
            placement: 'bottom',
            title: 'Hide/Clear/Apply Filter Buttons',
            offset: [
                { x: 0, y: 0 },
                { x: 0, y: 0 },
                { x: 0, y: 14 },
                { x: 0, y: 0 }
            ],
            chevronOffset: [
                { x: 0, y: -14 },
                { x: 14, y: 0 },
                { x: buttonOffsetX, y: 14 },
                { x: -8, y: 0 }
            ],
            html: `
           <ul class="filter-help-list">
        <li><b>Show/Hide Filters: </b>Used to toggle the visibility of the filter controls. Use this to hide the filters if they're 
        not needed or more space is needed within the app</li>
        
        <li><b>Clear Filters: </b>Once at least 1 filter is applied, this button will appear. This button will clear all of the quick filters and advanced filters across all artifact types. 
        Upon clearing the filters, the app will refresh its data.</li>
        
        <li><b>Apply Filters: </b>If present, this button becomes active after a single change is made to one of the filters. This button 
        allows the user to make multiple changes without the app refreshing after each change. Once the user has modified all of 
        the necessary filters, clicking this button will apply it to the app and refresh the data. If this button is not present, 
        the app will refresh after each change made to the filters.</li>
        </ul>
            `
        },
            {
                target: '#multiLevelFilterTabPanel tabbar tab',
                placement: 'bottom',
                title: 'Artifact Type Tabs',
                offset: [
                    { x: 0, y: 0 },
                    { x: 0, y: 0 },
                    { x: 0, y: 14 },
                    { x: 0, y: 0 }
                ],
                chevronOffset: [
                    { x: 0, y: -14 },
                    { x: 14, y: 0 },
                    { x: -25, y: 14 },
                    { x: -8, y: 0 }
                ],
                html: `
           <p>Each tab contains a unique filter that will apply filters at the level of the specified artifact type. 
        If the tab title ends with a number in parenthesis, this indicates the current number of filters applied at that level.</p>
            `
            },
            {
                target: '#' + this.app.btnRenderAreaId,
                placement: 'bottom',
                title: 'Errors',
                chevronOffset: [
                    { x: 0, y: -14 },
                    { x: 14, y: 0 },
                    { x: 0, y: 28 },
                    { x: -8, y: 0 }
                ],
                html: `
            <h4><i>One of the filters is trying to return too many records and would result in timeouts...</i></h4>
        <ul>
        <li>Often times, when using filters on artifact types above or below the artifact type displayed within the app, it's necessary 
        to first fetch those artifacts at that level in order to properly apply the filters. If the number of artifacts fitting those 
        filters is too large, it's too slow or impossible to retrieve all of them in order to then use them as filters afterwards.
        <br><br>
        <b>Example: </b>
        Using a grid to display Features across all projects. We only want to see Features that have User Stories that are blocked. 
        Since there's no way to directly search for Features containing blocked stories, we must first find all blocked stories so we can 
        build a list of Features that are tied to those stories. And since we're scoping across all projects, we must query for all blocked 
        stories across the workspace. The results would be over ten thousand records, which would take very long to load, or would fail 
        to load due to timeout errors. This is an example of when we would see this error. Using more specific filters, or scoping to a specific 
        project hierarchy would solve this issue.
        </li>
        </ul>
            `
            });

        return steps;
    }
});
Ext.define('Utils.AncestorPiAppFilter', {
    alias: 'plugin.UtilsAncestorPiAppFilter',
    version: "1.3.4",
    mixins: [
        'Ext.AbstractPlugin',
        'Rally.Messageable'
    ],
    extend: 'Ext.Component',

    statics: {
        RENDER_AREA_ID: 'utils-ancestor-pi-app-filter',
        PANEL_RENDER_AREA_ID: 'multi-level-pi-app-filter-panel'
    },

    config: {
        /**
         * @cfg {Boolean}
         * The id of the component where the plugin will render its controls
         */
        renderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the filter button will render itself
         */
        btnRenderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the tabbed filter panel will render itself
         */
        panelRenderAreaId: 'multi-level-pi-app-filter-panel',

        /**
         * @cfg {Boolean}
         * Set to true to show multilevel filter by default
         */
        displayMultiLevelFilter: false,

        /**
         * @cfg {String}
         * Choose default setting for project scope
         * Possible values: current, workspace, user
         */
        projectScope: 'user',

        /**
         * @cfg {Boolean}
         * Set to true to indicate that this component is a publisher of events
         * to other apps using this plugin
         */
        publisher: false,

        /**
         * @cfg {Boolean}
         * Set to false to prevent the '-- None --' selection option if your app can't support
         * querying by a null ancestor (e.g. Lookback _ItemHierarchy)
         */
        allowNoEntry: true,

        /**
         * @cfg {Object}
         * Config applied to the app settings components
         */
        settingsConfig: {},

        /**
         * @cfg {Object}
         * Fetch list for PI Selector
         */
        defaultFetch: true,

        /**
         * @cfg {Array}
         * Whitelist array for inline filters. Used if app fails to retrieve global
         * whitelist or overrideGlobalWhitelist is set to true
         */
        whiteListFields: ['Tags', 'Milestones', 'c_EAEpic', 'c_EnterpriseApprovalEA', 'DisplayColor'],

        /**
         * @cfg {Boolean}
         * Set to true to specify custom whitelist array
         */
        overrideGlobalWhitelist: false,

        /**
         * @cfg {Array}
         * Blacklist array for inline filters
         */
        blackListFields: [],

        /**
         * @cfg {Boolean}
         * Setting for inlineFilterButtonConfig
         */
        filterChildren: false,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker
         */
        ancestorLabel: 'With ancestor',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ancestorLabelWidth: 110,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown with the ancestor filter
         */
        ownerLabel: 'and owned by',

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown by itself
         */
        ownerOnlyLabel: 'Owned by',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ownerLabelWidth: 110,


        /**
         * @cfg {Number}
         * Style of the Portfolio Item Type picker label
         */
        labelStyle: 'font-size: medium',

        /**
         * @cfg {Number}
         * Minimum width for single row layout
         */
        singleRowMinWidth: 840,

        /**
         * @cfg {Array}
         * Field list for multi-level filter panel
         */
        defaultFilterFields: [],

        /**
         * @cfg {Boolean}
         * Set to true to hide filters on load
         */
        filtersHidden: false,

        /**
         * @cfg {Boolean}
         * Set to true to hide advanced filters on load
         */
        advancedFilterCollapsed: false,
        /**
         * @cfg {String}
         * Pass a typePath to set that PI type as the default visible tab
         */
        visibleTab: undefined,

        /**
         * @cfg {Boolean}
         * Set to true to prevent user from scoping app across the workspace
         * */
        disableGlobalScope: false
    },
    filterControls: [],
    portfolioItemTypes: [],
    readyDeferred: null,
    piTypesDeferred: null,
    isSubscriber: false,
    changeSubscribers: [],
    publishedValue: {},
    defaultTab: 0,

    constructor: function () {
        this.callParent(arguments);
        // this._addCancelLoad(); TODO - Future work
        this._setupPubSub();
        Ext.tip.QuickTipManager.init();
    },

    initComponent: function () {
        this.callParent(arguments);
        this.addEvents('ready', 'select', 'change');
    },

    init: function (cmp) {
        this.cmp = cmp;
        this.cmp.on('resize', this._onCmpResize, this);
        this.renderArea = this.cmp.down('#' + this.renderAreaId);
        this.btnRenderArea = this.cmp.down('#' + this.btnRenderAreaId);
        this.panelRenderArea = this.cmp.down('#' + this.panelRenderAreaId);

        // Extend app settings fields
        var cmpGetSettingsFields = this.cmp.getSettingsFields;
        this.cmp.getSettingsFields = function () {
            return this._getSettingsFields(cmpGetSettingsFields.apply(cmp, arguments));
        }.bind(this);

        // Extend app default settings fields
        var appDefaults = this.cmp.defaultSettings;
        appDefaults['Utils.AncestorPiAppFilter.enableAncestorPiFilter2'] = false;
        appDefaults['Utils.AncestorPiAppFilter.projectScope'] = this.projectScope;
        appDefaults['Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter'] = this.displayMultiLevelFilter;
        this.cmp.setDefaultSettings(appDefaults);

        // Add the control components then fire ready
        this._getGlobalWhitelist().then({
            scope: this,
            success: function (whitelist) {
                this.whiteListFields = whitelist;

                this._getTypeDefinitions().then({
                    scope: this,
                    success: function () {
                        Promise.all([this._addAncestorControls(), this._addFilters()]).then(
                            function () {
                                setTimeout(function () { this._setReady(); }.bind(this), 500);
                            }.bind(this),
                            function (error) {
                                this._showError(error, 'Failed while adding ancestor and multilevel filters');
                                this._setReady();
                            }.bind(this)
                        );
                    },
                    failure: function () {
                        this._showError('Failed to fetch portfolio item types for multi-level filter');
                    }
                });
            }
        });
    },

    // Attempt to load preference object specifying list of fields to whitelist
    _getGlobalWhitelist: function () {
        let def = Ext.create('Deft.Deferred');
        let prefName = 'multi-level-filter-whitelist-fields-preference-' + this.cmp.getContext().getWorkspaceRef();
        if (this.overrideGlobalWhitelist) {
            def.resolve(this.whiteListFields);
            return def.promise;
        }

        Rally.data.PreferenceManager.load({
            filterByName: prefName,
            scope: this,
            success: function (pref) {
                if (pref && pref.hasOwnProperty(prefName)) {
                    try {
                        let fields = pref[prefName].split(',');
                        if (fields && fields.length) {
                            def.resolve(fields);
                        }
                        else {
                            def.resolve(this.whiteListFields);
                        }
                    }
                    catch (e) {
                        def.resolve(this.whiteListFields);
                    }
                }
                else {
                    def.resolve(this.whiteListFields);
                }
            }
        });
        return def.promise;
    },

    _getTypeDefinitions: function () {
        let def = Ext.create('Deft.Deferred');

        Rally.data.util.PortfolioItemHelper.getPortfolioItemTypes().then({
            scope: this,
            success: function (piTypes) {
                this.portfolioItemTypes = piTypes;

                Ext.create('Rally.data.wsapi.Store', {
                    model: Ext.identityFn('TypeDefinition'),
                    fetch: ['Name', 'Ordinal', 'TypePath'],
                    requester: this,
                    filters: [{ property: 'Name', value: 'Hierarchical Requirement' }]
                }).load({
                    scope: this,
                    callback: function (records, operation, success) {
                        if (success) {
                            if (records && records.length) {
                                this.storyType = records[0];
                                this.allTypes = [this.storyType].concat(this.portfolioItemTypes);
                                def.resolve();
                            }
                            else { def.reject(); }
                        }
                        else { def.reject(); }
                    }
                });
            },
            failure: function () {
                def.reject();
            }
        });

        return def.promise;
    },

    notifySubscribers: function (changeType) {
        var data = this._getValue();
        data.changeType = changeType;
        _.each(this.changeSubscribers, function (subscriberName) {
            this.publish(subscriberName, data);
        }, this);
    },

    // Returns a filter that will ensure results are children of the
    // selected ancestor portfolio item. type is the TypeDefinition 
    // for the Portfolio Item level you wish to fetch.
    getAncestorFilterForType: function (type) {
        var filter;
        var modelName = type.toLowerCase();
        var currentValues = this._getValue();

        if (currentValues.piTypePath) {
            var selectedPiTypePath = currentValues.piTypePath;
            var selectedRecord = currentValues.isPiSelected;
            var selectedPi = currentValues.pi;
            var typesAbove = this._getAncestorTypeArray(modelName, selectedPiTypePath);
            if (selectedRecord && selectedPi !== null && typesAbove !== null) {
                var property = this._getPropertyPrefix(modelName, typesAbove);
                if (property) {
                    filter = new Rally.data.wsapi.Filter({
                        property: property,
                        value: selectedPi
                    });
                }
            }
            else if (selectedPi !== null) {
                // Filter out any items of this type because the ancestor pi filter is
                // enabled, but this type doesn't have any pi ancestor types
                filter = new Rally.data.wsapi.Filter({
                    property: 'ObjectID',
                    value: 0
                });
            }
        }
        return filter;
    },

    // Returns an array containing all of the filters applied in the
    // multi-level filter as well as the selected ancestor PI if one is selected. 
    // type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getAllFiltersForType: async function (type, includeFiltersBelowType) {
        let ancestorFilter = this.getAncestorFilterForType(type);
        let filters = ancestorFilter ? [ancestorFilter] : [];
        let multiFilters = await this.getMultiLevelFiltersForType(type, includeFiltersBelowType);
        filters = filters.concat(multiFilters);

        return filters;
    },

    // Returns an array containing all of the filters applied in the multi-level filter for a given PI type. 
    // Type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getMultiLevelFiltersForType: async function (type, includeFiltersBelowType) {
        let filters = [];
        let modelName = type.toLowerCase();
        let multiLevelFilters = this.getMultiLevelFilters();

        if (!multiLevelFilters || !Object.keys(multiLevelFilters).length) {
            return filters;
        }

        let keys = this._getAllTypePaths();
        let currentLevelIndex = _.findIndex(keys, function (currentType) {
            return currentType.toLowerCase() === modelName;
        });

        for (let i = currentLevelIndex; i < keys.length; i++) {
            let currentType = keys[i];
            let currentFilters = multiLevelFilters[currentType];

            if (currentFilters && currentFilters.length) {
                // If scoping all projects, filter releases by name instead of value
                // await this._convertReleaseFilters(currentFilters);

                // If we're at the given level, just add the filters
                if (modelName === currentType.toLowerCase()) {
                    filters = filters.concat(this._getWsapiFilter(modelName));
                }
                // If we're at a level above the given level, convert filters to fit given level
                else {
                    let parentFilters = await this._getParentFilters(modelName, currentType, currentFilters);
                    filters = filters.concat(parentFilters);
                }
            }
        }

        // If building a hierarchy from top level down, we don't need to include filters
        // below the given type (e.g. a timeline app). Otherwise if being used for an app
        // that only displays one PI type, we need to include those lower filters
        if (includeFiltersBelowType && Ext.String.startsWith(type.toLowerCase(), 'portfolioitem')) {
            let childFilters = this._getChildFiltersForType(type);
            if (childFilters) {
                filters = filters.concat(childFilters);
            }
        }

        return filters;
    },

    // Returns an array containing all of the filters applied to a specific PI level.
    // type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getFiltersOfSingleType: async function (type) {
        return this._getWsapiFilter(type);
    },

    // Returns an object containing all of the filters applied in the multi-level
    // filter. Keys are the type definition field and the resulting values are arrays
    // of filters
    getMultiLevelFilters: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filters || {};
        }

        var filters = {};
        if (this.filterControls) {
            _.each(this.filterControls, function (filterControl) {
                let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
                filters[typeName] = filterControl.inlineFilterButton.getFilters();
            });
        }
        return filters;
    },

    getMultiLevelWsapiFilters: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.wsapiFilters || {};
        }

        var filters = {};
        if (this.filterControls) {
            _.each(this.filterControls, function (filterControl) {
                let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
                filters[typeName] = filterControl.inlineFilterButton.getWsapiFilter();
            });
        }
        return filters;
    },

    // Return array of filters for all child levels below given type prefixed 
    // appropriately to filter at the given type
    _getChildFiltersForType: function (type) {
        let types = this._getAllTypePaths();
        let childProperty = '';
        let childFilters = [];

        let startIndex = _.findIndex(types, function (t) {
            return t.toLowerCase() === type.toLowerCase();
        });

        // Types are in order lowest to highest
        for (let i = startIndex - 1; i >= 0; i--) {
            let currentType = types[i];
            childProperty = childProperty + (childProperty.length ? '.' : '') + (currentType.toLowerCase() === 'hierarchicalrequirement' ? 'UserStories' : 'Children');
            childFilters = childFilters.concat(this._getWsapiFilter(currentType, childProperty));
        }

        return childFilters;
    },

    // Given a type, a parent type and array of parent filters, convert the filters
    // to apply to the given type
    // E.g.  (owner = /user/12345)   ->    (parent.parent.owner = /user/12345)
    _getParentFilters: async function (type, parentType, parentFilters) {
        let typesAbove = this._getAncestorTypeArray(type, parentType);

        if (typesAbove !== null) {
            let parentProperty = this._getPropertyPrefix(type, typesAbove);

            if (parentProperty) {
                let hasCustomFieldFilters = this._hasCustomFilters(parentFilters);
                let emptyFilter = [new Rally.data.wsapi.Filter({
                    property: parentProperty + '.ObjectID',
                    operator: '=',
                    value: 0
                })];

                // If filters on custom fields exist, lets get a list of IDs at that level and use those IDs as our filter
                // This is to overcome an issue with missing indices in Rally's database causing timeouts
                if (hasCustomFieldFilters && this.getIgnoreProjectScope()) {
                    let parentIDs = [];
                    try {
                        let currentLevelFilters = this._getWsapiFilter(parentType);
                        parentIDs = await new Promise(function (resolve, reject) { this._getFilteredRecords(currentLevelFilters, parentType, resolve, reject); }.bind(this)).catch((e) => {
                            this._showError(e, 'Failed while loading filters for parent artifacts');
                            return [];
                        });

                        if (parentIDs && parentIDs.length) {
                            return [new Rally.data.wsapi.Filter({
                                property: parentProperty + '.ObjectID',
                                operator: 'in',
                                value: _.map(parentIDs, function (id) { return id.get('ObjectID'); })
                            })];
                        }
                        else {
                            return emptyFilter;
                        }
                    }
                    catch (e) {
                        this._showError(e, 'Failed while loading filters for parent artifacts');
                        return emptyFilter;
                    }
                }
                else {
                    return this._getWsapiFilter(parentType, parentProperty);
                }
            }
        }
        return [];
    },

    // A user can apply a custom match condition to a set of inline filters.
    // This method returns the proper WSAPI filter object representing that
    // custom set of conditions. If parentPrefix is passed, the prefix is added to
    // the set of filters before returning
    _getWsapiFilter: function (model, parentPrefix) {
        let filter;
        if (this._isSubscriber()) {
            if (this.publishedValue.wsapiFilters) {
                for (let key in this.publishedValue.wsapiFilters) {
                    if (key.toLowerCase() === model.toLowerCase()) {
                        filter = this.publishedValue.wsapiFilters[key];
                        if (filter) {
                            filter = filter.clone();
                        }
                        break;
                    }
                }
            }
        }
        else {
            if (this.filterControls) {
                _.each(this.filterControls, function (filterControl) {
                    let typeName = filterControl.inlineFilterButton.modelNames || 'unknown';
                    if (typeName.toLowerCase() === model.toLowerCase()) {
                        filter = filterControl.inlineFilterButton.getWsapiFilter();
                        if (filter) {
                            filter = filter.clone();
                        }
                    }
                });
            }
        }

        if (filter) {
            this._updateWsapiDisplayColorFilter(filter);
            if (parentPrefix) {
                this._updateWsapiFilterWithPrefix(filter, parentPrefix);
            }
        }

        return filter ? [filter] : [];
    },

    // DisplayColor filter passes hex value as uppercase, but the web service needs
    // hex values to be lowercase in order to work properly
    _updateWsapiDisplayColorFilter: function (filter) {
        if (filter) {
            if (filter.property) {
                if (typeof filter.property === 'object') {
                    this._updateWsapiDisplayColorFilter(filter.property);
                }
            }

            if (typeof filter.value === 'object') {
                this._updateWsapiDisplayColorFilter(filter.value);
            }
            else if (typeof filter.value === 'string' && /^#[0-9a-f]{3,6}$/i.test(filter.value)) {
                filter.value = filter.value.toLowerCase();
            }
        }
    },

    // Recursively traverse through a Rally WSAPI filter and apply the given prefix to all of the values
    _updateWsapiFilterWithPrefix: function (filter, parentPrefix) {
        if (filter) {
            if (filter.property) {
                if (typeof filter.property === 'string') {
                    if (filter.config && filter.property === filter.config.property) {
                        filter.config.property = `${parentPrefix}.${filter.property}`;
                    }
                    if (filter.initialConfig && filter.property === filter.initialConfig.property) {
                        filter.initialConfig.property = `${parentPrefix}.${filter.property}`;
                    }
                    filter.property = `${parentPrefix}.${filter.property}`;
                }
                else {
                    this._updateWsapiFilterWithPrefix(filter.property, parentPrefix);
                }
            }

            if (typeof filter.value === 'object') {
                this._updateWsapiFilterWithPrefix(filter.value, parentPrefix);
            }
        }
    },

    // Rally has a hard time filtering on custom dropdown fields on parents (probably
    // not indexed) so we check to see if any are applied
    _hasCustomFilters: function (filters) {
        for (let filter of filters) {
            if (filter.property.indexOf('c_') !== -1 && typeof filter.value === 'string') {
                return true;
            }
        }
        return false;
    },

    // Takes an array of filters. If scoping across all projects, we need to update any release
    // filters to filter on the release name rather than the release value
    _convertReleaseFilters: async function (filters) {
        if (this.getIgnoreProjectScope()) {
            for (let i = 0; i < filters.length; i++) {
                if (filters[i].property === 'Release') {
                    let release = await this._getRelease(filters[i].value);
                    if (release) {
                        filters[i] = new Rally.data.wsapi.Filter({
                            property: 'Release.Name',
                            value: release.Name
                        });
                    }
                }
            }
        }
    },

    _getRelease: async function (releaseVal) {
        let deferred = Ext.create('Deft.Deferred');

        Ext.Ajax.request({
            url: Ext.String.format('/slm/webservice/v2.0{0}?fetch=Name', releaseVal),
            success(response) {
                if (response && response.responseText) {
                    let obj = Ext.JSON.decode(response.responseText);
                    if (obj && obj.Release) {
                        deferred.resolve(obj.Release);
                    }
                    else {
                        deferred.resolve(null);
                    }
                } else {
                    deferred.resolve(null);
                }
            }
        });

        return deferred.promise;
    },

    getSelectedPiRecord: function () {
        return this._getValue().piRecord;
    },

    getIgnoreProjectScope: function () {
        return !this.disableGlobalScope && this._getValue().ignoreProjectScope;
    },

    getCurrentView: function () {
        var ancestorData = this._getValue();
        // Delete piRecord to avoid recursive stack overflow error
        delete ancestorData.piRecord;
        return ancestorData;
    },

    setCurrentView: function (view) {
        let scopeControl = this.renderArea.down('#ignoreScopeControl');
        if (scopeControl && typeof view.ignoreProjectScope === 'boolean') {
            scopeControl.suspendEvents(false);
            scopeControl.setValue(view.ignoreProjectScope);
            scopeControl.resumeEvents();
        }

        this.setMultiLevelFilterStates(view.filterStates);

        if (view.piTypePath) {
            this._setPiSelector(view.piTypePath, view.pi);
        }
    },

    // Returns an object of states for all of the inline filters
    // Used for getting and setting shared views
    getMultiLevelFilterStates: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filterStates || {};
        }

        var states = {};
        if (this.filterControls) {
            _.each(this.filterControls, function (filterControl) {
                let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
                states[typeName] = filterControl.inlineFilterButton.getState();
            });
        }

        return states;
    },

    getModels: function () {
        return this.models;
    },

    getPortfolioItemTypes: function () {
        return this.portfolioItemTypes;
    },

    getLowestPortfolioItemType: function () {
        return this.portfolioItemTypes[0];
    },

    // Sets the states of the inline filters
    // Used when applying a shared view to the filters
    setMultiLevelFilterStates: function (states) {
        if (!this._isSubscriber()) {
            if (states) {
                this.suspendEvents(false);
                if (this.tabPanel) {
                    this.tabPanel.removeAll();
                }
                for (let key in states) {
                    if (states.hasOwnProperty(key)) {
                        for (let i = 0; i < this.filterControls.length; i++) {
                            let typeName = (this.filterControls[i].inlineFilterButton.modelNames) || 'unknown';
                            if (typeName === key) {
                                let filterBtn = this.filterControls[i].inlineFilterButton;
                                // filterBtn.suspendEvents(false);
                                filterBtn.applyState(states[key]);
                                // filterBtn.resumeEvents();
                            }
                        }
                    }
                }
                setTimeout(function () {
                    this.resumeEvents();
                    this.tabPanel && this.tabPanel.setActiveTab(this.defaultTab);
                    this._onChange();
                }.bind(this), 1500);
            }
            else {
                this._clearAllFilters();
            }
        }
    },

    // On many apps, the multilevel filter replaces the original single inline filter
    // control. Some users have saved views containing a filter state from this original
    // filter. This method allows apps to try and apply those filters to the multilevel
    // filter at the proper level in the porfolio hierarchy
    mergeLegacyFilter: function (multiFilterStates, legacyFilterState, modelName, setState) {
        if (!this._isSubscriber() && multiFilterStates && legacyFilterState && modelName) {
            for (let multiModel in multiFilterStates) {
                if (multiFilterStates.hasOwnProperty(multiModel)) {
                    if (multiModel === modelName) {
                        try {
                            let currentState = multiFilterStates[multiModel];
                            if (legacyFilterState.matchType) {
                                currentState.matchType = legacyFilterState.matchType;
                            }
                            if (typeof legacyFilterState.condition === 'string') {
                                currentState.condition = legacyFilterState.condition;
                            }
                            if (legacyFilterState.quickFilters) {
                                if (legacyFilterState.quickFilterFields && !legacyFilterState.quickFilterFields.length) {
                                    for (let qFilter of legacyFilterState.quickFilters) {
                                        legacyFilterState.quickFilterFields.push(qFilter.name);
                                    }
                                }
                                currentState.quickFilters = _.merge(currentState.quickFilters, legacyFilterState.quickFilters);
                            }
                            if (legacyFilterState.advancedFilters) {
                                currentState.advancedFilters = _.merge(currentState.advancedFilters, legacyFilterState.advancedFilters);
                            }
                            if (legacyFilterState.quickFilterFields) {
                                currentState.quickFilterFields = _.merge(currentState.quickFilterFields, legacyFilterState.quickFilterFields);
                            }
                        }
                        catch (e) {
                            console.error('Failed to merge legacy filter into multi-level filter');
                        }
                    }
                }
            }

            if (setState) {
                this.setMultiLevelFilterStates(multiFilterStates);
            }
        }
    },

    // Returns an array of records fitting the given filters
    _getFilteredRecords: async function (filters, model, resolve, reject) {
        let dataContext = Rally.getApp().getContext().getDataContext();
        if (this.getIgnoreProjectScope()) {
            dataContext.project = null;
        }

        let ancestor = this.getAncestorFilterForType(model);
        if (ancestor && ancestor.value) {
            filters.push(ancestor);
        }

        let fetch = ['ObjectID'];
        if (model === 'HierarchicalRequirement') {
            fetch.push('Feature');
        }
        else {
            fetch.push('Parent');
        }

        let totalCount = await this._getTotalResultCount(dataContext, filters, model);

        if (totalCount === -1) {
            reject('Multi-level filter failed while filtering out items above or below selected portfolio item type.');
        }
        else if (totalCount === 0) {
            resolve([]);
        }
        else if (totalCount > 6000) {
            reject('One of the filters is trying to return too many records and would result in long load times or timeouts, try using more specific filters to reduce the total result-set.');
        }
        else {
            let store = Ext.create('Rally.data.wsapi.Store', {
                autoLoad: false,
                context: dataContext,
                filters,
                model,
                fetch,
                limit: Infinity,
                enablePostGet: true
            });

            store.load().then({
                scope: this,
                success: function (records) {
                    resolve(records);
                },
                failure: function () {
                    reject('Multi-level filter failed while filtering out items above or below selected portfolio item type. Result set was probably too large.');
                }
            });
        }
    },

    _getTotalResultCount: function (context, filters, model) {
        let deferred = Ext.create('Deft.Deferred');

        let store = Ext.create('Rally.data.wsapi.Store', {
            autoLoad: false,
            context,
            filters,
            model,
            fetch: ['_ref'],
            limit: 1,
            enablePostGet: true
        });

        store.load().then({
            scope: this,
            success: function () {
                deferred.resolve(store.totalCount);
            },
            failure: function () {
                deferred.resolve(-1);
            }
        });

        return deferred.promise;
    },

    _setupPubSub: function () {
        if (this.publisher) {
            this.subscribe(this, 'registerChangeSubscriber', function (subscriberName) {
                // Register new unique subscribers
                if (!_.contains(this.changeSubscribers, subscriberName)) {
                    this.changeSubscribers.push(subscriberName);
                }
                this.publish(subscriberName, this._getValue());
            }, this);
            // Ask any existing subscribers to re-register
            this.publish('reRegisterChangeSubscriber');
        }
        else {
            this.subscriberEventName = Rally.getApp().getAppId() + this.$className;

            // Subscribe to a channel dedicated to this app
            this.subscribe(this, this.subscriberEventName, function (data) {
                if (this.intervalTimer) {
                    clearInterval(this.intervalTimer);
                    delete this.intervalTimer;
                }
                if (!this.isSubscriber) {
                    this.isSubscriber = true;
                    this._hideControlCmp();
                }

                // We only want to refresh the app if we have all of the filters from the broadcaster
                if (data.ready) {
                    this.publishedValue = data;
                    // Default to an ancestor change event for backwards compatibility
                    if (data.changeType === 'ancestor' || !data.changeType) {
                        this._onSelect();
                    }
                    else {
                        this._onChange();
                    }
                } else {
                    setTimeout(() => { this.publish('registerChangeSubscriber', this.subscriberEventName); }, 500);
                }
            }, this);

            // Attempt to register with a publisher (if one exists)
            this.publish('registerChangeSubscriber', this.subscriberEventName);
            this.registerAttempts = 0;
            this.intervalTimer = setInterval(() => {
                this.registerAttempts++;

                // After 15 attempts, there probably isn't a broadcaster present, so delete the interval
                if (this.registerAttempts >= 15) {
                    clearInterval(this.intervalTimer);
                    delete this.intervalTimer;
                    delete this.registerAttempts;
                }
                else {
                    this.publish('registerChangeSubscriber', this.subscriberEventName);
                }
            }, 500);
            this.subscribe(this, 'reRegisterChangeSubscriber', function () {
                this.publish('registerChangeSubscriber', this.subscriberEventName);
            }, this);
        }
    },

    _getValue: function () {
        var result = {};
        if (this._isSubscriber()) {
            result = this.publishedValue || {};
        }
        else {
            if (this.piTypeSelector) {
                var selectedPiType = this.piTypeSelector.getRecord();
                if (selectedPiType && this.piSelector) {
                    var selectedPiTypePath = selectedPiType.get('TypePath');
                    var selectedRecord = this.piSelector.getRecord();
                    var selectedPi = this.piSelector.getValue();
                    _.merge(result, {
                        piTypePath: selectedPiTypePath,
                        isPiSelected: !!selectedPi,
                        pi: selectedPi,
                        piRecord: selectedRecord
                    });
                }
            }
            result.ignoreProjectScope = this._ignoreProjectScope();
            result.filters = this.getMultiLevelFilters();
            result.filterStates = this.getMultiLevelFilterStates();
            result.wsapiFilters = this.getMultiLevelWsapiFilters();
            result.ready = this.ready;
        }
        return result;
    },

    _setReady: function () {
        // Hide floating components because of course they are still visible when settings menu is shown
        this.cmp.on('beforehide', () => {
            if (this.filterHelpBtn) {
                this.filterHelpBtn.hide();
            }
        });
        this.cmp.on('beforeshow', () => {
            if (this.filterHelpBtn) {
                this.filterHelpBtn.show();
            }
        });

        if (!this._showMultiLevelFilter() && this.filterHelpBtn) {
            this.filterHelpBtn.hide();
        }

        if (this._isSubscriber()) {
            if (this.tabPanel) {
                this.tabPanel.hide();
            }

            if (this.showFiltersBtn) {
                this.showFiltersBtn.hide();
            }

            if (this.filterHelpBtn) {
                this.filterHelpBtn.hide();
            }

            if (!this.publishedValue.filters) {
                setTimeout(function () {
                    this.ready = true;
                    this.fireEvent('ready', this);
                }.bind(this), 3000);
                return;
            }
        }
        else {
            this._updateReleaseValues();
        }
        this.ready = true;
        this.fireEvent('ready', this);
    },

    // Ancestor filter dropdowns have been selected
    _onSelect: function () {
        if (this.ready) {
            this.fireEvent('select', this);
        }
    },

    // Multi-level filters have changed
    _onChange: function () {
        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    hideHelpButton: function () {
        if (this.filterHelpBtn) {
            this.filterHelpBtn.hide();
        }
    },

    showHelpButton: function () {
        if (this.filterHelpBtn) {
            this.filterHelpBtn.show();
        }
    },

    _getSettingsFields: function (fields) {
        var currentSettings = Rally.getApp().getSettings();
        if (!currentSettings.hasOwnProperty('Utils.AncestorPiAppFilter.projectScope')) {
            currentSettings['Utils.AncestorPiAppFilter.projectScope'] = this.projectScope;
        }
        if (!currentSettings.hasOwnProperty('Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter')) {
            currentSettings['Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter'] = this.displayMultiLevelFilter;
        }
        var pluginSettingsFields = [{
            xtype: 'rallycheckboxfield',
            id: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            name: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            fieldLabel: 'Filter artifacts by ancestor portfolio item',
        }, {
            xtype: 'rallyportfolioitemtypecombobox',
            id: 'Utils.AncestorPiAppFilter.defaultPiType',
            name: 'Utils.AncestorPiAppFilter.defaultPiType',
            fieldLabel: "Default Portfolio Item type",
            valueField: 'TypePath',
            allowNoEntry: false,
            defaultSelectionPosition: 'last',
            // Disable the preference enabled combo box plugin so that this control value is app specific
            plugins: []
        },
        {
            xtype: 'radiogroup',
            fieldLabel: 'Show artifacts from',
            columns: 1,
            vertical: true,
            allowBlank: false,
            name: 'Utils.AncestorPiAppFilter.projectScope',
            items: [{
                boxLabel: "User's current project(s).",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'current',
                checked: 'current' === currentSettings['Utils.AncestorPiAppFilter.projectScope'] || this.disableGlobalScope
            }, {
                boxLabel: "All projects in workspace.",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'workspace',
                checked: 'workspace' === currentSettings['Utils.AncestorPiAppFilter.projectScope'] && !this.disableGlobalScope,
                disabled: this.disableGlobalScope
            }, {
                boxLabel: 'User selectable (either current project(s) or all projects in workspace).',
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'user',
                checked: 'user' === currentSettings['Utils.AncestorPiAppFilter.projectScope'] && !this.disableGlobalScope,
                disabled: this.disableGlobalScope
            },],
            listeners: {
                scope: this,
                change: function () {
                    return;
                }
            }
        },
        {
            xtype: 'rallycheckboxfield',
            id: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            name: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            fieldLabel: 'Enable multi-level portfolio item filter',
            value: currentSettings['Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter']
        }
        ];
        pluginSettingsFields = _.map(pluginSettingsFields, function (pluginSettingsField) {
            return _.merge(pluginSettingsField, this.settingsConfig);
        }, this);
        // apply any settings config to each field added by the plugin
        return pluginSettingsFields.concat(fields || []);
    },

    // When changing projects, if a release filter was previously applied, the inline filter state remembers the release
    // filter, but fails to populate the comobobox with the release name, which becomes misleading to 
    // the end user. This hack finds the release name and shoves it into the combobox.
    _updateReleaseValues: function () {
        _.each(this.filterControls, function (filter) {
            _.each(filter.inlineFilterButton.inlineFilterPanel.advancedFilterPanel.advancedFilterRows.rows, function (row) {
                if (row.name === 'Release' && row._valueFieldIsValid()) {
                    _.each(row.items.items, function (rowItem) {
                        if (rowItem.xtype === 'rallyreleasecombobox') {
                            this._getRelease(rowItem.originalValue).then(function (release) {
                                if (release) {
                                    rowItem.rawValue = release.Name;
                                }
                            });
                        }
                    }, this);
                }
            }, this);
        }, this);
    },

    // Requires that app settings are available (e.g. from 'beforelaunch')
    _addAncestorControls: function () {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        var ownerLabelWidth = this.ownerLabelWidth;
        if (this.cmp.getWidth() < this.singleRowMinWidth) {
            controlsLayout = 'vbox';
            ownerLabelWidth = this.ancestorLabelWidth;
        }
        var scopeControlByItself = false;
        if (this._showAncestorFilter() === false && this._showIgnoreProjectScopeControl() === true) {
            scopeControlByItself = true;
        }
        var controls = {
            xtype: 'container',
            id: 'controlsArea',
            overflowX: 'auto',
            layout: {
                type: 'hbox',
                align: 'top'
            },
            items: [{
                xtype: 'container',
                id: 'pubSubIndicatorArea',
                width: 25,
                padding: '6 5 0 0',
                hidden: !this.publisher && !this._isSubscriber(),
                items: [{
                    xtype: 'component',
                    id: 'publisherIndicator',
                    html: '<span class="icon-bullhorn icon-large"></span>',
                    hidden: !this.publisher
                },
                {
                    xtype: 'component',
                    id: 'subscriberIndicator',
                    html: '<span class="icon-link icon-large"></span>',
                    hidden: !this._isSubscriber()
                },
                ]
            }, {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: [{
                    xtype: 'container',
                    id: 'ancestorFilterArea',
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'container',
                        id: 'piTypeArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle'
                        },
                    },
                    {
                        xtype: 'container',
                        id: 'piSelectorArea',
                        itemId: 'piSelectorArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle',
                            padding: '0 0 0 5'
                        },
                    }
                    ]
                }, {
                    xtype: 'container',
                    itemId: 'scopeControlArea',
                    id: 'scopeControlArea',
                    width: this._showIgnoreProjectScopeControl() ? 250 : 0,
                    margin: this._showIgnoreProjectScopeControl() ? '0 10 0 0' : 0,
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'rallycombobox',
                        itemId: 'ignoreScopeControl',
                        id: 'ignoreScopeControl',
                        stateful: true,
                        stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.ignoreProjectScopeControl'),
                        stateEvents: ['select'],
                        hidden: this._isSubscriber() || !this._showIgnoreProjectScopeControl(),
                        displayField: 'text',
                        valueField: 'value',
                        labelStyle: this.labelStyle,
                        labelWidth: this._showIgnoreProjectScopeControl() ? ownerLabelWidth : 0,
                        fieldLabel: scopeControlByItself ? this.ownerOnlyLabel : this.ownerLabel,
                        // Don't set initial value with this component or it will override the state
                        storeConfig: {
                            fields: ['text', 'value'],
                            data: [{
                                text: "Current Project(s)",
                                value: false
                            }, {
                                text: "Any Project",
                                value: true
                            }]
                        },
                        listeners: {
                            scope: this,
                            change: function () {
                                this._onSelect();
                            }
                        },
                    }]
                }]
            }]
        };

        if (this.renderArea) {
            // Without this, the components are clipped on narrow windows
            this.renderArea.setOverflowXY('auto', 'auto');
            this.renderArea.add(controls);
            this.filterHelpBtn = Ext.widget('rallybutton', {
                itemId: 'filterHelpBtn',
                floating: true,
                shadow: false,
                cls: 'filter-help',
                iconOnly: true,
                iconCls: 'icon-help',
                hidden: this._isSubscriber() || !this._showMultiLevelFilter(),
                handler: (...args) => this.onHelpClicked(...args)
            });
            this.filterHelpBtn.showBy(this.renderArea, 'tr-tr', [-4, 5]);
        }

        this._addTooltips();

        // Need to get pi types sorted by ordinal lowest to highest for the filter logic to work
        return new Promise(function (resolve) {
            if (!this._isSubscriber() && this._showAncestorFilter()) {
                // Now create the pi type selector
                this._addPiTypeSelector().then(function () {
                    this._addPiSelector(this.piTypeSelector.getValue(), null).then(
                        function () {
                            resolve();
                        }.bind(this)
                    );
                }.bind(this));
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _addPiTypeSelector: function (initialValue) {
        return new Promise(function (resolve) {
            this.piTypeSelector = Ext.create('Rally.ui.combobox.PortfolioItemTypeComboBox', {
                xtype: 'rallyportfolioitemtypecombobox',
                id: 'Utils.AncestorPiAppFilter.piType',
                name: 'Utils.AncestorPiAppFilter.piType',
                width: 250,
                // Disable the preference enabled combo box plugin so that this control value is app specific
                plugins: [],
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piType'),
                stateEvents: ['select'],
                fieldLabel: this.ancestorLabel,
                labelWidth: this.ancestorLabelWidth,
                labelStyle: this.labelStyle,
                valueField: 'TypePath',
                value: initialValue || this._defaultPortfolioItemType(),
                allowNoEntry: false,
                defaultSelectionPosition: 'first',
                listeners: {
                    scope: this,
                    ready: function (combobox) {
                        // Unfortunately we cannot use the combobox store of PI types for our filter
                        // logic because it is sorted by ordinal from highest to lowest so that the
                        // picker options have a an order familiar to the user.

                        // Don't add the change listener until ready. This prevents us
                        // from adding and removing the pi selector multiple times during
                        // startup which causes a null ptr exception in that component
                        combobox.addListener({
                            scope: this,
                            change: this._onPiTypeChange
                        });
                        resolve();
                    }
                }
            });
            this.renderArea.down('#piTypeArea').add(this.piTypeSelector);
        }.bind(this));
    },

    _addTooltips: function () {
        Ext.tip.QuickTipManager.register({
            target: 'publisherIndicator',
            text: 'This app broadcasts filter settings to any enabled ancestor filtered apps (indicated with <span class="icon-link icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        Ext.tip.QuickTipManager.register({
            target: 'subscriberIndicator',
            text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        if (this._isSubscriber()) {
            Ext.tip.QuickTipManager.register({
                target: 'subscriberFilterIndicator',
                text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
                showDelay: 50,
                border: true
            });
        }
    },

    _onCmpResize: function (cmp, width) {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        if (width < this.singleRowMinWidth) {
            controlsLayout = {
                type: 'vbox'
            };
        }
        var filtersArea = this.renderArea.down('#filtersArea');
        if (filtersArea) {
            var controlsArea = this.renderArea.down('#controlsArea');
            var filters = filtersArea.removeAll(false);
            var newFiltersArea = {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: filters,
                hidden: filtersArea.isHidden()
            };
            controlsArea.remove(filtersArea, false);
            controlsArea.add(newFiltersArea);
        }
    },

    _hideControlCmp: function () {
        if (this.renderArea) {
            this.renderArea.down('#pubSubIndicatorArea').show();
            this.renderArea.down('#subscriberIndicator').show();
            this.renderArea.down('#filtersArea').hide();
        }
    },

    _onPiTypeChange: function (piTypeSelector, newValue) {
        if (newValue) {
            let currentPi = this._getValue().pi;
            this._removePiSelector();
            this._addPiSelector(newValue).then(
                function () {
                    // this._setReady();
                    // If an ancestor was selected it has now been cleared, so fire select event
                    if (currentPi) {
                        this._onSelect();
                    }
                }.bind(this)
            );
        }
    },

    _removePiSelector: function () {
        this.piSelector = null;
        this.renderArea.down('#piSelectorArea').removeAll(true);
    },

    _addPiSelector: function (piType, initialValue) {
        return new Promise(function (resolve) {
            this.piSelector = Ext.create('Rally.ui.combobox.ArtifactSearchComboBox', {
                id: 'Utils.AncestorPiAppFilter.piSelector',
                width: 250,
                margin: '0 10 0 10',
                labelAlign: 'top',
                storeConfig: {
                    models: piType,
                    autoLoad: true,
                    fetch: this.defaultFetch,
                    context: {
                        project: null
                    }
                },
                queryDelay: 2000,
                typeAhead: false,
                validateOnChange: false,
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piSelector'),
                stateEvents: ['select'],
                valueField: '_ref',
                allowClear: true,
                clearValue: null,
                allowNoEntry: this.allowNoEntry,
                noEntryValue: '',
                value: initialValue || null,
                // forceSelection: false,
                defaultSelectionPosition: null,
                listeners: {
                    scope: this,
                    select: function () {
                        this._onSelect();
                    },
                    ready: function () {
                        resolve();
                    }
                }
            });
            // Allow this combobox to save null state (which is default behavior of
            // stateful mixin, but for some reason was overridden in combobox)
            Ext.override(this.piSelector, {
                saveState: function () {
                    var me = this,
                        id = me.stateful && me.getStateId(),
                        hasListeners = me.hasListeners,
                        state;

                    if (id) {
                        state = me.getState() || {}; //pass along for custom interactions
                        if (!hasListeners.beforestatesave || me.fireEvent('beforestatesave', me, state) !== false) {
                            Ext.state.Manager.set(id, state);
                            if (hasListeners.statesave) {
                                me.fireEvent('statesave', me, state);
                            }
                        }
                    }
                }
            });
            this.renderArea.down('#piSelectorArea').add(this.piSelector);
        }.bind(this));
    },

    _setPiSelector: function (piType, pi) {
        return new Promise(function (resolve) {
            if (this.piTypeSelector) {
                this.piTypeSelector.suspendEvents(false);
                this.piTypeSelector.setValue(piType);
                this._removePiSelector();
                this._addPiSelector(piType, pi).then(function () {
                    this.piSelector.setValue(pi);
                    this.piTypeSelector.resumeEvents();
                    resolve();
                }.bind(this));
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _showAncestorFilter: function () {
        let enableAncestorFilter = this.cmp.getSetting('Utils.AncestorPiAppFilter.enableAncestorPiFilter2');

        if (enableAncestorFilter === undefined) {
            return false;
        }

        return enableAncestorFilter;
    },

    _showIgnoreProjectScopeControl: function () {
        let showProjectScope = this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'user';

        if (showProjectScope === undefined) {
            return this.projectScope;
        }

        return showProjectScope;
    },

    _ignoreProjectScope: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.ignoreProjectScope;
        }

        var result = false;
        if (this._showIgnoreProjectScopeControl()) {
            // If the control is shown, that values overrides the ignoreScope app setting
            result = this.renderArea.down('#ignoreScopeControl').getValue();
        }
        else if (this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === undefined) {
            result = this.projectScope === 'workspace';
        }
        else if (this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'workspace') {
            result = true;
        }

        return result;
    },

    _isSubscriber: function () {
        return this.isSubscriber;
    },

    _defaultPortfolioItemType: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.defaultPiType');
    },

    _getPropertyPrefix: function (typeName, typesAbove) {
        let type = typeName.toLowerCase();
        let property;

        if (type === 'hierarchicalrequirement' || type === 'userstory') {
            property = this.getLowestPortfolioItemType().get('Name');
        }
        else if (type === 'defect') {
            property = 'Requirement';
            typesAbove = typesAbove.slice(1);
            if (typesAbove.length) {
                property += `.${this.getLowestPortfolioItemType().get('Name')}`;
            }
        }
        else if (Ext.String.startsWith(type, 'portfolioitem')) {
            property = 'Parent';
        }

        if (property) {
            // property already gets us to the lowest pi level above the current type
            // for each additional level, add a 'Parent' term, except for the last
            // type in the list which is the currently selected pi type ancestor
            _.forEach(typesAbove.slice(1), function () {
                property += '.Parent';
            }, this);
        }

        return property;
    },

    /**
     * Return a list of artifact types AT or below selectedPiTypePath,
     * that are an ancestor of the given modelName, or null if there are no pi type
     * ancestors for the given model.
     */
    _getAncestorTypeArray: function (modelName, selectedPiTypePath) {
        var selectedPiTypeIndex;
        var modelNamePiTypeIndex;
        var model = modelName.toLowerCase();
        var selectedModel = selectedPiTypePath.toLowerCase();

        if (model === 'defect') {
            selectedPiTypeIndex = _.findIndex(this.allTypes, function (type) {
                return type.get('TypePath').toLowerCase() === selectedModel;
            });
            return this.allTypes.slice(0, selectedPiTypeIndex + 1);
        }

        modelNamePiTypeIndex = _.findIndex(this.allTypes, function (type) {
            return type.get('TypePath').toLowerCase() === model;
        });
        selectedPiTypeIndex = _.findIndex(this.allTypes, function (type) {
            return type.get('TypePath').toLowerCase() === selectedModel;
        });

        if (modelNamePiTypeIndex < selectedPiTypeIndex) {
            // Don't include the current model pi in the list of ancestors
            // Include the selcted pi type ancestor
            return this.allTypes.slice(modelNamePiTypeIndex + 1, selectedPiTypeIndex + 1);
        }

        return null;
    },

    /*
        Multi-Level Filter functions
    */
    _showMultiLevelFilter: function () {
        let showFilters = this.cmp.getSetting('Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter');

        if (showFilters === undefined) {
            return this.displayMultiLevelFilter;
        }

        return showFilters;
    },

    _addFilters: function () {
        return new Promise(function (resolve, reject) {
            var promises = [];
            if (this._showMultiLevelFilter() && !this._isSubscriber()) {
                if (this.btnRenderArea) {
                    if (!this._isSubscriber()) {
                        this.showFiltersBtn = this.btnRenderArea.add(
                            {
                                xtype: 'multifiltertogglebtn',
                                cls: ` rly-small ${this.filtersHidden ? 'secondary' : 'primary'}`,
                                handler: this._toggleFilters,
                                scope: this,
                                stateId: this.cmp.getContext().getScopedStateId(`multi-filter-toggle-button`),
                                listeners: {
                                    scope: this,
                                    added: function (btn) {
                                        if (this.filtersHidden) {
                                            btn.setFiltersHidden(true);
                                        }

                                        if (btn.filtersHidden) {
                                            btn.setToolTipText('Show Filters');
                                        }
                                        else {
                                            btn.setToolTipText('Hide Filters');
                                        }
                                    }
                                }
                            }
                        );

                        Rally.data.ModelFactory.getModels({
                            types: this._getAllTypePaths().reverse(),
                            context: this.cmp.getContext(),
                            scope: this,
                            success: function (models) {
                                this.models = models;

                                this.tabPanel = this.panelRenderArea.add({
                                    xtype: 'tabpanel',
                                    itemId: 'multiLevelFilterTabPanel',
                                    width: '98%',
                                    cls: 'blue-tabs',
                                    minTabWidth: 100,
                                    plain: true,
                                    autoRender: true,
                                    hidden: this._isSubscriber() || this.showFiltersBtn.filtersHidden,
                                    hideMode: 'offsets',
                                    items: []
                                });

                                this.filterControls = [];
                                let clearAdvancedButtonConfig = {};
                                let matchTypeConfig = {};
                                let advancedFilterRowsFlex = 1;
                                let propertyFieldConfig = {
                                    blackListFields: this.blackListFields,
                                    whiteListFields: this.whiteListFields
                                };
                                let context = this.cmp.getContext();

                                if (this.cmp.getWidth() < this.singleRowMinWidth) {
                                    clearAdvancedButtonConfig = {
                                        text: 'Clear'
                                    };
                                    matchTypeConfig = {
                                        fieldLabel: 'Match',
                                        width: 65
                                    };
                                    propertyFieldConfig.width = 100;
                                    advancedFilterRowsFlex = 2;
                                }

                                // If a default visible tab is specified, we need to convert an
                                // artifact ordinal to a tab index
                                // Tab indices start at 0 for top-most portfolio item
                                // Artfiact ordinals start at -1 for user stories, 0 for Features, etc...
                                let ordinalLookup = {};
                                let modelLength = Object.keys(models).length;
                                if (this.visibleTab) {
                                    for (let i = 0; i < modelLength; i++) {
                                        ordinalLookup[i] = modelLength - i - 1;
                                    }
                                }

                                _.each(models, function (model, key) {
                                    if (this.visibleTab && this.visibleTab.toLowerCase() === key.toLowerCase()) {
                                        let ord = model.ordinal;
                                        if (typeof ord === 'number') {
                                            let newDefaultTab = ordinalLookup[ord + 1];
                                            if (typeof newDefaultTab === 'number') {
                                                this.defaultTab = newDefaultTab;
                                            }
                                        }
                                    }

                                    promises.push(new Promise(function (newResolve) {
                                        let filterName = `inlineFilter${key}`;
                                        this.filterControls.push(Ext.create('Rally.ui.inlinefilter.InlineFilterControl', {
                                            xtype: 'rallyinlinefiltercontrol',
                                            name: filterName,
                                            autoRender: true,
                                            itemId: filterName,
                                            context,
                                            inlineFilterButtonConfig: {
                                                stateful: true,
                                                stateId: this.cmp.getContext().getScopedStateId(`multi-${filterName}-button`),
                                                stateEvents: ['inlinefilterchange'],
                                                context: this.cmp.getContext(),
                                                modelNames: key,
                                                filterChildren: this.filterChildren,
                                                inlineFilterPanelConfig: {
                                                    autoRender: true,
                                                    name: `${filterName}-panel`,
                                                    itemId: `${filterName}-panel`,
                                                    model: model,
                                                    padding: 5,
                                                    width: '98%',
                                                    context,
                                                    quickFilterPanelConfig: {
                                                        defaultFields: this.defaultFilterFields,
                                                        addQuickFilterConfig: {
                                                            whiteListFields: this.whiteListFields,
                                                            blackListFields: this.blackListFields
                                                        }
                                                    },
                                                    advancedFilterPanelConfig: {
                                                        collapsed: this.advancedFilterCollapsed,
                                                        advancedFilterRowsConfig: {
                                                            propertyFieldConfig,
                                                            flex: advancedFilterRowsFlex
                                                        },
                                                        matchTypeConfig,
                                                        clearAdvancedButtonConfig
                                                    }
                                                },
                                                listeners: {
                                                    inlinefilterchange: this._onFilterChange,
                                                    inlinefilterready: function (panel) {
                                                        this._onFilterReady(panel);
                                                        newResolve();
                                                    },
                                                    scope: this
                                                }
                                            }
                                        }));
                                    }.bind(this)));
                                }, this);

                                Promise.all(promises).then(function () {
                                    if (!this._isSubscriber()) {
                                        this.clearAllButton = Ext.widget({
                                            xtype: 'rallybutton',
                                            itemId: 'clearAllButton',
                                            cls: 'secondary rly-small clear-all-filters-button',
                                            text: 'Clear All',
                                            margin: '3 9 3 0',
                                            hidden: !this._hasFilters(),
                                            listeners: {
                                                click: this._clearAllFilters,
                                                scope: this
                                            }
                                        });

                                        this.btnRenderArea.add(this.clearAllButton);
                                        this.tabPanel.setActiveTab(this.defaultTab);
                                        if (this.filtersHidden) {
                                            this.tabPanel.hide();
                                        }

                                        // Without this, the components are clipped on narrow windows
                                        this.btnRenderArea.setOverflowXY('auto', 'auto');
                                    }
                                    resolve();
                                }.bind(this));
                            },
                            failure: function () {
                                reject('Failed to fetch models for multi-level filter');
                            }
                        });
                    }
                    else {
                        this.btnRenderArea.add({
                            xtype: 'container',
                            id: 'filterSubIndicatorArea',
                            width: 25,
                            padding: '6 5 0 0',
                            items: [
                                {
                                    xtype: 'component',
                                    id: 'subscriberFilterIndicator',
                                    html: '<span class="icon-link icon-large"></span>'
                                }
                            ]
                        });
                        resolve();
                    }
                } else {
                    reject('Unable to find button render area for multi-level filter');
                }
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _clearAllFilters: function () {
        this.suspendEvents(false);

        // The quick filters don't properly clear if the filter isn't displayed
        let activeTab = this.tabPanel.getActiveTab();

        _.each(this.filterControls, function (filterControl) {
            try {
                this.tabPanel.setActiveTab(filterControl.tab);
                filterControl.inlineFilterButton.suspendEvents(false);
                filterControl.inlineFilterButton.clearAllFilters();
                filterControl.inlineFilterButton.saveState();
                filterControl.inlineFilterButton.resumeEvents();
            }
            catch (e) {
                console.log(e);
            }
        }.bind(this));

        this.tabPanel.setActiveTab(activeTab);
        this.resumeEvents();
        this._onFilterChange();
    },

    _hasFilters: function () {
        var filters = this.getMultiLevelFilters();
        var returnVal = false;

        _.each(filters, function (filter) {
            if (filter.length) {
                returnVal = true;
            }
        });

        return returnVal;
    },

    _onFilterReady: function (panel) {
        panel.expand();
        let filterCount = panel.quickFilterPanel.getFilters().length + panel.advancedFilterPanel.getFilters().length;
        let modelName = this._getModelName(panel);

        let tab = this.tabPanel.add({
            title: modelName + (filterCount ? ` (${filterCount})` : ''),
            html: '',
            itemId: `${modelName.replace(/\s+/g, '')}-tab`,

        });

        tab.add({
            xtype: 'container',
            layout: 'hbox',
            items: [panel]
        });

        panel.tab = tab;
    },

    _getModelName(panel) {
        let modelName = (panel.model && panel.model.elementName) || 'unknown';

        if (modelName === 'HierarchicalRequirement') {
            modelName = panel.model.displayName;
        }

        return modelName;
    },

    _applyFilters: function () {
        this.suspendEvents(false);
        this.suspendLayouts();
        _.each(this.filterControls, function (filterControl) {
            filterControl.inlineFilterButton._applyFilters();
        });
        this.resumeEvents();
        this.resumeLayouts(false);
        this.updateLayout();
    },

    _onFilterChange: function () {
        if (this.clearAllButton) {
            if (this._hasFilters()) {
                this.clearAllButton.show();
            }
            else {
                this.clearAllButton.hide();
            }
        }

        _.each(this.filterControls, function (filterControl) {
            let modelName = this._getModelName(filterControl.inlineFilterButton.inlineFilterPanel);
            this._setTabText(modelName, filterControl.inlineFilterButton.getFilters().length);
        }, this);

        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    _setTabText: function (typeName, filterCount) {
        var titleText = filterCount ? `${typeName} (${filterCount})` : typeName;
        var tab = this.tabPanel.child(`#${typeName.replace(/\s+/g, '')}-tab`);

        if (tab) { tab.setTitle(titleText); }
    },

    _toggleFilters: function (btn) {
        if (this.tabPanel.isHidden()) {
            this.tabPanel.show();
            btn.setToolTipText('Hide Filters');
            btn.addCls('primary');
            btn.removeCls('secondary');
            btn.setFiltersHidden(false);
        } else {
            this.tabPanel.hide();
            btn.setToolTipText('Show Filters');
            btn.addCls('secondary');
            btn.removeCls('primary');
            btn.setFiltersHidden(true);
        }
    },

    _getAllTypePaths: function () {
        return _.map(this.allTypes, (type) => {
            return type.get('TypePath');
        });
    },

    /**
    *   Overrides to allow a store load to be canceled which will abort loading
    *   any subsequent pages and not invoke the load callback.
    */

    /*     TODO - Future work
 
     _addCancelLoad() {
 
         Ext.override(Rally.data.PageableStore, {
 
             loadCanceled: false,
 
             cancelLoad: function () {
                 this.loadCanceled = true;
             },
 
             load: function (options) {
                 this.loadCanceled = false;
                 this.callParent(arguments);
             },
 
             _shouldLoadMorePages: function (operation) {
                 if (this.loadCanceled) {
                     return false;
                 }
                 else {
                     return this.callParent(arguments)
                 }
             },
 
             _afterDoneLoadingAllPages: function (operation, success, callback, scope) {
                 if (this.loadCanceled) {
                     // Loading canceled. Don't send any events or invoke the callback
                     this.resumeEvents();
                     this.currentPage = 1;
                     this.loading = false;
                 }
                 else {
                     this.callParent(arguments);
                 }
             }
         });
     },
 
     */

    _showError(msg, defaultMessage) {
        Rally.ui.notify.Notifier.showError({ message: this.parseError(msg, defaultMessage) });
    },

    parseError(e, defaultMessage) {
        defaultMessage = defaultMessage || 'An unknown error has occurred';

        if (typeof e === 'string' && e.length) {
            return e;
        }
        if (e.message && e.message.length) {
            return e.message;
        }
        if (e.exception && e.error && e.error.errors && e.error.errors.length) {
            if (e.error.errors[0].length) {
                return e.error.errors[0];
            } else {
                if (e.error && e.error.response && e.error.response.status) {
                    return `${defaultMessage} (Status ${e.error.response.status})`;
                }
            }
        }
        if (e.exceptions && e.exceptions.length && e.exceptions[0].error) {
            return e.exceptions[0].error.statusText;
        }
        return defaultMessage;
    },

    onHelpClicked() {
        CustomAgile.ui.tutorial.MultiLevelFilterTutorial.showWelcomeDialog(this);
    }
});
Ext.override(Rally.ui.gridboard.SharedViewComboBox, {
    /**
     * This override fixes a bug in the SharedViewComboBox which prevents a newly created
     * view from appearing in the view picker until after an app reload
     */
    _isViewPreference: function (record) {
        return record.self.typePath === 'preference' &&
            record.get('Type') === 'View' &&
            // This is fix. Must use '==' not '===' for this to return true
            record.get('AppId') == this.getContext().getAppId();
    },

    /**
     * This override allows the `enableUrlSharing` option to work.
     * Must override `window.location` with `parent.location`.
     */
    getSharedViewParam: function () {
        var hash = parent.location.hash,
            matches = hash.match(/sharedViewId=(\d+)/);

        return matches && matches[1];
    },

    /**
     * Override to avoid a race condition when restoring columns when using
     * `enableUrlSharing`
     * _ensureLatestView is called out of the constructor after initComponent before store.load(), but store.load() is called immediately after
     * by the parent combobox. The asynchronous store.model.load() here will race with store.load() invoked by the parent. If
     * the store.load returns first, this function would miss the load event and never apply the latest view columns.
     * 
     * Ensure we don't miss the store.load() event by registering an event handler now (before the parent calls store.load()) and
     * that handler can act on the store.model.load() promise when it resolves. This allows both loads to proceed in parallel without
     * possibly missing the load event.
     */
    _ensureLatestView: function (state) {
        if (state.objectId && state.versionId) {
            var modelLoadDeferred = Ext.create('Deft.Deferred');
            this.store.model.load(state.objectId, {
                fetch: true,
                success: function (record) {
                    modelLoadDeferred.resolve(record);
                }
            });
            this.store.on('load', function () {
                modelLoadDeferred.promise.then({
                    success: function (record) {
                        if (record && record.get('VersionId') !== state.versionId && record.raw.AppId == Rally.getApp().getAppId()) {
                            this._applyView(this._decodeValue(record));
                        }
                    },
                    scope: this
                })
            }, this, { single: true });
        }
    },

    /**
     *  Need to first make sure that the view grabbed from the URL is intended for this app
    * */
    _insertViewIntoStore: function () {
        this.store.model.load(this.sharedViewId, {
            fetch: true,
            success: function (record) {
                if (record && record.raw.AppId == Rally.getApp().getAppId()) {
                    this.callParent(arguments);
                }
            }
        });

    }
});

Ext.define('Constants', {
    statics: {
        FEATURE_FETCH: ['ObjectID', 'FormattedID', 'Name', 'PercentDoneByStoryCount', 'PercentDoneByStoryPlanEstimate', 'Project', 'DisplayColor', 'Predecessors', 'Successors'],
        STORIES_FETCH: ['ObjectID', 'FormattedID', 'Name', 'Iteration', 'Project', 'StartDate', 'EndDate', 'Predecessors', 'Successors', 'AcceptedDate'],
        STORY_COLUMNS: ['FormattedID', 'Name', 'PlanEstimate', 'ScheduleState'],
        RELEASE_CONTROL_LABEL: 'Release Tracking',
        RELEASE_CONTROL_LABEL_CLASS: 'ts-page-label',
        UNSCHEDULED: 'Unscheduled',
        START_DATE: 'From',
        END_DATE: 'To',
        PORTFOLIO_ITEMS: 'Portfolio Items'
    }
})

/* global Ext */
Ext.define('FeatureStoriesDependenciesPopover', {
    extend: Rally.ui.popover.DependenciesPopover,

    titleIconCls: null,
    title: 'Stories With Dependencies',

    constructor: function (config) {
        var numPredecessors = 0,
            numSuccessors = 0;
        _.each(config.stories, function (story) {
            var predecessorsAndSuccessors = story.get('PredecessorsAndSuccessors');
            if (predecessorsAndSuccessors) {
                numPredecessors += predecessorsAndSuccessors.Predecessors;
                numSuccessors += predecessorsAndSuccessors.Successors;
            }
            if (numPredecessors || numSuccessors) {
                return false; // No need to keep counting
            }
        }, this);

        config.items = [{
            xtype: 'tabpanel',
            activeTab: numPredecessors === 0 && numSuccessors > 0 ? 1 : 0,
            items: [{
                title: 'Predecessors',
                html: 'Loading...',
                tabConfig: {
                    width: 160
                },
            },
            {
                title: 'Successors',
                html: 'Loading...',
                tabConfig: {
                    width: 160
                }
            }
            ],
            listeners: {
                afterRender: this._onAfterRender,
                tabChange: this._onAfterRender,
                scope: this
            }
        }];

        this.loaded = {};
        //this.callSuper(arguments);
        // Get super super method (skip the extended DependenciesPopover.constructor()
        return this.superclass.superclass['constructor'].apply(this, arguments);
    },

    // fireEvent: function (eventName) {
    //     console.log(eventName);
    //     this.callParent(arguments);
    // },

    _loadData: function (tabTitle) {
        var promises = _.map(this.stories, function (story) {
            return story.getCollection(tabTitle, {
                fetch: this.fetchFields[this._getType(story)],
                requester: this
            }).load().then({
                scope: this,
                success: function (records) {
                    story.get(tabTitle)['Stories'] = records;
                    return story;
                }
            });
        }, this);

        Deft.promise.Promise.all(promises).then({
            scope: this,
            success: this._onDataRetrieved
        });
    },

    _buildContent: function (stories) {
        var html = [],
            fieldName = this._getTabPanel().getActiveTab().title;

        _.each(stories, function (story) {
            story.tplType = this._getType(story);
            var dependencies = story.get(fieldName).Stories;
            if (dependencies && dependencies.length) {
                // Add a row for the story
                html.push(this.rowTpl.apply(story));
                // Add a row for each story dependency
                _.each(dependencies, function (dependentStory) {
                    dependentStory.set('_dependencyType', fieldName);
                    html.push(this.depRowTpl.apply(dependentStory));
                }, this);
            }
            else {
                // Don't show stories with no dependencies

                // Add a "None" row
                html.push(this.noneRowTpl.apply({
                    _dependencyType: fieldName
                }));

            }
        }, this);

        return '<div class="outer-container">' + html.join("\n") + '</div>';
    },

    rowTpl: Ext.create('Ext.XTemplate',
        '<div class="dependency-row">',
        '<div class="identifier">',
        '{[this.getFormattedIdTemplate(values.data)]} <span class="object-name dependency-title">{[this.trimText(values.data, 40, "")]}</span>',
        '</div>',
        '<div class="status">',
        '<tpl if="this.isUserStory(values)">',
        '{[this.getScheduleState(values)]}',
        '</div>',
        '<span class="field-label">Iteration:</span> <span class="object-name iteration">{[this.trimText(values.data.Iteration, 25, "Unscheduled")]}</span>',
        '<tpl else>',
        '<div class="percent-done-wrapper">{[this.getPercentDoneByStoryCount(values)]}</div>',
        '</div>',
        '<tpl if="this.hasReleaseAttr(values.data)">',
        '<span class="field-label">Release:</span>  <span class="object-name release">{[this.trimText(values.data.Release, 25, "Unscheduled")]}</span>',
        '<tpl else>',
        '<span>&nbsp;</span>',
        '</tpl>',
        '</tpl>',
        '</div>', {
        isUserStory: function (record) {
            return record.tplType === 'hierarchicalrequirement';
        },
        getFormattedIdTemplate: function (data) {
            return Ext.create('Rally.ui.renderer.template.FormattedIDTemplate', {
                showIcon: true,
                showHover: false
            }).apply(data);
        },
        getScheduleState: function (record) {
            return Ext.create('Rally.ui.renderer.template.ScheduleStateTemplate', {
                field: record.getField('ScheduleState')
            }).apply(record.data);
        },
        getPercentDoneByStoryCount: function (record) {
            return Ext.create('Rally.ui.renderer.template.progressbar.PercentDoneByStoryCountTemplate', {
                field: record.getField('PercentDoneByStoryCount'),
                record: record
            }).apply(record.data);
        },
        trimText: function (data, max, defaultValue) {
            return data && data.Name ? Ext.String.ellipsis(data.Name, max) : defaultValue;
        },
        hasReleaseAttr: function (data) {
            return data.hasOwnProperty('Release');
        }
    }
    ),

    depRowTpl: Ext.create('Ext.XTemplate',
        '<div class="dependency-row ts-dependent-story">',
        '<div class="identifier">',
        '<span class="{[this.getDependencyIconClass(values.data)]}"></span>',
        '{[this.getFormattedIdTemplate(values.data)]} <span class="object-name dependency-title">{[this.trimText(values.data, 40, "")]}</span>',
        '</div>',
        '<div class="status">',
        '<tpl if="this.isUserStory(values)">',
        '{[this.getScheduleState(values)]}',
        '</div>',
        '<span class="field-label">Iteration:</span> <span class="object-name iteration">{[this.trimText(values.data.Iteration, 25, "Unscheduled")]}</span>',
        '<tpl else>',
        '<div class="percent-done-wrapper">{[this.getPercentDoneByStoryCount(values)]}</div>',
        '</div>',
        '<tpl if="this.hasReleaseAttr(values.data)">',
        '<span class="field-label">Release:</span>  <span class="object-name release">{[this.trimText(values.data.Release, 25, "Unscheduled")]}</span>',
        '<tpl else>',
        '<span>&nbsp;</span>',
        '</tpl>',
        '</tpl>',
        '</div>', {
        getDependencyIconClass: function (record) {
            return record._dependencyType == 'Predecessors' ? 'icon-predecessor' : 'icon-successor'
        },
        isUserStory: function (record) {
            return true;
        },
        getFormattedIdTemplate: function (data) {
            return Ext.create('Rally.ui.renderer.template.FormattedIDTemplate', {
                showIcon: true,
                showHover: false
            }).apply(data);
        },
        getScheduleState: function (record) {
            return Ext.create('Rally.ui.renderer.template.ScheduleStateTemplate', {
                field: record.getField('ScheduleState')
            }).apply(record.data);
        },
        getPercentDoneByStoryCount: function (record) {
            return Ext.create('Rally.ui.renderer.template.progressbar.PercentDoneByStoryCountTemplate', {
                field: record.getField('PercentDoneByStoryCount'),
                record: record
            }).apply(record.data);
        },
        trimText: function (data, max, defaultValue) {
            return data && data.Name ? Ext.String.ellipsis(data.Name, max) : defaultValue;
        },
        hasReleaseAttr: function (data) {
            return data.hasOwnProperty('Release');
        }
    }
    ),

    noneRowTpl: Ext.create('Ext.XTemplate',
        '<div class="dependency-row ts-dependent-story">',
        '<div class="identifier">',
        // '<span class="{[this.getDependencyIconClass(values)]}"></span>',
        'No {[this.getDependencyType(values)]}',
        '</div>',
        '</div>', {
        getDependencyIconClass: function (record) {
            return record._dependencyType == 'Predecessors' ? 'icon-predecessor' : 'icon-successor';
        },
        getDependencyType: function (record) {
            return record._dependencyType;
        },
    }
    ),
});

/* globals Ext */
Ext.define('StoryFeatureCard', {
    extend: 'Rally.ui.cardboard.Card',
    alias: 'widget.storyfeaturecard',
    hidden: false,
    lowestPiTypeName: 'Feature',

    initComponent: function () {
        this.hidden = this.isHiddenFunc(this);
        this.callParent(arguments);
        this.feature = this.record.get(this.lowestPiTypeName);
        if (!this.hidden) {
            this.on('ready', this._onReady, this);
        }
    },

    setupPlugins: function () {
        return [
            { ptype: 'rallycardpopover' },
        ];
    },

    reRender: function (highlight) {
        // Convert reRender calls into a re-render of the primary feature card
        if (this.hidden) {
            var primaryCard = this.getVisibleCard(this);
            primaryCard.reRender(highlight);
            primaryCard._onReady(primaryCard);
        }
        else {
            this.callParent(arguments);
            this._onReady(this);
        }
    },

    _onReady: function (card) {
        var stories = this.getAllFeatureStories(this);
        this.storyCount = stories.length;
        this.acceptedStoryCount = 0;
        this.storiesHaveDependencies = false;
        _.each(stories, function (story) {
            if (story.get('AcceptedDate')) {
                this.acceptedStoryCount = this.acceptedStoryCount + 1;
            }

            var predSuc = story.get('PredecessorsAndSuccessors');
            if (predSuc && predSuc.Count) {
                this.storiesHaveDependencies = true;
            }
        }, this);
        this.update(this._buildFinalHtml());
        this._addFinalListeners();
    },

    _getFeatureColor: function () {
        var artifactColorDiv = {
            tag: 'div',
            cls: 'ts-artifact-color'
        };
        if (this.feature.DisplayColor) {
            artifactColorDiv.style = {
                backgroundColor: this.feature.DisplayColor
            };
        }
        return Ext.DomHelper.createHtml(artifactColorDiv);
    },

    _buildHtml: function () {
        return this._buildInitialHtml();
    },

    _buildInitialHtml: function () {
        var record = this.getRecord();
        var html = [];
        html.push('<div class="ts-card-table-ct"><table class="ts-card-table"><tr>');
        html.push('<td class="ts-card-content">' + this._getFeatureColor() + '</td>');
        html.push(`<td class="ts-card-content"><div class="field-content" data-qtip="${this.feature.Name}">${this.feature.FormattedID}</div></td>`);
        html.push('</tr></table>');
        return html.join('\n');
    },

    _buildFinalHtml: function (stories) {
        var record = this.getRecord();
        var feature = record.get(this.lowestPiTypeName);
        var html = [];
        html.push('<div class="ts-card-table-ct"><table class="ts-card-table"><tr>');

        html.push('<td class="ts-card-content">' + this._getFeatureColor() + '</td>');
        html.push(`<td class="ts-card-content ts-formatted-id"><div class="field-content" data-qtip="${this.feature.Name}">${this.feature.FormattedID}</div></td>`);
        html.push('<td class="ts-card-content ts-card-icons">');
        if (this.storiesHaveDependencies) {
            html.push('<span class="field-content FeatureStoriesPredecessorsAndSuccessors icon-children" data-qtip="Story to Story Dependencies"></span>');
            html.push('<span class="field-content FeatureStoriesPredecessorsAndSuccessorsCancel icon-cancel"></span>');
        }
        var featurePred = feature.Predecessors;
        var featureSucc = feature.Successors;
        if ((featurePred && featurePred.Count) || (featureSucc && featureSucc.Count)) {
            html.push('<span class="field-content FeaturePredecessorsAndSuccessors icon-predecessor" data-qtip="Feature to Feature Dependencies"></span>');
        }
        html.push('</td>');
        html.push('<td class="ts-card-content ts-accepted-count"><span class="field-content">' + this.acceptedStoryCount + ' / ' + this.storyCount + '</span></td>');
        html.push('</tr></table>');
        return html.join('\n');
    },

    _addFinalListeners: function () {
        var el = this.getEl();
        var table = el.down('.ts-card-table')
        if (table) {
            table.on('click', function (event, target, options) {
                this.fireEvent('story', this);
            }, this);
        }
        var predSucIcon = el.down('.FeatureStoriesPredecessorsAndSuccessors');
        if (predSucIcon) {
            predSucIcon.on('click', function (event, target, options) {
                this.fireEvent('fieldclick', 'FeatureStoriesPredecessorsAndSuccessors', this);
                return false;
            }, this, {
                card: this,
                stopPropagation: true // Prevent stories popup from also showing
            });
        }
        var featurePredSucIcon = el.down('.FeaturePredecessorsAndSuccessors');
        if (featurePredSucIcon) {
            featurePredSucIcon.on('click', function () {
                this.fireEvent('fieldclick', 'FeaturePredecessorsAndSuccessors', this);
                return false;
            }, this, {
                card: this,
                stopPropagation: true // Prevent stories popup from also showing
            });
        }
        var cancelIcon = el.down('.FeatureStoriesPredecessorsAndSuccessorsCancel');
        if (cancelIcon) {
            cancelIcon.on('click', function (event, target, options) {
                this.fireEvent('fieldclick', 'FeatureStoriesPredecessorsAndSuccessorsCancel', this);
                return false;
            }, this, {
                card: this,
                stopPropagation: true // Prevent stories popup from also showing
            });

            cancelIcon.setStyle('display', 'none');
        }
    }
});

/**
     * Adds a button to a GridBoard to filter on Feature dependencies and/or Features with Story dependencies
**/
Ext.define('CustomAgile.ui.gridboard.DependencyFilter', {
    alias: 'widget.gridboarddependencyfilter',
    extend: 'Rally.ui.Button',

    stateful: true,

    stateId: 'gridboarddependencyfilter',

    config: {
        filterFeatures: false,
        filterStories: false,
        filterMatch: 'AND',
        tooltipText: 'Dependencies',
        margin: '3 9 0 0',
        cls: 'field-picker-btn secondary rly-small',
        iconCls: 'icon-predecessor',
        handler: (btn) => {
            btn._onClick(btn);
        }
    },

    constructor: function (config) {
        this.mergeConfig(config);
        this.callParent([this.config]);
        this.on('afterrender', this.updateFilterCount);
    },

    _onClick: function (btn) {
        this._createPopover(btn.getEl());
    },

    _createPopover: function (popoverTarget) {
        this.popover = Ext.create('Rally.ui.popover.Popover', {
            target: popoverTarget,
            placement: ['bottom', 'left', 'top', 'right'],
            cls: 'field-picker-popover',
            width: 300,
            toFront: Ext.emptyFn,
            buttonAlign: 'center',
            title: this.tooltipText,
            listeners: {
                destroy: function () {
                    this.popover = null;
                },
                scope: this
            },
            buttons: [
                {
                    xtype: "rallybutton",
                    text: 'Apply',
                    cls: 'field-picker-apply-btn primary rly-small dependency-filter-btn',
                    listeners: {
                        click: function () {
                            this._onApply(this.popover);
                        },
                        scope: this
                    }
                },
                {
                    xtype: "rallybutton",
                    text: 'Cancel',
                    cls: 'field-picker-cancel-btn secondary dark rly-small',
                    listeners: {
                        click: this.cancel,
                        scope: this
                    }
                }
            ],
            items: [
                {
                    xtype: 'container',
                    cls: 'dep-checkbox-container',
                    itemId: 'checkboxfiltercontainer',
                    width: 200,
                    listeners: {
                        specialkey: function (field, e) {
                            if (e.getKey() === e.ESC) {
                                this.popover.close();
                            }
                        },
                        scope: this
                    },
                    items: [
                        {
                            xtype: 'rallycheckboxfield',
                            stateEvents: ['change'],
                            boxLabel: 'Filter on Features w/ Dependencies',
                            boxLabelCls: 'dependency-label',
                            margin: 10,
                            name: 'featuresWithDependencies',
                            inputValue: true,
                            value: this.filterFeatures,
                            itemId: 'featuresWithDependenciesCheckbox',
                            cls: 'dependency-checkbox',
                            listeners: {
                                scope: this,
                                change: function (cmp, newVal) {
                                    this.filterFeatures = newVal;
                                    this.updateMatchCombo();
                                }
                            }
                        },
                        {
                            xtype: 'rallycheckboxfield',
                            stateEvents: ['change'],
                            boxLabel: 'Filter on Features w/ Story Dependencies',
                            boxLabelCls: 'dependency-label',
                            margin: 10,
                            name: 'featuresWithStoryDependencies',
                            inputValue: true,
                            value: this.filterStories,
                            itemId: 'featuresWithStoryDependenciesCheckbox',
                            cls: 'dependency-checkbox',
                            listeners: {
                                scope: this,
                                change: function (cmp, newVal) {
                                    this.filterStories = newVal;
                                    this.updateMatchCombo();
                                }
                            }
                        },
                        {
                            xtype: 'rallycombobox',
                            itemId: 'dependencyFilterMatchCombo',
                            hideLabel: false,
                            margin: 10,
                            fieldLabel: 'Filter Match Condition',
                            labelAlign: 'top',
                            queryMode: 'local',
                            store: {
                                fields: ['label', 'value'],
                                data: [
                                    { label: 'Both Filters', value: 'AND' },
                                    { label: 'Either Filter', value: 'OR' }
                                ]
                            },
                            width: 120,
                            displayField: 'label',
                            valueField: 'value',
                            editable: false,
                            autoSelect: true,
                            forceSelection: true,
                            value: this.filterMatch || 'All',
                            disabled: !(this.filterFeatures && this.filterStories),
                            listeners: {
                                scope: this,
                                change: function (cmp, newVal) {
                                    this.filterMatch = newVal;
                                }
                            }
                        }
                    ]
                }
            ]
        });
    },

    updateMatchCombo: function () {
        if (this.popover) {
            let combo = this.popover.down('#dependencyFilterMatchCombo');
            if (combo) {
                combo.setDisabled(!(this.filterFeatures && this.filterStories));
            }
        }
    },

    getFilters: function () {
        let filters = [];

        if (this.filterFeatures) {
            let featureFilter = Ext.create('Rally.data.wsapi.Filter', {
                property: 'Predecessors.ObjectID',
                operator: '!=',
                value: null
            });

            featureFilter = featureFilter.or(Ext.create('Rally.data.wsapi.Filter', {
                property: 'Successors.ObjectID',
                operator: '!=',
                value: null
            }));

            filters.push(featureFilter);
        }

        if (this.filterStories) {
            let storyFilter = Ext.create('Rally.data.wsapi.Filter', {
                property: 'UserStories.Predecessors.ObjectID',
                operator: '!=',
                value: null
            });

            storyFilter = storyFilter.or(Ext.create('Rally.data.wsapi.Filter', {
                property: 'UserStories.Successors.ObjectID',
                operator: '!=',
                value: null
            }));

            filters.push(storyFilter);
        }

        if (this.filterFeatures && this.filterStories) {
            if (this.filterMatch === 'AND') {
                return [Rally.data.wsapi.Filter.and(filters)];
            }
            else {
                return [Rally.data.wsapi.Filter.or(filters)];
            }
        }

        return filters;
    },

    cancel: function () {
        if (this.popover) {
            this.popover.close();
        }

        if (this.stateful && this.stateId) {
            let state = Ext.state.Manager.get(this.stateId, {});
            this.updateValues(state);
        }
    },

    _onApply: function (popover) {
        this.updateFilterCount();
        this.saveState();
        this.fireEvent('dependencyfilterchange', this.getFilters());
        popover.close();
    },

    updateFilterCount: function () {
        if (this.filterCounter) {
            this.filterCounter.remove();
        }
        let filterCount = 0;
        if (this.filterFeatures) { filterCount++; }
        if (this.filterStories) { filterCount++; }

        if (filterCount) {
            this.filterCounter = document.createElement('div');
            this.filterCounter.classList.add('dependency-filter-count');
            let text = document.createTextNode(filterCount.toString());
            this.filterCounter.appendChild(text);
            if (this.el && Ext.isFunction(this.el.appendChild)) {
                this.el.appendChild(this.filterCounter);
            }
        }
    },

    getState: function () {
        return {
            filterFeatures: this.filterFeatures,
            filterStories: this.filterStories,
            filterMatch: this.filterMatch
        };
    },

    applyState: function (state) {
        this.updateValues(state);
        this.fireEvent('dependencyfilterstateapplied', this.getFilters());
    },

    updateValues: function (state) {
        this.filterFeatures = state.filterFeatures;
        this.filterStories = state.filterStories;
        this.filterMatch = state.filterMatch;
        this.updateFilterCount();

        if (this.popover) {
            let featureCheckbox = this.popover.down('#featuresWithDependenciesCheckbox');
            let storyCheckbox = this.popover.down('#featuresWithStoryDependenciesCheckbox');
            let matchCombo = this.popover.down('#dependencyFilterMatchCombo');

            featureCheckbox.setValue(state.filterFeatures);
            storyCheckbox.setValue(state.filterStories);
            matchCombo.setValue(state.filterMatch);
        }
    },

    getFeaturesWithDependenciesValue: function () {
        return this.filterFeatures;
    },

    getFeaturesWithStoryDependenciesValue: function () {
        return this.filterStories;
    },

    getFilterMatchValue: function () {
        return this.filterMatch;
    },

    saveState: function () {
        var me = this,
            id = me.stateful && me.stateId,
            state;

        if (id) {
            state = me.getState() || {};
            Ext.state.Manager.set(id, state);
        }
    }
});
Ext.define('Rally.technicalservices.HierarchyExporter', {

    mixins: {
        observable: 'Ext.util.Observable'
    },

    records: undefined,

    constructor: function (config) {
        this.mixins.observable.constructor.call(this, config);
        this.modelName = config.modelName;
        this.records = [];
        this.fileName = config.fileName || "export.csv";
        this.columns = config.columns || [{ dataIndex: 'FormattedID', text: 'ID' }, { dataIndex: 'Name', text: 'Name' }];
        this.portfolioItemTypeObjects = config.portfolioItemTypeObjects || [];
    },
    setRecords: function (type, records) {
        this.records = (this.records || []).concat(records);
    },
    export: function () {

        this.fireEvent('exportupdate', "Preparing export data");

        //var columns = _.filter(this.columns, function(c){ return c.dataIndex !== "FormattedID"; }),
        var columns = this.columns,
            hierarchicalData = this._buildHierarchy(),
            exportData = this._getExportableHierarchicalData(hierarchicalData, columns);

        var ancestorType = this.modelName.toLowerCase();
        if (hierarchicalData.length > 0) {
            ancestorType = hierarchicalData[0]._type;
        }
        columns = this._getAncestorTypeColumns(ancestorType).concat(columns);

        var csv = this._transformDataToDelimitedString(exportData, columns);

        this.saveCSVToFile(csv, this.fileName);
        this.fireEvent('exportcomplete');

    },
    _buildHierarchy: function () {
        var rootItems = [];

        var objectHash = _.reduce(this.records, function (objHash, record) {
            var oid = record.get('ObjectID');
            objHash[oid] = record.getData();
            objHash[oid].loadedChildren = [];
            return objHash;
        }, {});

        this.records = null;

        for (var key in objectHash) {
            /*
             * guess at parent based on populated field.  it is
             * possible for an item to have two parents (e.g., a defect
             * might have a story and a test case related "above" it
             * this will default to the first it finds
             */
            var obj = objectHash[key],
                parent = obj.Parent && obj.Parent.ObjectID ||
                    obj.PortfolioItem && obj.PortfolioItem.ObjectID ||
                    obj.WorkProduct && obj.WorkProduct.ObjectID ||
                    obj.Requirement && obj.Requirement.ObjectID ||
                    obj.TestCase && obj.TestCase.ObjectID;

            //   if (obj._type === 'task') { console.log('obj',parent, obj._type, obj)};
            if (parent && objectHash[parent]) {
                objectHash[parent].loadedChildren.push(obj);
            }
            else {
                var grandParent = obj.Parent && obj.Parent.Parent && obj.Parent.Parent.ObjectID || null;
                if (grandParent && objectHash[grandParent]) {
                    objectHash[grandParent].loadedChildren.push(obj);
                }
                else {
                    rootItems.push(obj);
                }
            }
        }
        return rootItems;
    },
    _transformDataToDelimitedString: function (data, columns) {
        var csvArray = [],
            delimiter = ",",
            rowDelimiter = "\r\n",
            re = new RegExp(delimiter + '|\"|\r|\n', 'g'),
            reHTML = new RegExp('<\/?[^>]+>', 'g'),
            reNbsp = new RegExp('&nbsp;', 'ig');

        var column_keys = _.map(columns, function (c) { return c.dataIndex; }),
            column_headers = _.pluck(columns, 'text');

        csvArray.push(column_headers.join(delimiter));

        Ext.Array.each(data, function (obj) {
            var data = [];
            Ext.Array.each(column_keys, function (key) {
                var val = obj[key];

                if (key === "Parent") {
                    val = obj[key] || obj['PortfolioItem'];
                }

                if (val) {
                    if (reHTML.test(val)) {
                        val = val.replace('<br>', '\r\n');
                        val = Ext.util.Format.htmlDecode(val);
                        val = Ext.util.Format.stripTags(val);
                    }
                    if (reNbsp.test(val)) {
                        val = val.replace(reNbsp, ' ');
                    }

                    if (re.test(val)) { //enclose in double quotes if we have the delimiters
                        val = val.replace(/\"/g, '\"\"');
                        val = Ext.String.format("\"{0}\"", val);
                    }

                }
                data.push(val);
            }, this);
            csvArray.push(data.join(delimiter));
        }, this);

        return csvArray.join(rowDelimiter);
    },
    /**
     * Returns an array of hash rollup data
     *
     * @param rootObjectIDs
     * @param columns - the data index of the columns that we want to export.
     * @param rollupData
     * @returns {Array}
     * @private
     */
    _getExportableHierarchicalData: function (hierarchyData, columns) {

        var exportData = [];

        _.each(hierarchyData, function (r) {
            var ancestors = {};
            var rec = this._getExportDataRow(r, columns, ancestors);
            exportData.push(rec);
            this._addExportChildren(r, exportData, columns, ancestors);
        }, this);

        return exportData;
    },
    _addExportChildren: function (record, exportData, columns, ancestors) {
        var new_ancestors = Ext.clone(ancestors),
            me = this;

        if (Ext.isEmpty(new_ancestors[record._type])) {
            new_ancestors[record._type] = record.FormattedID;
        }

        var children = record.loadedChildren;
        if (children && children.length > 0) {
            _.each(children, function (c) {
                var row = this._getExportDataRow(c, columns, new_ancestors);
                // if this is a descendant of a story, set the field that
                // represents the User Story column to be the first level
                // level story
                var child_type = row._type;
                if (!Ext.isEmpty(new_ancestors[child_type])) {
                    row[child_type] = new_ancestors[child_type];
                }
                exportData.push(row);
                me._addExportChildren(c, exportData, columns, new_ancestors);
            }, this);
        }

        return;
    },
    getTypePathDisplayName: function (modelName) {
        if (modelName.toLowerCase() === 'hierarchicalrequirement') {
            return 'User Story';
        }
        if (modelName.toLowerCase() === 'task') {
            return 'Task';
        }
        if (modelName.toLowerCase() === 'defect') {
            return 'Defect';
        }
        if (modelName.toLowerCase() === 'testcase') {
            return 'Test Case';
        }

        var displayName = '';
        Ext.Array.each(this.portfolioItemTypeObjects, function (p) {
            if (p.get('TypePath').toLowerCase() === modelName.toLowerCase()) {
                displayName = p.get('Name');
                return false;
            }
        });
        return displayName;
    },
    _getExportDataRow: function (recData, columns, ancestors) {
        var rec = Ext.clone(ancestors),
            type = recData._type;

        rec[type] = recData.FormattedID;
        rec.type = this.getTypePathDisplayName(recData._type);
        rec._type = recData._type;

        _.each(columns, function (c) {
            var field = c.dataIndex || null;
            if (field) {
                var data = recData[field];

                if (field === "Predecessors" || field === "Successors") {
                    data = (recData[field] && recData[field].Count) || 0;
                }
                else if (field === "Parent") {
                    data = recData[field] || recData["PortfolioItem"];
                }

                if (Ext.isObject(data)) {
                    if (data._tagsNameArray && data._tagsNameArray.length > 0) {
                        var names = _.pluck(data._tagsNameArray, 'Name');
                        rec[field] = names.join(',');
                    }
                    else if (data.FormattedID) {
                        rec[field] = data.FormattedID + ": " + data._refObjectName;
                    }
                    else {
                        rec[field] = data._refObjectName;
                    }
                }
                else if (Ext.isDate(data)) {
                    rec[field] = Rally.util.DateTime.formatWithDefaultDateTime(data);
                }
                else {
                    rec[field] = data;
                }
            }
        });

        return rec;
    },
    _getAncestorTypeColumns: function (rootModel) {
        var modelName = rootModel.toLowerCase();
        var columns = [];
        if (modelName == 'hierarchicalrequirement' || Ext.String.startsWith(modelName, 'portfolioitem')) {
            var piTypes = this.portfolioItemTypeObjects,
                piIdx = -1;

            Ext.Array.each(piTypes, function (piObj, idx) {
                if (piObj.get('TypePath').toLowerCase() === rootModel.toLowerCase()) {
                    piIdx = idx;
                }
            });

            columns.push({
                dataIndex: 'hierarchicalrequirement',
                text: 'User Story'
            });

            if (piIdx >= 0) {
                columns = columns.concat(Ext.Array.map(piTypes.slice(0, piIdx + 1), function (piObj) {
                    return {
                        dataIndex: piObj.get('TypePath').toLowerCase(),
                        text: piObj.get('Name')
                    };
                }));
                columns.push({
                    dataIndex: 'type',
                    text: 'Artifact Type'
                });

            }
            columns.reverse();
        }
        return columns;
    },
    saveCSVToFile: function (csv, file_name, type_object) {
        if (type_object === undefined) {
            type_object = { type: 'text/csv;charset=utf-8' };
        }
        this.saveAs(csv, file_name, type_object);
    },
    saveAs: function (textToWrite, fileName) {
        if (Ext.isIE9m) {
            Rally.ui.notify.Notifier.showWarning({ message: "Export is not supported for IE9 and below." });
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], { type: 'text/plain' });
        }
        catch (e) {
            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder && e.name == 'TypeError') {
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob) {
            Rally.ui.notify.Notifier.showWarning({ message: "Export is not supported for this browser." });
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p) {
            window.navigator.msSaveOrOpenBlob(textFileAsBlob, fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url) {
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink) {
                downloadLink.download = fileNameToSaveAs;
            }
            else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome) {
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        }
        else {
            Rally.ui.notify.Notifier.showError({ message: "Export is not supported " });
        }

    },
    createObjectURL: function (file) {
        if (window.webkitURL) {
            return window.webkitURL.createObjectURL(file);
        }
        else if (window.URL && window.URL.createObjectURL) {
            return window.URL.createObjectURL(file);
        }
        else {
            return null;
        }
    },
    destroyClickedElement: function (event) {
        document.body.removeChild(event.target);
    }
});

Ext.define('Rally.technicalservices.HierarchyLoader', {

    storyModelName: 'hierarchicalrequirement',
    taskModelName: 'task',

    mixins: {
        observable: 'Ext.util.Observable'
    },

    model: undefined,
    filters: undefined,
    fetch: undefined,
    childModels: undefined,
    sorters: undefined,

    maxParallelCalls: 6,

    constructor: function (config) {
        this.mixins.observable.constructor.call(this, config);
        this.portfolioItemTypes = config.portfolioItemTypes || [];
        this.model = config.model || null;
        this.fetch = config.fetch || [];
        this.filters = config.filters || [];
        this.loadChildModels = config.loadChildModels || [];
        this.sorters = config.sorters || [];
    },
    load: function () {

        if (!this.model) {
            this.fireEvent('hierarchyloaderror', "No model specified.");
            return;
        }
        if (this.portfolioItemTypes.length === 0) {
            this.fireEvent('hierarchyloaderror', "Portfolio Item Types not initialized.");
            return;
        }
        if (!(this.loadChildModels instanceof Array)) {
            this.fireEvent('hierarchyloaderror', "No child models specified.");
            return;
        }

        var fns = [];
        for (var i = 0; i < this.loadChildModels.length + 4; i++) {
            fns.push(this.fetchNextLevel);
        }

        Deft.Chain.pipeline(fns, this).then({
            success: function () {
                this.fireEvent('hierarchyloadcomplete');
            },
            failure: function (msg) {
                this.fireEvent('hierarchyloaderror', msg);
            },
            scope: this
        });
    },
    fetchNextLevel: function (args) {
        if (!args) {
            return this.fetchRoot();
        }

        args = _.flatten(args);

        if (args.length > 0 && Ext.isFunction(args[0].get)) {
            var type = args[0].get('_type');
            var types = Ext.Array.unique(Ext.Array.map(args, function (arg) { return arg.get('_type'); }));

            this.fireEvent('hierarchyloadartifactsloaded', type, args);

            var portfolioItemTypePaths = _.map(this.portfolioItemTypes, function (type) {
                return type.get('TypePath').toLowerCase();
            }),
                portfolioItemOrdinal = _.indexOf(portfolioItemTypePaths, type);

            if (portfolioItemOrdinal === 0 && Ext.Array.contains(this.loadChildModels, this.storyModelName)) {
                return this.fetchUserStories(args);
            }
            if (portfolioItemOrdinal > 0 && Ext.Array.contains(this.loadChildModels, portfolioItemTypePaths[portfolioItemOrdinal - 1])) {
                return this.fetchPortfolioItems(portfolioItemTypePaths[portfolioItemOrdinal - 1], args);
            }

            return this.fetchChildrenFromMultipleTypes(types, args);

        }
        return [];
    },

    fetchRoot: function () {
        var fetch = this.fetch.concat(this.getRequiredFetchFields(this.model));
        this.fireEvent('statusupdate', "Loading artifacts");
        var config = {
            model: this.model,
            fetch: fetch,
            filters: this.filters,
            sorters: this.sorters,
            context: this.context
        };

        return this.fetchWsapiRecords(config);
    },
    fetchPortfolioItems: function (type, parentRecords) {

        var fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            chunks = this._getChunks(parentRecords, 'Children', 'Count');

        return this.fetchChunks(type, fetch, chunks, "Parent.ObjectID", Ext.String.format("Please Wait... Loading Children for {0} Portfolio Items", parentRecords.length));
    },
    _getChunks: function (parentRecords, countField, countFieldAttribute) {

        var chunks = [],
            childCount = 0,
            maxListSize = 100,
            childCountTarget = 200,
            idx = 0;

        chunks[idx] = [];
        _.each(parentRecords, function (r) {
            var count = r.get(countField);
            if (countFieldAttribute && count) {
                count = count[countFieldAttribute];
            }
            if (count > 0) { //using story count because it is a more accurate gauge of the number of user stories for a feature than UserStories.Count is, evne though it may not match exactly.
                childCount += count;
                if (childCount > childCountTarget || chunks[idx].length >= maxListSize) {
                    idx++;
                    chunks[idx] = [];
                    childCount = 0;
                }
                chunks[idx].push(r.get('ObjectID'));
            }
        });

        return chunks;
    },
    fetchUserStories: function (parentRecords) {
        var type = this.storyModelName,
            fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            chunks = this._getChunks(parentRecords, 'LeafStoryCount'),
            featureParentName = this.portfolioItemTypes[0].get('Name').replace(/\s/g, '') + ".ObjectID";

        return this.fetchChunks(type, fetch, chunks, featureParentName, Ext.String.format("Please Wait... Loading User Stories for {0} Portfolio Items", parentRecords.length));
    },

    fetchChildrenFromMultipleTypes: function (types, parentRecords) {

        var promises = [];
        Ext.Array.map(types, function (type) {
            child_types = this.getAllowedChildTypes(type);
            if (child_types.length > 0) {
                var parents = Ext.Array.filter(parentRecords, function (parent) {
                    return (parent.get('_type') == type);
                }, this);
                promises.push(function () {
                    return this.fetchChildrenOfMultipleTypes(parents);
                });
            }
        }, this);

        if (promises.length === 0) { return []; }
        return Deft.Chain.sequence(promises, this);
    },
    fetchChildrenOfMultipleTypes: function (parentRecords) {
        var parent_type = parentRecords[0].get('_type');
        var child_types = this.getAllowedChildTypes(parent_type);
        var promises = Ext.Array.map(child_types, function (type) {
            return function () { return this.fetchChildren(type, parentRecords); }
        }, this);

        return Deft.Chain.sequence(promises, this);
    },

    fetchChildren: function (type, parentRecords) {
        var fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            parentType = parentRecords[0].get('_type'),
            childField = this.getChildFieldFor(parentType, type),
            chunks = this._getChunks(parentRecords, childField, 'Count'),
            parentField = this.getParentFieldFor(type, parentType);

        return this.fetchChunks(type, fetch, chunks, parentField + ".ObjectID",
            Ext.String.format("Please Wait... Loading {0} for {1} items", childField, parentRecords.length));
    },

    fetchChunks: function (type, fetch, chunks, chunkProperty, statusString) {

        if (!chunks || chunks.length === 0) {
            return [];
        }
        if (chunks[0].length === 0) {
            return [];
        }

        this.fireEvent('statusupdate', statusString);

        var promises = [];

        _.each(chunks, function (c) {
            var filters = _.map(c, function (ids) { return { property: chunkProperty, value: ids }; });
            filters = Rally.data.wsapi.Filter.or(filters);

            var config = {
                model: type,
                fetch: fetch,
                sorters: [
                    { property: 'TaskIndex', direction: 'ASC' },
                    { property: 'DragAndDropRank', direction: 'ASC' }
                ],
                filters: filters,
                context: { project: null }
            };
            promises.push(function () { return this.fetchWsapiRecords(config); });
        });

        return this.throttle(promises, this.maxParallelCalls, this);
    },
    fetchWsapiRecords: function (config) {
        var deferred = Ext.create('Deft.Deferred');

        config.compact = false;
        config.limit = "Infinity";
        config.allowPostGet = true;

        Ext.create('Rally.data.wsapi.Store', config).load({
            callback: function (records, operation) {
                if (operation.wasSuccessful()) {
                    deferred.resolve(records);
                }
                else {
                    deferred.reject('fetchWsapiRecords error: ' + operation.error.errors.join(','));
                }
            },
            scope: this
        });
        return deferred;
    },

    getChildFieldFor: function (parent_type, child_type) {
        if (parent_type.toLowerCase() === "hierarchicalrequirement" || parent_type.toLowerCase() === "userstory") {
            if (child_type.toLowerCase() == "task") { return 'Tasks'; }
            if (child_type.toLowerCase() == "defect") { return 'Defects'; }
            if (child_type.toLowerCase() == "testcase") { return 'TestCases'; }
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'Children'; }
        }
        if (parent_type.toLowerCase() === "defect") {
            if (child_type.toLowerCase() == "task") { return 'Tasks'; }
            if (child_type.toLowerCase() == "testcase") { return 'TestCases'; }
        }
        if (parent_type.toLowerCase() === "testcase") {
            if (child_type.toLowerCase() == "defect") { return 'Defects'; }
        }
        if (/portfolioitem/.test(parent_type.toLowerCase())) {
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'UserStories'; }
        }
        return null;
    },

    getParentFieldFor: function (child_type, parent_type) {
        if (parent_type.toLowerCase() === "hierarchicalrequirement" || parent_type.toLowerCase() === "userstory") {
            if (child_type.toLowerCase() == "task") { return 'WorkProduct'; }
            if (child_type.toLowerCase() == "defect") { return 'Requirement'; }
            if (child_type.toLowerCase() == "testcase") { return 'WorkProduct'; }
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'Parent'; }
        }
        if (parent_type.toLowerCase() === "defect") {
            if (child_type.toLowerCase() == "task") { return 'WorkProduct'; }
            if (child_type.toLowerCase() == "testcase") { return 'WorkProduct'; }
        }
        if (parent_type.toLowerCase() === "testcase") {
            if (child_type.toLowerCase() == "defect") { return 'TestCase'; }
        }
        if (/portfolioitem/.test(parent_type.toLowerCase())) {
            if (child_type.toLowerCase() == "hierarchicalrequirement") { return 'PortfolioItem'; }
        }
        return null;

    },
    getAllowedChildTypes: function (type) {
        var allowed_types = [];
        var given_types = this.loadChildModels;

        if (type.toLowerCase() === this.storyModelName.toLowerCase()) {
            allowed_types = ['task', 'defect', 'testcase', this.storyModelName.toLowerCase()];
        }
        if (type.toLowerCase() === 'defect') {
            allowed_types = ['task', 'testcase'];
        }
        if (type.toLowerCase() === 'testcase') {
            allowed_types = ['defect'];
        }

        var types_in_both = Ext.Array.intersect(allowed_types, given_types);
        return types_in_both;
    },

    getRequiredFetchFields: function (type) {
        if (/^portfolioitem/.test(type.toLowerCase())) {
            return ['Children', 'LeafStoryCount', 'Parent', 'ObjectID', 'UserStories'];
        }

        if (type.toLowerCase() === this.storyModelName) {
            return ['FormattedID', 'Children', 'Tasks', 'Parent', 'PortfolioItem', 'HasParent', 'ObjectID', 'TestCases', 'Defects', 'PredecessorsAndSuccessors'];
        }

        return ['ObjectID', 'WorkProduct', 'Defects', 'Tasks', 'TestCases', 'Requirement', 'TestCase', 'FormattedID'];
    },
    throttle: function (fns, maxParallelCalls, scope) {

        if (maxParallelCalls <= 0 || fns.length < maxParallelCalls) {
            return Deft.promise.Chain.parallel(fns, scope);
        }


        var parallelFns = [],
            fnChunks = [],
            idx = -1;

        for (var i = 0; i < fns.length; i++) {
            if (i % maxParallelCalls === 0) {
                idx++;
                fnChunks[idx] = [];
            }
            fnChunks[idx].push(fns[i]);
        }

        _.each(fnChunks, function (chunk) {
            parallelFns.push(function () {
                return Deft.promise.Chain.parallel(chunk, scope);
            });
        });

        return Deft.Promise.reduce(parallelFns, function (groupResults, fnGroup) {
            return Deft.Promise.when(fnGroup.call(scope)).then(function (results) {
                groupResults = groupResults.concat(results || []);
                return groupResults;
            });
        }, []);
    }

});

dependencyExample = 'data: image / png; base64, iVBORw0KGgoAAAANSUhEUgAAA + 4AAABYCAYAAABrn61LAAAMSWlDQ1BJQ0MgUHJvZmlsZQAASImVVwdYU8kWnltSSWiBCEgJvYlSpEsJoUUQkCrYCEkgocSQEETsLssquHYRARu6KqLoWgBZK + paF8HuWh6KqCjrYsGGypsUWNf93nvfO9839 / 45c85 / SubeOwOATg1PKs1FdQHIkxTI4iNCWJNS01ikLoAAFNCBHhjJ48ul7Li4aABl6P53eXsDWkO56qLk + uf8fxU9gVDOBwCJgzhDIOfnQXwQALyEL5UVAED0gXrrmQVSJZ4CsYEMJgixVImz1LhEiTPUuFJlkxjPgXg3AGQajyfLAkC7GepZhfwsyKN9C2JXiUAsAUCHDHEgX8QTQBwJ8ai8vBlKDO2AQ8ZXPFl / 48wY5uTxsoaxuhaVkEPFcmkub9b / 2Y7 / LXm5iqEYdnDQRLLIeGXNsG + 3cmZEKTEN4l5JRkwsxPoQvxcLVPYQo1SRIjJJbY + a8uUc2DPAhNhVwAuNgtgU4nBJbky0Rp + RKQ7nQgxXCFokLuAmanwXC + VhCRrOGtmM + NghnCnjsDW + DTyZKq7S / rQiJ4mt4b8lEnKH + N8UixJT1Dlj1EJxcgzE2hAz5TkJUWobzKZYxIkZspEp4pX520DsJ5REhKj5sWmZsvB4jb0sTz5UL7ZYJObGaHBVgSgxUsOzm89T5W8EcbNQwk4a4hHKJ0UP1SIQhoapa8fahZIkTb1Yp7QgJF7j + 0qaG6exx6nC3Ail3gpiU3lhgsYXDyyAC1LNj8dIC + IS1XniGdm88XHqfPAiEA04IBSwgAKODDADZANxW29TL / ylngkHPCADWUAIXDSaIY8U1YwEXhNAMfgDIiGQD / uFqGaFoBDqPw9r1VcXkKmaLVR55IDHEOeBKJALfytUXpLhaMngEdSI / xGdD3PNhUM5908dG2qiNRrFEC9LZ8iSGEYMJUYSw4mOuAkeiPvj0fAaDIc77oP7DmX7lz3hMaGD8JBwndBJuD1dvEj2TT0sMAF0wgjhmpozvq4Zt4OsnngIHgD5ITfOxE2ACz4WRmLjQTC2J9RyNJkrq / +W + 281fNV1jR3FlYJSRlCCKQ7femo7aXsOsyh7 + nWH1LlmDPeVMzzzbXzOV50WwHvUt5bYYuwAdhY7iZ3HjmBNgIUdx5qxS9hRJR5eRY9Uq2goWrwqnxzII / 5HPJ4mprKTctd61x7XT + q5AmGR8v0IODOks2TiLFEBiw3f / EIWV8IfPYrl7urmC4DyO6J + Tb1mqr4PCPPCX7r8EwD4lkFl1l86njUAhx8DwHj7l876FXw8VgBwtJ2vkBWqdbjyQgBUoAOfKGNgDqyBA6zHHXgBfxAMwsB4EAsSQSqYBrssgutZBmaCOWAhKAXlYAVYC6rAJrAV7AR7wH7QBI6Ak + BXcBG0g + vgDlw93eA56ANvwQCCICSEjjAQY8QCsUWcEXfEBwlEwpBoJB5JRdKRLESCKJA5yHdIObIKqUK2IHXIz8hh5CRyHulAbiMPkB7kFfIRxVAaaoCaoXboGNQHZaNRaCI6Fc1C89FitARdhlaitehutBE9iV5Er6Od6HO0HwOYFsbELDEXzAfjYLFYGpaJybB5WBlWgdViDVgL / J + vYp1YL / YBJ + IMnIW7wBUciSfhfDwfn4cvxavwnXgjfhq / ij / A + /AvBDrBlOBM8CNwCZMIWYSZhFJCBWE74RDhDHyauglviUQik2hP9IZPYyoxmzibuJS4gbiXeILYQewi9pNIJGOSMymAFEvikQpIpaT1pN2k46QrpG7Se7IW2YLsTg4np5El5EXkCvIu8jHyFfIT8gBFl2JL8aPEUgSUWZTllG2UFsplSjdlgKpHtacGUBOp2dSF1EpqA/UM9S71tZaWlpWWr9ZELbHWAq1KrX1a57QeaH2g6dOcaBzaFJqCtoy2g3aCdpv2mk6n29GD6Wn0Avoyeh39FP0 + /b02Q3u0NldboD1fu1q7UfuK9gsdio6tDltnmk6xToXOAZ3LOr26FF07XY4uT3eebrXuYd2buv16DD03vVi9PL2lerv0zus91Sfp2+mH6Qv0S/S36p / S72JgDGsGh8FnfMfYxjjD6DYgGtgbcA2yDcoN9hi0GfQZ6huONUw2LDKsNjxq2MnEmHZMLjOXuZy5n3mD + XGE2Qj2COGIJSMaRlwZ8c5opFGwkdCozGiv0XWjj8Ys4zDjHOOVxk3G90xwEyeTiSYzTTaanDHpHWkw0n8kf2TZyP0jfzdFTZ1M401nm241vWTab2ZuFmEmNVtvdsqs15xpHmyebb7G / Jh5jwXDItBCbLHG4rjFM5Yhi83KZVWyTrP6LE0tIy0Vllss2ywHrOytkqwWWe21umdNtfaxzrReY91q3WdjYTPBZo5Nvc3vthRbH1uR7Trbs7bv7OztUux + sGuye2pvZM + 1L7avt7 / rQHcIcsh3qHW45kh09HHMcdzg2O6EOnk6iZyqnS47o85ezmLnDc4dowijfEdJRtWOuulCc2G7FLrUuzwYzRwdPXrR6KbRL8bYjEkbs3LM2TFfXD1dc123ud5x03cb77bIrcXtlbuTO9 + 92v2aB90j3GO + R7PHy7HOY4VjN4695cnwnOD5g2er52cvby + ZV4NXj7eNd7p3jfdNHwOfOJ + lPud8Cb4hvvN9j / h + 8PPyK / Db7 / env4t / jv8u / 6fj7McJx20b1xVgFcAL2BLQGcgKTA / cHNgZZBnEC6oNehhsHSwI3h78hO3IzmbvZr8IcQ2RhRwKecfx48zlnAjFQiNCy0LbwvTDksKqwu6HW4VnhdeH90V4RsyOOBFJiIyKXBl5k2vG5XPruH3jvcfPHX86ihaVEFUV9TDaKVoW3TIBnTB + wuoJd2NsYyQxTbEglhu7OvZenH1cftwvE4kT4yZWT3wc7xY / J / 5sAiNhesKuhLeJIYnLE + 8kOSQpklqTdZKnJNclv0sJTVmV0jlpzKS5ky6mmqSKU5vTSGnJadvT + ieHTV47uXuK55TSKTem2k8tmnp + msm03GlHp + tM500 / kE5IT0nflf6JF8ur5fVncDNqMvr4HP46 / nNBsGCNoEcYIFwlfJIZkLkq82lWQNbqrB5RkKhC1CvmiKvEL7Mjszdlv8uJzdmRM5ibkrs3j5yXnndYoi / JkZyeYT6jaEaH1FlaKu3M98tfm98ni5JtlyPyqfLmAgO4Yb + kcFB8r3hQGFhYXfh + ZvLMA0V6RZKiS7OcZi2Z9aQ4vPin2fhs / uzWOZZzFs55MJc9d8s8ZF7GvNb51vNL5ncviFiwcyF1Yc7C3xa5Llq16M13Kd + 1lJiVLCjp + j7i + /pS7VJZ6c0f/H / YtBhfLF7ctsRjyfolX8oEZRfKXcsryj8t5S + 98KPbj5U / Di7LXNa23Gv5xhXEFZIVN1YGrdy5Sm9V8aqu1RNWN65hrSlb82bt9LXnK8ZWbFpHXadY11kZXdm83mb9ivWfqkRV16tDqvfWmNYsqXm3QbDhysbgjQ2bzDaVb / q4Wbz51paILY21drUVW4lbC7c + 3pa87exPPj / VbTfZXr798w7Jjs6d8TtP13nX1e0y3bW8Hq1X1PfsnrK7fU / onuYGl4Yte5l7y / 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2QQw5xm2yyiU6bwowZMxJR+e2337pp06YlolL1WmuttdwKK6zQFPe5555zn332WdO1dh/23HPPdlG6ev+hhx5yJ5xwgnvnnXeSctxyyy3u/PPPd6prf8O///7rhg8f7saPH+922203N27cuKT9L7jggkbWX375pVtttdXc3XffnUzT33///d3RRx+dCPhGJE4qRSDWMIYOIlPlK9XcFBYCECgRgbz2VL7dPPPMk1nyMB+LWKRwj/H9fJ8Pv9RawyW+Gn7pHB7tzvBL2xHq7fux/mlXhbsE7SmnnJKrRSSc1llnHff222+722+/3UmEZ4WTTjqpIfIVR4b43nvvddOnT89Kklw/8cQT3YgRI5LzmLJZplZG+yxDft999yXi2675xx122MHttdde/iX3wQcfuJtuuimzfvvtt58bNWpUI82dd97pHnnkkcbnPCdXXHFFnmhdi6P20rT4KVOmJB0qxx57rNtyyy3dOeec0+8yvfDCC26nnXZy33zzTZLXM88848aMGdPU+XHllVcm79ijjz6axLnooouSNrz//vv7/Xwy6A6BWMMYOogI9+60G0+FAASqTyCvPVUHugYp9C9NwIf5GJkihXuM72c+H34pfqm9i3054pf2hdrcaaS59P1daqml3Lzzzjt3hJJeifVPKyXcv//+e6fRVz9oxFzBF+Wa9nzcccc1RtDTxK1Es0IoetWRoPQxxjvJaNZ/foeBXiCV1S+X4qm8Cy20kPv111+Toy/cNdKuzgM/qJyaVfDaa681Lvsj9Wl1a0RMOdGovYRw2cOTTz7pRo8enaxx32effdwNN9xQyFT133//3S255JLu3HPPbYy4ax27OFp46aWX3GabbZZM1dfGeBpx33XXXZM19xanrseXX37ZqUNDPcQHHHCAW3755fuMQh0k+k5vsMEGbvvtt8+Vj74LU6dOTfYeUBtp/4M8wQyjZrF8+OGHSWeeOogUNNNG7azvhtUndBCZKp+HMnEgAAEIzE0grz21znntK5Mm4MN87EndFO74pbNbAb/U3sb4I35pPDM/hXw6DaxJQ1nQzOvdd9+9z5tbd8M/tbIPGzbMTlOPpRLuZ511VmohdXHhhRdOemC11lhTcNTTucYaazR6ZdVg1157bUPg+kZEIlrpBGPbbbdtWs8cCmw19M477+x0XQa5VZCIuPTSS5MomsKuzdQsvP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';
// Remove 'Actuals' from the blacklist
Ext.override(Rally.ui.gridboard.plugin.GridBoardFieldPicker, {
    gridFieldBlackList: [
        // 'Actuals',
        'Changesets',
        'Children',
        // 'Description',
        // 'Notes',
        'ObjectID',
        'Predecessors',
        'RevisionHistory',
        'Subscription',
        'Successors',
        'TaskIndex',
        'Workspace',
        'VersionId'
    ]
});

/**
 * Remove the buffer when responding to 'viewstatesave' events
 */
Ext.override(Rally.ui.gridboard.SharedViewComboBox, {
    initComponent: function () {
        this.callParent(arguments);
        this.cmp.un('viewstatesave', this._onCmpViewStateSave, this);
        this.cmp.on('viewstatesave', this._onCmpViewStateSave, this);
    },
});

Ext.override(Rally.ui.cardboard.plugin.CardPopover, {
    showFeaturePredecessorsAndSuccessors: function () {
        return this._createPopover({
            field: 'PredecessorsAndSuccessors',
            title: 'Portfolio Item Dependencies',
            //width: 750,
            record: this.card.getFeature(this.card),
            offsetFromTarget: [{ x: 0, y: -8 }, { x: 15, y: 0 }, { x: 5, y: 15 }, { x: -15, y: 0 }],
            target: this.card.getEl()// .down('.field-content.FeaturePredecessorsAndSuccessors')
        });
    },

    showFeatureStoriesPredecessorsAndSuccessors: function () {
        var stories = this.card.getAllFeatureStories(this.card);
        return this._createPopover({
            field: 'FeatureStoriesDependenciesPopover',
            //width: 750,
            record: this.card.getRecord(),
            stories: stories,
            offsetFromTarget: [{ x: 0, y: -8 }, { x: 15, y: 0 }, { x: 5, y: 15 }, { x: -15, y: 0 }],
            target: this.card.getEl()// .down('.field-content.FeatureStoriesPredecessorsAndSuccessors')
        });
    }
});

Rally.ui.popover.PopoverFactory.popovers['FeatureStoriesDependenciesPopover'] = function (config) {
    return Ext.create('FeatureStoriesDependenciesPopover', this._getConfig(config));
};


// Would be nice if Checkboxes were stateful out of the box...
Ext.override(Ext.form.field.Checkbox, {
    getState: function () {
        return { checked: this.getValue() };
    },
    applyState: function (state) {
        if (typeof state.checked === 'boolean') {
            this.suspendEvents(false);
            this.setValue(state.checked);
            this.resumeEvents();
        }
    }
});
Ext.define('TsExportGrid', {

    extend: 'Ext.Component',

    getExportMenuItems: function () {
        var result = [];
        var models = [this.model];
        result = [{
            text: 'Export Portfolio Items...',
            handler: this._export,
            scope: this,
            childModels: models
        }, {
            text: 'Export Portfolio Items and User Stories...',
            handler: this._export,
            scope: this,
            childModels: models.concat(['hierarchicalrequirement'])
        }, {
            text: 'Export Portfolio Items, User Stories and Tasks...',
            handler: this._export,
            scope: this,
            childModels: models.concat(['hierarchicalrequirement', 'task'])
        }, {
            text: 'Export Portfolio Items and Child Items...',
            handler: this._export,
            scope: this,
            childModels: models.concat(['hierarchicalrequirement', 'task', 'defect', 'testcase'])
        }];

        return result;
    },

    _getGrid: function () {
        return Rally.getApp().down('#' + this.gridId);
    },

    _export: async function (args) {
        var columns = this._getExportColumns(),
            fetch = this._getExportFetch(),
            filters = await this._getExportFilters(),
            modelName = this.model,
            childModels = args.childModels,
            sorters = this._getExportSorters();

        var exporter = Ext.create('Rally.technicalservices.HierarchyExporter', {
            modelName: modelName,
            fileName: 'hierarchy-export.csv',
            columns: columns,
            portfolioItemTypeObjects: this.portfolioItemTypes

        });
        exporter.on('exportupdate', this._showStatus, this);
        exporter.on('exporterror', this._showError, this);
        exporter.on('exportcomplete', this._showStatus, this);

        var hierarchyLoader = Ext.create('Rally.technicalservices.HierarchyLoader', {
            model: modelName,
            fetch: fetch,
            filters: filters,
            sorters: sorters,
            loadChildModels: childModels,
            portfolioItemTypes: this.portfolioItemTypes,
            context: this.dataContext
        });
        hierarchyLoader.on('statusupdate', this._showStatus, this);
        hierarchyLoader.on('hierarchyloadartifactsloaded', exporter.setRecords, exporter);
        hierarchyLoader.on('hierarchyloadcomplete', exporter.export, exporter);
        hierarchyLoader.on('hierarchyloaderror', this._showError, this)
        hierarchyLoader.load();
    },
    _getExportColumns: function () {
        var grid = this._getGrid();
        if (grid) {
            let filteredColumns = [];
            let hasDependencies = false;

            _.each(grid.getGridOrBoard().columns, function (item) {
                // PredecessorsAndSuccessors column is generated via a template, not from
                // a specific WSAPI attribute. For exporting this data we have to split
                // this column back into 2 separate columns/data points
                if (item.dataIndex === 'PredecessorsAndSuccessors') {
                    hasDependencies = true;

                    let predCol = Ext.create('Rally.ui.grid.FieldColumn', {
                        dataIndex: 'Predecessors',
                        text: 'Predecessors'
                    });

                    let succCol = Ext.create('Rally.ui.grid.FieldColumn', {
                        dataIndex: 'Successors',
                        text: 'Successors'
                    });

                    filteredColumns.push(predCol);
                    filteredColumns.push(succCol);
                }
                else if (item.dataIndex &&
                    item.dataIndex != "DragAndDropRank" &&
                    item.xtype &&
                    item.xtype != "rallytreerankdraghandlecolumn" &&
                    item.xtype != "rallyrowactioncolumn" &&
                    item.text != "&#160;") {
                    filteredColumns.push(item);
                }
            });

            if (!hasDependencies) {
                let predCol = Ext.create('Rally.ui.grid.FieldColumn', {
                    dataIndex: 'Predecessors',
                    text: 'Predecessors'
                });

                let succCol = Ext.create('Rally.ui.grid.FieldColumn', {
                    dataIndex: 'Successors',
                    text: 'Successors'
                });

                filteredColumns.push(predCol);
                filteredColumns.push(succCol);
            }

            return filteredColumns;
        }
    },
    _getExportFilters: async function () {
        var app = Rally.getApp();
        var grid = this._getGrid(),
            filters = [],
            query = app.getSetting('query');

        if (grid.currentCustomFilter && grid.currentCustomFilter.filters) {
            // Concat any current custom filters (don't assign as we don't want to modify the currentCustomFilter array)
            filters = filters.concat(grid.currentCustomFilter.filters);
        }

        if (query) {
            filters.push(Rally.data.wsapi.Filter.fromQueryString(query));
        }

        let ancestorAndMultiFilters = await Rally.getApp()._getAncestorAndMultiFilters();

        if (ancestorAndMultiFilters) {
            filters = filters.concat(ancestorAndMultiFilters);
        }

        var timeboxScope = this.context.getTimeboxScope();
        if (timeboxScope && timeboxScope.isApplicable(grid.getGridOrBoard().store.model)) {
            filters.push(timeboxScope.getQueryFilter());
        }

        let depFilter = app.down('#dependencyFilterBtn');

        if (depFilter) {
            filters = filters.concat(depFilter.getFilters());
        }

        return filters;
    },
    _getExportFetch: function () {
        var fetch = _.pluck(this._getExportColumns(), 'dataIndex');
        if (Ext.Array.contains(fetch, 'TaskActualTotal')) {
            fetch.push('Actuals');
        }

        if (!Ext.Array.contains(fetch, 'PredecessorsAndSuccessors')) {
            fetch.push('PredecessorsAndSuccessors');
        }

        return fetch;
    },
    _getExportSorters: function () {
        var grid = this._getGrid();
        if (grid) {
            return grid.getGridOrBoard().getStore().getSorters();
        }
    },

    _showError: function (msg) {
        Rally.ui.notify.Notifier.showError({ message: msg });
    },
    _showStatus: function (message) {
        if (message) {
            Rally.ui.notify.Notifier.showStatus({
                message: message,
                showForever: true,
                closable: false,
                animateShowHide: false
            });
        }
        else {
            Rally.ui.notify.Notifier.hide();
        }
    },
});

Ext.define('CustomAgile.ui.tutorial.ReleaseTrackingTutorial', {
    singleton: true,

    welcomeHtml: `
    <p>Program managers, product owners, engineering leads, and other organizers can track the status of teams and features in a common Program Increment (PI) via the release timebox from this app.</p>
    
    <p>Features that have been planned into the selected PI (release timebox) display on the left side of the page, which can be compared against a matrix of teams and iterations on the right.</p>

    <p>Change the release via the Release timebox picker at the top of this page.</p>
    `,

    steps: [
        {
            target: '#grid-area',
            title: 'Feature Grid',
            placement: 'right',
            html: `
            <p>This section lists all of the features that have been planned in the selected PI (release timebox). By default they are sorted by rank. Clicking and dragging the left-most side of a row allows you to re-rank features.</p>
            <p>Just above the grid is a series of buttons</p>
            <div>
                <p> <span role="presentation" class="x-btn-icon-el icon-add-column tutorial-example-btn">&nbsp;</span> Column picker: Select which fields you would like to see in the grid. These fields will also appear as columns when exported</p>
                <p> <span role="presentation" class="x-btn-icon-el icon-predecessor tutorial-example-btn">&nbsp;</span> Dependency Filter: Provides the ability to filter the below list of Features on those that have dependencies, those that have stories with dependencies or both</p>
                <p> <span role="presentation" class="x-btn-icon-el icon-export tutorial-example-btn">&nbsp;</span> Export: Exports the Features from the grid as well as the option to include any level of child artifacts</p>
            </div>
            <p>Only the Features showing on the current grid page will show data in the board. Increase the page size to show more data in the board.</p>
            `
        },
        {
            target: '#filter-area',
            placement: 'bottom',
            title: 'Filters',
            html: `
            <p>This section provides fine-tuning of the Features that will display in the grid.</p>
            <p>Filters can be applied at any level in the portfolio item hierarchy as well as to user stories. Scope can be set to the current project(s) or across the entire workspace (workspace scoping may cause longer load times or even timeouts).</p>
            <p>Additional filter help can be found by clicking on the help button in the top-right corner of the filters section.</p>
            `
        },
        {
            target: '#date-range-area',
            placement: 'right',
            title: 'Iterations',
            html: `
            <p>These 2 date inputs control which iterations show in the board.</p>
            <p>They are automatically populated using the selected PI (release timebox) start and end dates. Update the values to control which iterations are shown.</p>
            `
        },
        {
            target: '#card-controls-area',
            placement: 'left',
            title: 'Board Controls',
            html: `
            <p>Customize how the data is ogranized in the board.</p>
            <p>Card Type</p>
            <ul>
                <li>Features - In a Feature summary card, User Stories are rolled up to their parent Feature giving you an overview of how many Stories are assigned to each Iteration by Feature. Clicking on a card will provide a popup with more detailed story information.</li>
                <li>Stories - Each card represents a single User Story</li>
            </ul>
            <p>Swimlanes</p>
            <ul>
                <li>Project - Stories are grouped in horizontal swimlanes by Project</li>
                <li>Feature - Stories are grouped in horizontal swimlanes by Feature</li>
            </ul>
            `
        },
        {
            target: '#dependency-controls-area',
            placement: 'left',
            title: 'Dependencies',
            html: `
            <h4><span class="field-content FeatureStoriesPredecessorsAndSuccessors icon-children"></span> - Story to Story dependencies</h4>
            <h4><span class="field-content FeaturePredecessorsAndSuccessors icon-predecessor"></span> - Feature to Feature dependencies</h4>

            <h3>Show Story Dependency Lines</h3>

            <p>This setting will display lines between cards that have user story dependencies.</p>
            <p>Each line will connect to the predecessor on the right side of the card via a small circle and then
            to the successor on the left side of the card via a triangle.</p>

            <img src="${this.dependencyExample}" alt="Story Dependency Line Example" style="width:400px;display:block;margin-left:auto;margin-right:auto" />
            <br>
            
            Click on a card's story dependency icon(<span class="field-content FeatureStoriesPredecessorsAndSuccessors icon-children"></span>) 
            to view only lines for stories within that feature. An 'x' will replace the dependency icon allowing you to clear the 
            dependencies and reset the view.
            
            <br><br>
            
            <b>Note: Feature to feature dependency information can be viewed by clicking on this icon: </b><span class="field-content FeaturePredecessorsAndSuccessors icon-predecessor"></span>
            <br><br>However, Feature-Feature dependency lines cannot be drawn as this board is a view of stories by iteration and therefore Features are often displayed in the board multiple times each.
            
            <br><br>
            
            The colors indicate the following:
            <ul>
                <li><b><span style="color:grey;">Grey</span></b> - Successor is scheduled in an iteration after the predecessor</li>
                <li><b><span style="color:#FAD200;">Yellow</span></b> - Predecessor and successor are scheduled in the same iteration</li>
                <li><b><span style="color:#F66349;">Red</span></b> - Predecessor is scheduled in an iteration after the successor or the successor is scheduled in an iteration but it's predecessor is unscheduled</li>
                </ul>
            </ul>
            <br>
            Lines can be displayed or hidden by color using the provided color checkbox filters that appear after selecting the "Show Dependency Lines" option.
            <br>
            `
        }
    ],

    showWelcomeDialog: function (app) {
        this.app = app;

        this.welcomeDialog = Ext.create('Rally.ui.dialog.Dialog', {
            autoShow: true,
            layout: 'fit',
            componentCls: 'rly-popover dark-container',
            width: 500,
            height: 300,
            closable: true,
            autoDestroy: true,
            buttonAlign: 'center',
            autoScroll: true,
            title: 'Using the PI Tracking With Filters App',
            items: {
                xtype: 'component',
                html: this.welcomeHtml,
                padding: 10,
                style: 'font-size:12px;'
            },
            buttons: [
                {
                    xtype: "rallybutton",
                    text: 'Close',
                    cls: 'secondary rly-small',
                    listeners: {
                        click: () => {
                            this.welcomeDialog.close();
                        },
                        scope: this
                    }
                }, {
                    xtype: "rallybutton",
                    text: 'Next',
                    cls: 'primary rly-small',
                    listeners: {
                        click: function () {
                            this.showNextStep(0);
                            this.welcomeDialog.close();
                        },
                        scope: this
                    }
                }
            ]
        });
    },

    showNextStep: function (stepIndex) {
        if (this.popover) {
            Ext.destroy(this.popover);
        }

        if (stepIndex >= this.steps.length) {
            return;
        }

        let currentStep = this.steps[stepIndex];

        let buttons = [{
            xtype: "rallybutton",
            text: 'Close',
            cls: 'secondary rly-small',
            listeners: {
                click: () => {
                    this.popover.close();
                },
                scope: this
            }
        }];

        if (stepIndex < this.steps.length - 1) {
            buttons.push({
                xtype: "rallybutton",
                text: 'Next',
                cls: 'primary rly-small',
                listeners: {
                    click: function () {
                        this.showNextStep(stepIndex + 1);
                    },
                    scope: this
                }
            });
        }

        this.popover = Ext.create('Rally.ui.popover.Popover', {
            target: this.app.down(currentStep.target).getEl(),
            placement: currentStep.placement || ['bottom', 'left', 'top', 'right'],
            overflowY: 'auto',
            maxWidth: 700,
            maxHeight: 700,
            toFront: Ext.emptyFn,
            buttonAlign: 'center',
            title: currentStep.title,
            listeners: {
                destroy: function () {
                    this.popover = null;
                },
                scope: this
            },
            html: `<div class="tutorial-popover-body">${currentStep.html}</div>`,
            buttons
        });
    }

});
/* global Ext _ Rally Constants Deft Utils */
Ext.define("release-tracking-with-filters", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    layout: 'border',
    integrationHeaders: {
        name: "release-tracking-with-filters"
    },
    items: [{
        id: 'filter-area',
        region: 'north',
        xtype: 'panel',
        minHeight: 250,
        overflowY: 'auto',
        collapsible: true,
        margins: '0 0 10 0',
        header: {
            cls: 'ts-panel-header',
            padding: '0 0 15 0'
        },
        cls: 'grid-area',
        title: 'FILTERS',
        layout: {
            type: 'vbox',
            align: 'stretch'
        },
        items: [{
            id: Utils.AncestorPiAppFilter.RENDER_AREA_ID,
            xtype: 'container',
            layout: {
                type: 'hbox',
                align: 'middle',
                defaultMargins: 5,
            }
        }, {
            id: 'sharedViewsContainer',
            xtype: 'container',
            layout: {
                type: 'hbox',
                align: 'middle',
                defaultMargins: 5,
            }
        }, {
            id: Utils.AncestorPiAppFilter.PANEL_RENDER_AREA_ID,
            xtype: 'container',
            layout: {
                type: 'hbox',
                align: 'middle',
                defaultMargins: 5,
            }
        }]
    }, {
        id: 'left-area',
        region: 'west',
        xtype: 'panel',
        split: true,
        header: {
            cls: 'ts-panel-header',
            padding: '0 0 15 0'
        },
        cls: 'grid-area',
        title: Constants.PORTFOLIO_ITEMS,
        flex: 1,
        layout: {
            type: 'vbox',
            align: 'stretch'
        },
        items: [{
            id: 'grid-area',
            xtype: 'container',
            flex: 1,
            layout: {
                type: 'vbox',
                align: 'stretch'
            },
        }]
    },
    {
        id: 'right-area',
        region: 'center',
        xtype: 'container',
        flex: 2,
        type: 'vbox',
        align: 'stretch',
        overflowX: 'auto',
        overflowY: 'auto',
        items: [{
            id: 'controls-area',
            xtype: 'container',
            layout: 'hbox',
            minWidth: 700,
            minHeight: 100,
            margin: '0 0 10 20',
            items: [{
                id: 'date-range-area',
                xtype: 'container',
                layout: 'vbox'
            }, {
                id: 'card-controls-area',
                xtype: 'container',
                layout: 'vbox',
                margin: '0 0 0 30',
            }, {
                id: 'dependency-controls-area',
                xtype: 'container',
                layout: 'vbox',
                margin: '0 0 0 30',
            }]
        }, {
            id: 'board-area',
            xtype: 'container',
            flex: 1,
            type: 'vbox',
            align: 'stretch',
            margin: '0 0 0 20'
        }]
    }
    ],
    config: {
        defaultSettings: {
            // 'ReleaseTrackingWithFilters.dependencyLines': 'noDependencyLines'
        },
    },

    launch: function () {
        Rally.data.wsapi.Proxy.superclass.timeout = 120000;
        Ext.tip.QuickTipManager.init();
        Ext.apply(Ext.tip.QuickTipManager.getQuickTip(), { showDelay: 50 });

        Ext.override(Rally.ui.cardboard.CardBoard, {
            getCards: function () {
                let cards = [];
                _.each(this.columnDefinitions, function (column) {
                    cards = cards.concat(column.getCards());
                });
                return cards;
            }
        });

        this.down('#right-area').on('resize', this.onCardboardResize, this);
        this.down('#controls-area').add({
            xtype: 'rallybutton',
            cls: 'customagile-button help',
            iconOnly: true,
            iconCls: 'icon-help',
            handler: (...args) => this.onHelpClicked(...args),
            id: 'storyDependencyHelp',
            margin: '0 0 0 5'
        });

        this.down('#date-range-area').add([
            {
                xtype: 'container',
                html: 'ITERATIONS',
                cls: 'date-label control-label'
            },
            {
                xtype: 'rallydatefield',
                id: 'start-date-picker',
                fieldLabel: Constants.START_DATE,
                labelWidth: 50,
                labelCls: 'date-label',
                width: 180,
                margin: '0 10 5 0',
                listeners: {
                    scope: this,
                    change: function (cmp, newValue) {
                        this.timeboxStart = newValue;
                        this._update();
                    }
                }
            }, {
                xtype: 'rallydatefield',
                id: 'end-date-picker',
                fieldLabel: Constants.END_DATE,
                labelWidth: 50,
                width: 180,
                labelCls: 'date-label',
                margin: '0 10 0 0',
                listeners: {
                    scope: this,
                    change: function (cmp, newValue) {
                        this.timeboxEnd = newValue;
                        this._update();
                    }
                }
            }]);

        this.down('#card-controls-area').add([{
            xtype: 'container',
            html: 'BOARD',
            cls: 'date-label control-label'
        }, {
            itemId: 'cardTypeCombo',
            xtype: 'rallycombobox',
            stateful: true,
            stateId: this.context.getScopedStateId('ReleaseTrackingWithFilters.CardTypeCombo'),
            stateEvents: ['change'],
            fieldLabel: 'Card Type',
            displayField: 'name',
            valueField: 'value',
            editable: false,
            allowBlank: false,
            labelWidth: 65,
            width: 200,
            margin: '0 5 5 0',
            store: Ext.create('Ext.data.Store', {
                fields: ['name', 'value'],
                data: [
                    { name: 'Features', value: 'Features' },
                    { name: 'Stories', value: 'Stories' }
                ]
            }),
            listeners: {
                scope: this,
                change: function () {
                    if (this.storiesFilter && this.currentIterations) {
                        this._addPisBoard(this.storiesFilter, this.currentIterations).then({
                            scope: this,
                            success: this.onAddPisBoardSuccess
                        });
                    }
                }
            }
        }, {
            itemId: 'swimlaneCombo',
            xtype: 'rallycombobox',
            stateful: true,
            stateId: this.context.getScopedStateId('ReleaseTrackingWithFilters.SwimlaneCombo'),
            stateEvents: ['change'],
            fieldLabel: 'Swimlanes',
            displayField: 'name',
            valueField: 'value',
            editable: false,
            allowBlank: false,
            labelWidth: 65,
            width: 200,
            margin: '0 5 0 0',
            store: Ext.create('Ext.data.Store', {
                fields: ['name', 'value'],
                data: [
                    { name: 'Project', value: 'Project' },
                    { name: 'Feature', value: 'Feature' }
                ]
            }),
            listeners: {
                scope: this,
                change: function () {
                    if (this.storiesFilter && this.currentIterations) {
                        this._addPisBoard(this.storiesFilter, this.currentIterations).then({
                            scope: this,
                            success: this.onAddPisBoardSuccess
                        });
                    }
                }
            }
        }]);

        this.down('#dependency-controls-area').add([{
            xtype: 'container',
            layout: 'hbox',
            items: [{
                xtype: 'container',
                html: 'DEPENDENCIES',
                cls: 'date-label control-label'
            }]
        },
        {
            xtype: 'checkbox',
            stateful: true,
            stateId: this.context.getScopedStateId('ReleaseTrackingWithFilters.ShowOnlyStoriesWithDependenciesCheckbox'),
            stateEvents: ['change'],
            boxLabel: 'Only show Stories w/ Dependencies',
            boxLabelCls: 'dependency-label',
            labelWidth: 255,
            //labelAlign: 'right',
            width: 275,
            name: 'onlyStoriesWithDependencies',
            inputValue: true,
            itemId: 'onlyStoriesWithDependenciesCheckbox',
            cls: 'dependency-checkbox',
            margin: '0 3 3 0',
            listeners: {
                scope: this,
                change: function (cmp, showLines) {
                    if (this.previousCancelIcon) {
                        this.previousDepIcon.setStyle('display', 'inline');
                        this.previousCancelIcon.setStyle('display', 'none');
                        this.previousDepIcon = null;
                        this.previousCancelIcon = null;
                    }

                    this.removeDependencyLines();
                    this._update();
                }
            }
        }, {
            xtype: 'checkbox',
            stateful: true,
            stateId: this.context.getScopedStateId('ReleaseTrackingWithFilters.ShowDependenciesCheckbox'),
            stateEvents: ['change'],
            boxLabel: 'Show Story Dependency Lines (<span class="field-content FeatureStoriesPredecessorsAndSuccessors icon-children"></span>)',
            boxLabelCls: 'dependency-label',
            labelWidth: 255,
            width: 275,
            name: 'dependencies',
            inputValue: true,
            itemId: 'storyDependencyCheckbox',
            cls: 'dependency-checkbox',
            margin: '0 3 3 0',
            listeners: {
                scope: this,
                change: function (cmp, showLines) {
                    if (this.previousCancelIcon) {
                        this.previousDepIcon.setStyle('display', 'inline');
                        this.previousCancelIcon.setStyle('display', 'none');
                        this.previousDepIcon = null;
                        this.previousCancelIcon = null;
                    }

                    this.removeDependencyLines();

                    if (showLines) {
                        this.down('#dependencyFiltersContainer').show();
                        this.showAllStoryDependencyLines();
                    } else {
                        this.down('#dependencyFiltersContainer').hide();
                    }
                }
            }
        }, {
            xtype: 'fieldcontainer',
            itemId: 'dependencyFiltersContainer',
            hidden: true,
            fieldLabel: 'Filters:',
            labelWidth: 50,
            defaultType: 'checkboxfield',
            layout: 'hbox',
            width: 300,
            fieldDefaults: {
                name: 'lineFilter',
                labelSeparator: '',
                margin: '-2 10 0 0'
            },
            items: [
                {
                    fieldLabel: 'Grey',
                    id: 'greyLineFilter',
                    stateful: true,
                    stateId: this.context.getScopedStateId('ReleaseTrackingWithFilters.ShowGreyDependenciesCheckbox'),
                    stateEvents: ['change'],
                    width: 56,
                    labelWidth: 28,
                    checked: true,
                    margin: '-2 8 0 0',
                    listeners: {
                        scope: this,
                        change: this.showAllStoryDependencyLines
                    }
                }, {
                    fieldLabel: 'Yellow',
                    id: 'yellowLineFilter',
                    stateful: true,
                    stateId: this.context.getScopedStateId('ReleaseTrackingWithFilters.ShowYellowDependenciesCheckbox'),
                    stateEvents: ['change'],
                    width: 60,
                    labelWidth: 35,
                    checked: true,
                    listeners: {
                        scope: this,
                        change: this.showAllStoryDependencyLines
                    }
                }, {
                    fieldLabel: 'Red',
                    id: 'redLineFilter',
                    stateful: true,
                    stateId: this.context.getScopedStateId('ReleaseTrackingWithFilters.ShowRedDependenciesCheckbox'),
                    stateEvents: ['change'],
                    width: 60,
                    labelWidth: 26,
                    checked: true,
                    listeners: {
                        scope: this,
                        change: this.showAllStoryDependencyLines
                    }
                }
            ]
        }]);

        let timeboxScope = this.getContext().getTimeboxScope();
        this._onTimeboxScopeChange(timeboxScope);

        this.ancestorFilterPlugin = Ext.create('Utils.AncestorPiAppFilter', {
            ptype: 'UtilsAncestorPiAppFilter',
            pluginId: 'ancestorFilterPlugin',
            visibleTab: 'PortfolioItem/Feature',
            listeners: {
                scope: this,
                ready(plugin) {
                    plugin.addListener({
                        scope: this,
                        select: this._update,
                        change: this._update
                    });
                    this.portfolioItemTypes = plugin.portfolioItemTypes;
                    this.lowestPi = this.portfolioItemTypes[0];
                    this.lowestPiTypePath = this.lowestPi.get('TypePath');
                    this.lowestPiTypeName = this.lowestPi.get('Name');
                    this.modelNames = [this.lowestPiTypePath];
                    Rally.data.wsapi.ModelFactory.getModel({
                        type: this.lowestPiTypePath
                    }).then({
                        scope: this,
                        success: async function (model) {
                            this.lowestPiModel = model;
                            await this._addSharedViewsCombo();
                            this._update();
                        }
                    });
                },
            }
        });

        this.down('#grid-area').on('resize', this._onResize, this);
        this.down('#controls-area').on('resize', this._onResize, this);
        this.down('#filter-area').on('collapse', this._onResize, this);
        this.down('#filter-area').on('expand', this._onResize, this);

        this.addPlugin(this.ancestorFilterPlugin);
    },

    _addSharedViewsCombo: function () {
        return new Promise(function (resolve) {
            this.down('#sharedViewsContainer').add([
                {
                    xtype: 'rallysharedviewcombobox',
                    title: 'Shared Views',
                    itemId: 'releaseTrackingSharedViewCombobox',
                    enableUrlSharing: true,
                    context: this.getContext(),
                    cmp: this,
                    listeners: {
                        ready: function (combo) {
                            combo.setValue(null);
                            resolve();
                        }
                    }
                }
            ]);
        }.bind(this));
    },

    getCurrentView: function () {
        let ancestorData = Rally.getApp().ancestorFilterPlugin._getValue();

        // Delete piRecord to avoid recursive stack overflow error
        delete ancestorData.piRecord;

        let gridView = this.down('#pisGrid').getCurrentView();
        let views = Ext.apply(gridView, ancestorData);

        views.featuresWithDependencies = this.dependencyFilterBtn.getFeaturesWithDependenciesValue();
        views.featuresWithStoryDependencies = this.dependencyFilterBtn.getFeaturesWithStoryDependenciesValue();
        views.dependencyFilterMatch = this.dependencyFilterBtn.getFilterMatchValue();
        views.cardType = this.down('#cardTypeCombo').getValue();
        views.swimlane = this.down('#swimlaneCombo').getValue();
        views.onlyStoriesWithDependencies = this.down('#onlyStoriesWithDependenciesCheckbox').getValue();
        views.storyDependencyLines = this.down('#storyDependencyCheckbox').getValue();
        views.greyLineFilter = this.down('#greyLineFilter').getValue();
        views.yellowLineFilter = this.down('#yellowLineFilter').getValue();
        views.redLineFilter = this.down('#redLineFilter').getValue();

        return views;
    },

    setCurrentView: function (view) {
        let app = Rally.getApp();
        this.setLoading('Loading View...');
        Ext.suspendLayouts();
        app.settingView = true;
        if (app.ancestorFilterPlugin) {
            if (view.filterStates) {
                app.ancestorFilterPlugin.mergeLegacyFilter(view.filterStates, view, app.lowestPiTypePath);
            }
            if (app.ancestorFilterPlugin.renderArea.down('#ignoreScopeControl')) {
                app.ancestorFilterPlugin.renderArea.down('#ignoreScopeControl').setValue(view.ignoreProjectScope);
            }
            app.ancestorFilterPlugin.setMultiLevelFilterStates(view.filterStates);
            app.ancestorFilterPlugin._setPiSelector(view.piTypePath, view.pi);
        }
        this.down('#pisGrid').setCurrentView(view);

        this.dependencyFilterBtn.updateValues({
            filterFeatures: view.featuresWithDependencies,
            filterStories: view.featuresWithStoryDependencies,
            filterMatch: view.dependencyFilterMatch
        });
        this.dependencyFilterBtn.saveState();

        this.down('#cardTypeCombo').setValue(view.cardType);
        this.down('#swimlaneCombo').setValue(view.swimlane);
        this.down('#onlyStoriesWithDependenciesCheckbox').setValue(view.onlyStoriesWithDependencies);
        this.down('#storyDependencyCheckbox').setValue(view.storyDependencyLines);
        this.down('#greyLineFilter').setValue(view.greyLineFilter);
        this.down('#yellowLineFilter').setValue(view.yellowLineFilter);
        this.down('#redLineFilter').setValue(view.redLineFilter);

        setTimeout(async function () {
            Ext.resumeLayouts(true);
            app.settingView = false;
            app.dontResetSharedViewCombo = true;
            this.setLoading(false);
            app._update();
        }.bind(this), 2000);
    },

    _update: async function () {
        if (this.settingView) {
            return;
        }

        let gridArea = this.down('#grid-area');
        if (gridArea) {
            gridArea.removeAll();
        }
        if (!this.dontResetSharedViewCombo && this.down('#releaseTrackingSharedViewCombobox')) {
            this.down('#releaseTrackingSharedViewCombobox').setValue(null);
        }
        this.dontResetSharedViewCombo = false;
        this.setLoading(true);
        this.dependencyFilterBtn = Ext.create('CustomAgile.ui.gridboard.DependencyFilter', {
            // headerPosition: 'left',
            margin: '0 9 0 9',
            itemId: 'dependencyFilterBtn',
            stateful: true,
            stateId: this.getContext().getScopedStateId('ReleaseTrackingWithFilters.dependencyfilter'),
            listeners: {
                scope: this,
                dependencyfilterchange: this._dependencyfilterchange,
                dependencyfilterstateapplied: this._dependencyfilterstateapplied
            }
        });

        this.currentIterations = await this._updateIterationsStore();
        await this._updatePisStore();

        if (!this.loadingFailed) {
            this._addPisGrid(this.piStore);
        } else {
            this.setLoading(false);
        }
    },

    _onResize: function () {
        // Hiding one of the advanced filters throws an error once this method is 
        // called and we try to set the grid height. Waiting a bit first solves this
        setTimeout(function () {
            // this.is_a_nightmare() === true
            let gridArea = this.down('#grid-area');
            let grid = this.down('#pisGrid');

            if (gridArea && grid) {
                grid.setHeight(gridArea.getHeight());
            }

            let boardArea = this.down('#board-area');
            let rightArea = this.down('#right-area');
            let controlsArea = this.down('#controls-area');
            let board = this.down('#releaseCardboard');

            if (rightArea && controlsArea && boardArea && board) {
                boardArea.setHeight(rightArea.getHeight() - ((controlsArea.getOuterSize() && controlsArea.getOuterSize().height) || 0));
                board.setHeight(boardArea.getHeight() - 20);
                boardArea.setWidth(rightArea.getWidth() - 20);
            }
        }.bind(this), 500);
    },

    _updatePisStore: async function () {
        this.loadingFailed = false;
        this.currentDataContext = this.getContext().getDataContext();
        if (this.searchAllProjects()) {
            this.currentDataContext.project = null;
        }

        this.currentPiQueries = await this._getPiQueries();

        if (this.loadingFailed) {
            return;
        }

        this.piStore = await Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: [this.lowestPiTypePath],
            autoLoad: false,
            fetch: true, // This solves the issue with the field picker loading new columns with no data in them
            filters: this.currentPiQueries,
            enableHierarchy: true,
            remoteSort: true,
            context: this.currentDataContext,
            enablePostGet: true,
            enableRootLevelPostGet: true,
            clearOnLoad: false

        });
    },

    _getPiQueries: async function () {
        let queries = [];

        switch (this.timeboxType) {
            case 'release':
                queries.push({
                    property: 'Release',
                    value: this.timebox ? this.timebox.get('_ref') : null
                });
                break;
            case 'iteration':
                if (this.timebox) {
                    queries.push({
                        property: 'UserStories.Iteration.Name',
                        value: this.timebox.get('Name')
                    });
                    queries.push({
                        property: 'UserStories.Iteration.StartDate',
                        value: this.timebox.get('StartDate')
                    });
                    queries.push({
                        property: 'UserStories.Iteration.EndDate',
                        value: this.timebox.get('EndDate')
                    });
                }
                else {
                    queries.push({
                        property: 'UserStories.Iteration',
                        value: null
                    });
                }
                break;
            case 'milestone':
                queries.push({
                    property: 'Milestones.ObjectID',
                    value: this.timebox ? this.timebox.get('ObjectID') : null
                });
                break;
            default:
                break;
        }

        let filters = await this._getAncestorAndMultiFilters();
        if (filters) {
            queries = queries.concat(filters);
        }

        if (this.getSetting('query')) {
            queries = queries.concat(Rally.data.QueryFilter.fromQueryString(this.getSetting('query')));
        }

        if (this.featureDependencyFilters) {
            queries = queries.concat(this.featureDependencyFilters);
        }

        return queries;
    },

    _updateIterationsStore: async function () {
        let filter = Rally.data.wsapi.Filter.and([{
            property: 'EndDate',
            operator: '>=',
            value: this.timeboxStart
        }, {
            property: 'StartDate',
            operator: '<=',
            value: this.timeboxEnd
        }]);
        this.iterationsStore = Ext.create('Rally.data.wsapi.Store', {
            model: 'Iteration',
            fetch: ['Name', 'StartDate', 'EndDate'],
            autoLoad: false,
            filters: filter,
            context: this.getContext().getDataContext(),
            pageSize: 4000
        });
        let iterations = await this.iterationsStore.load();
        return iterations;
    },

    _getAncestorAndMultiFilters: async function () {
        let filters = [];
        if (this.ancestorFilterPlugin) {
            filters = await this.ancestorFilterPlugin.getAllFiltersForType(this.lowestPiTypePath, true).catch((e) => {
                Rally.ui.notify.Notifier.showError({ message: (e.message || e) });
                this.loadingFailed = true;
            });
        }
        return filters;
    },

    _getDefects: function () {
        // TODO (tj) needed?
    },

    _addPisGrid: function (store) {
        let gridArea = this.down('#grid-area');
        let currentModelName = this.modelNames[0];
        let allProjectsContext = this.getContext().getDataContext();
        allProjectsContext.project = null;
        let gridExporter = Ext.create('TsExportGrid', {
            model: this.lowestPiTypePath,
            gridId: 'pisGrid',
            context: this.getContext(),
            dataContext: this.currentDataContext,
            portfolioItemTypes: this.portfolioItemTypes,
        });
        this.grid = gridArea.add({
            xtype: 'rallygridboard',
            id: 'pisGrid',
            context: this.getContext(),
            modelNames: this.modelNames,
            toggleState: 'grid',
            height: gridArea.getHeight(),
            listeners: {
                scope: this,
                viewchange: this._update,
                load: function (grid) {
                    this._onGridLoad(grid);
                }
            },
            plugins: [{
                ptype: 'rallygridboardinlinefiltercontrol',
                inlineFilterButtonConfig: {
                    stateful: true,
                    stateId: this.getContext().getScopedStateId('CA.releaseTrackingWithFiltersNewFilters'),
                    hidden: true,
                    modelNames: this.modelNames,
                    inlineFilterPanelConfig: {
                        quickFilterPanelConfig: {
                            dataContext: allProjectsContext,
                            portfolioItemTypes: this.portfolioItemTypes,
                            modelName: this.lowestPiTypePath,
                            whiteListFields: ['Tags', 'Milestones', 'c_EnterpriseApprovalEA', 'c_EAEpic']
                        }
                    }
                }
            },
            {
                ptype: 'rallygridboardfieldpicker',
                headerPosition: 'left',
                margin: '0 9 0 9',
                modelNames: this.modelNames,
                stateful: true,
                stateId: this.getModelScopedStateId(currentModelName, 'fields'),
            },
            {
                ptype: 'rallygridboardactionsmenu',
                menuItems: gridExporter.getExportMenuItems(),
                buttonConfig: {
                    iconCls: 'icon-export'
                }
            },
            ],
            gridConfig: {
                shouldShowRowActionsColumn: false,
                enableBulkEdit: false,
                enableEditing: false,
                enableColumnMove: false,
                enableInlineAdd: false,
                enableRanking: true,
                store: store,
                storeConfig: {
                    context: this.currentDataContext,
                    filters: this.currentPiQueries,
                    fetch: true,
                    enablePostGet: true,
                    pageSize: 2000,
                    limit: Infinity
                },
                columnCfgs: [{
                    dataIndex: 'FormattedID',
                    text: 'ID'
                }, {
                    dataIndex: 'Name',
                    text: 'Name'
                }],
                listeners: {
                    scope: this,
                    // TODO (tj) support multi item selection
                    /*
                    itemclick: function(grid, record, item, index) {
                        // Ignore clicks on non root items
                        if (record.get('_type') == this.lowestPiTypePath.toLowerCase()) {
                            this._onPiSelected(record);
                        }
                    }
                    */
                }
            }
        });
    },

    _onGridLoad: function (grid) {
        let store = grid.getGridOrBoard().getStore();
        let root = store.getRootNode();

        if (grid.down('rallyleftright')) {
            grid.down('rallyleftright').insert(1, this.dependencyFilterBtn);
        }
        else {
            grid.insert(0, this.dependencyFilterBtn);
        }

        if (root.childNodes && root.childNodes.length) {
            let oids = _.map(root.childNodes, function (pi) {
                return pi.get('ObjectID');
            }, this).join(',');

            // Performance may be better by using 'in' instead of a collection of ORs
            let query = Ext.create('Rally.data.wsapi.Filter', {
                property: this.lowestPiTypeName + '.ObjectID',
                operator: 'in',
                value: oids
            });

            this.storiesFilter = query;
        }
        else {
            // If there are no PIs, then explicitly filter out all stories
            this.storiesFilter = Rally.data.wsapi.Filter.and({
                property: 'ObjectID',
                value: 0
            });
        }

        // Only consider direct Feature children (not nested stories)
        this.storiesFilter = this.storiesFilter.and({
            property: 'Parent',
            value: null
        });

        if (this.down('#onlyStoriesWithDependenciesCheckbox').getValue()) {
            let storyDepQuery = Ext.create('Rally.data.wsapi.Filter', {
                property: 'Predecessors.ObjectID',
                operator: '!=',
                value: null
            });

            storyDepQuery = storyDepQuery.or(Ext.create('Rally.data.wsapi.Filter', {
                property: 'Successors.ObjectID',
                operator: '!=',
                value: null
            }));

            this.storiesFilter = this.storiesFilter.and(storyDepQuery);
        }

        let boardPromise = this._addPisBoard(this.storiesFilter, this.currentIterations).then({
            scope: this,
            success: this.onAddPisBoardSuccess
        });
        return boardPromise;
    },

    onAddPisBoardSuccess: function (board) {
        if (this.down('#cardTypeCombo').getValue() === 'Stories') {
            this.buckets = {};
            let cards = board.getCards();
            for (let c of cards) {
                this.buckets[c.getRecord().get('ObjectID')] = c;
            }
        }

        for (let def of board.rowDefinitions) {
            def.on('collapse', this.onCardboardResize, this);
            def.on('expand', this.onCardboardResize, this);
        }

        if (this._shouldShowStoryDependencies()) {
            this.down('#dependencyFiltersContainer').show();
            this.showAllStoryDependencyLines();
        }
        else {
            this.setLoading(false);
        }

        this._onResize();
    },

    _onPiSelected: function (pi) {
        let filter;
        if (this.selectedPi === pi) {
            // Unselecting the pi
            filter = this.storiesFilter;
            delete this.selectedPi;
        }
        else {
            this.selectedPi = pi;
            filter = Rally.data.wsapi.Filter({
                property: this.lowestPiTypeName,
                operator: '=',
                value: pi.get('_ref')
            });
        }
        this.buckets = {};
        this.board.refresh({
            storeConfig: {
                filters: filter,
                enablePostGet: true,
                pageSize: 2000,
                limit: Infinity
            }
        });
    },

    _addPisBoard: function (filter, iterations) {
        let boardDeferred = Ext.create('Deft.Deferred');
        let boardArea = this.down('#board-area');
        boardArea.removeAll();

        this.buckets = {};

        // Create a column for each iteration shared by the projects
        let endDateSorted = _.sortBy(iterations, function (i) {
            return i.get('EndDate');
        });
        let uniqueIterations = _.unique(endDateSorted, function (i) {
            return this._getIterationKey(i);
        }, this);

        let columns = _.map(uniqueIterations, function (iteration) {
            let startDate = iteration.get('StartDate').toLocaleDateString();
            let endDate = iteration.get('EndDate').toLocaleDateString();
            let headerTemplate = new Ext.XTemplate('<div class="iteration-name">{name}</div><div class="iteration-dates">{start} - {end}</dev>').apply({
                name: iteration.get('Name'),
                start: startDate,
                end: endDate
            });
            return {
                xtype: 'rallycardboardcolumn',
                columnHeaderConfig: {
                    headerTpl: headerTemplate,
                    cls: 'cardboard-column-header'
                },
                fields: [this.lowestPiTypeName],
                value: iteration.get('_ref'), // AM TODO, needed to add this, but will it affect dragging and dropping cards?
                additionalFetchFields: Constants.STORIES_FETCH,
                getStoreFilter: function () {
                    // Don't return this column 'value' as a filter
                    return [{
                        property: 'Iteration.StartDate',
                        value: iteration.get('StartDate')
                    },
                    {
                        property: 'Iteration.EndDate',
                        value: iteration.get('EndDate')
                    }
                    ];
                },
                isMatchingRecord: function () {
                    return true;
                }
            };
        }, this);
        // Add a column for unscheduled stories
        columns.push({
            xtype: 'rallycardboardcolumn',
            value: null,
            columnHeaderConfig: {
                headerTpl: Constants.UNSCHEDULED
            },
            fields: [this.lowestPiTypeName],
            additionalFetchFields: Constants.STORIES_FETCH
        });

        this.board = boardArea.add({
            xtype: 'rallycardboard',
            height: this.down('#board-area').getHeight(),
            itemId: 'releaseCardboard',
            type: ['HierarchicalRequirement'],
            plugins: [{ ptype: 'rallyfixedheadercardboard' }],
            attribute: 'Iteration',
            overflowY: 'hidden',
            storeConfig: {
                filters: filter,
                fetch: [this.lowestPiTypeName].concat(Constants.STORIES_FETCH),
                groupField: this.lowestPiTypeName,
                context: this.currentDataContext,
                enablePostGet: true,
                pageSize: 2000,
                limit: Infinity
            },
            listeners: {
                scope: this,
                load: function (board) {
                    boardDeferred.resolve(board);
                }
            },
            rowConfig: {
                field: this.down('#swimlaneCombo').getValue() || 'Project',
                sortField: this.down('#swimlaneCombo').getValue() === 'Feature' ? 'DragAndDropRank' : null,
                enableCrossRowDragging: false
            },
            columns: columns,
            cardConfig: this.getCardConfig()
        });
        return boardDeferred.promise;
    },

    getCardConfig: function () {
        if (this.down('#cardTypeCombo').getValue() === 'Stories') {
            return {
                fields: ['Feature', 'Project', 'PredecessorsAndSuccessors']
            };
            // let config = {};
            // if (this.down('#swimlaneCombo').getValue() === 'Project') {
            //     config.fields = ['Feature'];
            // }
            // else {
            //     config.fields = ['Project'];
            // }
            // return config;
        }

        return {
            xtype: 'storyfeaturecard',
            lowestPiTypeName: this.lowestPiTypeName,
            draggable: false,
            isHiddenFunc: this._isCardHidden.bind(this),
            getFeature: function (card) {
                let story = card.getRecord();
                let featureRef = story.get(this.lowestPiTypeName);
                let feature = this.piStore.getById(featureRef);
                return feature;
            }.bind(this),
            getAllFeatureStories: function (card) {
                let cards = this._getCardsForCard(card);
                return _.map(cards, function (card) {
                    return card.getRecord();
                });
            }.bind(this),
            getVisibleCard: function (card) {
                let cards = this._getCardsForCard(card);
                return cards[0];
            }.bind(this),
            listeners: {
                scope: this,
                fieldclick: function (fieldName, card) {
                    let depIcon = card.el.down('.FeatureStoriesPredecessorsAndSuccessors');
                    let cancelIcon = card.el.down('.FeatureStoriesPredecessorsAndSuccessorsCancel');

                    if (fieldName === 'FeaturePredecessorsAndSuccessors') {
                        // Show feature to feature dependencies?
                    }
                    else if (fieldName === 'FeatureStoriesPredecessorsAndSuccessors') {
                        if (depIcon && cancelIcon) {
                            depIcon.setStyle('display', 'none');
                            cancelIcon.setStyle('display', 'inline');
                        }

                        if (this.previousDepIcon && this.previousDepIcon !== depIcon) {
                            this.previousDepIcon.setStyle('display', 'inline');
                            this.previousCancelIcon.setStyle('display', 'none');
                        }

                        this.showStoryDependencyLinesForCard(card);
                    }
                    else if (fieldName === 'FeatureStoriesPredecessorsAndSuccessorsCancel') {
                        if (depIcon && cancelIcon) {
                            depIcon.setStyle('display', 'inline');
                            cancelIcon.setStyle('display', 'none');
                        }

                        if (this.previousDepIcon && this.previousDepIcon !== depIcon) {
                            this.previousDepIcon.setStyle('display', 'inline');
                            this.previousCancelIcon.setStyle('display', 'none');
                        }

                        if (this._shouldShowStoryDependencies()) {
                            this.showAllStoryDependencyLines();
                        }
                        else {
                            this.removeDependencyLines();
                        }
                    }
                    this.previousDepIcon = depIcon;
                    this.previousCancelIcon = cancelIcon;
                },
                story: function (card) {
                    // TODO (tj) move into StoryFeatureCard
                    let story = card.getRecord();
                    let featureRef = story.get(this.lowestPiTypeName);
                    let feature = this.piStore.getById(featureRef);
                    let context = this.getContext().getDataContext();
                    context.project = story.get('Project')._ref;
                    let iteration = story.get('Iteration');
                    let filters = [];
                    if (iteration) {
                        filters = [{
                            property: 'Iteration.Name',
                            value: iteration.Name
                        }, {
                            property: 'Iteration.StartDate',
                            value: iteration.StartDate
                        }, {
                            property: 'Iteration.EndDate',
                            value: iteration.EndDate
                        }];
                    }
                    else {
                        filters = [{
                            property: 'Iteration',
                            value: null
                        }];
                    }
                    filters.push({
                        property: 'Project',
                        value: context.project
                    });
                    Rally.ui.popover.PopoverFactory.bake({
                        field: 'UserStory',
                        record: feature,
                        target: card.getEl(),
                        context: context,
                        // header: {
                        //     title: 'test'
                        // },
                        listViewConfig: {
                            gridConfig: {
                                storeConfig: {
                                    filters: filters,
                                    context: context,
                                    enablePostGet: true
                                },
                                columnCfgs: Constants.STORY_COLUMNS,
                            }
                        },
                        listeners: {
                            scope: this,
                            afterrender: function (popover) {
                                popover.down('rallyleftright').insert(0, Ext.create('Ext.container.Container', {
                                    cls: 'story-popover-feature-text',
                                    html: `<b>${popover.record.get('FormattedID')}:</b> ${popover.record.get('Name')}`
                                }))
                            }
                        }
                    });
                },
            }
        }
    },

    _dependencyfilterchange: function (filters) {
        this.featureDependencyFilters = filters;

        if (this.down('#pisGrid') && this.down('#pisGrid').getGridOrBoard()) {
            this._update();
        }
    },

    _dependencyfilterstateapplied: function (filters) {
        this.featureDependencyFilters = filters;
    },

    showAllStoryDependencyLines: function () {
        let def = Ext.create('Deft.Deferred');
        let board = this.down('#releaseCardboard');
        let isFeatureCards = this.down('#cardTypeCombo').getValue() === 'Features';

        if (board) {
            this.removeDependencyLines();

            this.setLoading('Drawing Dependencies');
            let cards = board.getCards();

            this.getAllStoryPredecessors(cards).then({
                scope: this,
                success: function (storyPredObjArray) {
                    if (storyPredObjArray.length) {
                        let lines = [];

                        _.each(storyPredObjArray, function (storyPredObj) {
                            let successorCard = isFeatureCards ? storyPredObj.card.getVisibleCard(storyPredObj.card) : storyPredObj.card;

                            _.each(storyPredObj.predecessors, function (pred) {
                                if (isFeatureCards) {
                                    let key = this._getRecordBucketKey(pred);
                                    if (this.buckets.hasOwnProperty(key)) {
                                        let predecessorCard = this.buckets[key][0];

                                        // Skip self-dependencies
                                        if (predecessorCard === successorCard) {
                                            return;
                                        }

                                        lines = lines.concat(this.generateDependencyLine(predecessorCard, successorCard));
                                    }
                                }
                                else {
                                    let predecessorCard = this.buckets[pred.get('ObjectID')];

                                    if (predecessorCard && predecessorCard !== successorCard) {
                                        lines = lines.concat(this.generateDependencyLine(predecessorCard, successorCard));
                                    }
                                }
                            }, this);
                        }, this);

                        this.drawDependencies(lines);
                    }

                    this.setLoading(false);
                    def.resolve();
                },
                failure: function () {
                    Rally.ui.notify.Notifier.showError({ message: 'Failed to add dependency lines for user stories' });
                    this.setLoading(false);
                    def.resolve();
                }
            });

        }
        else {
            def.resolve();
        }

        return def.promise;
    },

    showStoryDependencyLinesForCard: function (clickedCard) {
        let items = [];
        this.removeDependencyLines();

        // Get list of all cards for this card (1 for each story for this feature + iteration + project)
        let cards = this._getCardsForCard(clickedCard);

        let promises = _.map(cards, function (item) {
            let story = item.getRecord();

            let promise = this.getPredecessorsAndSuccessors(story).then({
                scope: this,
                success: function (predecessorsSuccessors) {
                    _.each(predecessorsSuccessors[0], function (predecessor) {
                        let key = this._getRecordBucketKey(predecessor);
                        if (this.buckets.hasOwnProperty(key)) {
                            let visibleCard = this.buckets[key][0];

                            // Skip self-dependencies
                            if (visibleCard === clickedCard) {
                                return;
                            }

                            items = items.concat(this.generateDependencyLine(visibleCard, clickedCard));
                        }
                    }, this);

                    _.each(predecessorsSuccessors[1], function (successor) {
                        let key = this._getRecordBucketKey(successor);
                        if (this.buckets.hasOwnProperty(key)) {
                            let visibleCard = this.buckets[key][0];

                            // Skip self-dependencies
                            if (visibleCard === clickedCard) {
                                return;
                            }

                            items = items.concat(this.generateDependencyLine(clickedCard, visibleCard));
                        }
                    }, this);
                }
            });

            return promise;
        }, this);

        Deft.promise.Promise.all(promises).then({
            scope: this,
            success: function () {
                this.drawDependencies(items);
            }
        });
    },

    generateDependencyLine: function (predecessorCard, successorCard) {
        // If a project swimlane is collapsed, the card isn't hidden, but it's coordinates will be 0,0
        if (!predecessorCard.getY() || !successorCard.getY()) {
            return [];
        }

        let items = [];
        let angle = 0;
        let stroke = "grey"; // "#D1D1D1";
        let circleRadius = 3;
        let cardHeight = predecessorCard.getHeight();
        let cardWidth = predecessorCard.getWidth();
        let predX = predecessorCard.getX();
        let predY = predecessorCard.getY();
        let succX = successorCard.getX();
        let succY = successorCard.getY();
        let rightAreaEl = this.down('#right-area').getEl();
        let rightAreaScroll = rightAreaEl.getScroll();
        let boardArea = this.down('#board-area');
        let boardAreaScroll = boardArea.getEl().getScroll();
        let boardAreaButtons = boardArea.getEl().dom.getElementsByClassName('rui-leftright');
        let buttonAreaHeight = (boardAreaButtons && boardAreaButtons.length) ? boardAreaButtons[0].getBoundingClientRect().height : 0;
        let cbBody = this.getCardboardBody();

        // Yellow line if the dependencies are in the same iteration
        if (predX === succX) {
            if (this._shouldShowStoryDependencies() && !this.down('#yellowLineFilter').getValue()) {
                return [];
            }
            stroke = "#FAD200";
        }
        // Red line if:
        //     - The predecessor is scheduled for an iteration after the successor's scheduled iteration
        //     OR
        //     - The successor is scheduled for an iteration but the predecessor is not
        else if ((predX > succX) || (!predecessorCard.record.get('Iteration') && successorCard.record.get('Iteration'))) {
            if (this._shouldShowStoryDependencies() && !this.down('#redLineFilter').getValue()) {
                return [];
            }
            stroke = "#F66349";
        }
        else if (this._shouldShowStoryDependencies() && !this.down('#greyLineFilter').getValue()) {
            return [];
        }

        let xOffset = -boardArea.getX() + boardArea.getEl().getMargin().left + boardAreaScroll.left + cbBody.getScrollLeft();
        let yOffset = -rightAreaEl.getY() + rightAreaScroll.top + boardAreaScroll.top + cbBody.getScrollTop() - buttonAreaHeight - 1;

        if (predY === succY) {
            predY += cardHeight / 2 + yOffset;
            succY += cardHeight / 2 + yOffset;
        }
        else if (predY > succY) {
            succY += cardHeight + yOffset;
            predY += yOffset;
            angle = -60;
        }
        else {
            predY += cardHeight + yOffset;
            succY += yOffset;
            angle = 60;
        }

        predX += cardWidth + circleRadius + xOffset;
        succX += xOffset - circleRadius;

        // Half Circle
        // items.push({
        //     type: "path",
        //     path: Ext.String.format("M{0} {1} A{2},{2} 0 0,0,{0},0",
        //         p.x, p.y, circleRadius
        //     ),
        //     fill: 'grey'
        // });

        // Dashed line connecting dependencies
        items.push({
            type: "path",
            path: Ext.String.format("M{0} {1} L {2} {3}",
                predX, predY, succX, succY,
            ),
            fill: "transparent",
            stroke,
            "stroke-width": "1",
            "stroke-dasharray": "3",
        });

        // Circle from predecessor
        items.push({
            type: "circle",
            stroke,
            fill: "#f6f6f6",
            "stroke-width": "2",
            radius: circleRadius,
            x: predX,
            y: predY
        });

        // Arrow pointing to successor

        let arrow = Ext.create('Ext.draw.Sprite', {
            type: "path",
            fill: '#f6f6f6',
            stroke,
            "stroke-width": "2",
            transformText: Ext.String.format("rotate(35 {0} {1})",
                succX, succY
            ),
            path: Ext.String.format("M {0} {1} L {2} {3} L {4} {5} z",
                succX,
                succY - circleRadius,
                succX + (circleRadius * 2),
                succY,
                succX,
                succY + circleRadius,
            )
        });

        // let angle = Math.atan2(predY - succY, predX - succX) * 180 / Math.PI;
        // if (angle < 0) {
        //     angle += 360;
        // }
        arrow.setAttributes({
            rotate: {
                degrees: angle
            }
        }, false);

        items.push(arrow);

        return items;
    },

    getAllStoryPredecessors: function (cards) {
        let def = Ext.create('Deft.Deferred');
        let isFeatureCards = this.down('#cardTypeCombo').getValue() === 'Features';

        if (cards.length) {
            let promises = [];

            for (let card of cards) {
                let storyCards = isFeatureCards ? this._getCardsForCard(card) : [card];

                _.each(storyCards, function (item) {
                    let story = item.getRecord();

                    if (story.get('Predecessors').Count) {
                        promises.push(this.getPredecessorsForRecord(story, [this.lowestPiTypeName].concat(Constants.STORIES_FETCH)).then({
                            success: function (predecessors) {
                                return { card: item, predecessors };
                            }
                        }));
                    }
                }, this);
            }

            if (!promises.length) {
                def.resolve([]);
            }

            Deft.promise.Promise.all(promises).then({
                scope: this,
                success: function (preds) {
                    // let results = _.flatten(preds);
                    def.resolve(preds);
                },
                failure: function (e) {
                    console.log(e);
                    def.reject();
                }
            });
        }
        else {
            def.resolve([]);
        }

        return def.promise;
    },

    getPredecessorsForRecord: function (record, fetch) {
        let filters = [{ property: 'Feature', operator: '!=', value: null }];

        return record.getCollection('Predecessors', { fetch, filters }).load().then({
            scope: this,
            success: function (predecessors) {
                return predecessors;
            }
        });
    },

    getSuccessorsForRecord: function (record, fetch) {
        let filters = [{ property: 'Feature', operator: '!=', value: null }];

        return record.getCollection('Successors', { fetch, filters }).load().then({
            scope: this,
            success: function (successors) {
                return successors;
            }
        });
    },

    getPredecessorsAndSuccessors: function (record) {
        let fetch = [this.lowestPiTypeName].concat(Constants.STORIES_FETCH);

        let predecessorsPromise = this.getPredecessorsForRecord(record, fetch);
        let successorsPromise = this.getSuccessorsForRecord(record, fetch);

        return Deft.promise.Promise.all([predecessorsPromise, successorsPromise]);
    },

    drawDependencies: function (items) {

        let cbHeader = this.getCardboardHeader();
        let cbBody = this.getCardboardBody();
        let yOffset = -cbHeader.getHeight() - 120;
        let xOffset = -20;

        this.drawComponent = Ext.create('Ext.draw.Component', {
            renderTo: cbBody,
            style: Ext.String.format('position:absolute; top:{0}px; left:{1}px;z-index:1000;pointer-events:none', yOffset, xOffset),
            itemId: 'dependencies',
            id: 'dep',
            viewBox: false,
            floating: false,
            height: cbBody.dom.firstElementChild.clientHeight + 200,
            width: cbBody.getWidth() + 40,
            items: items
        });
    },

    getCardboardBody: function () {
        return this.board && this.board.getEl().down('.fixed-header-card-board-body-container');
    },

    getCardboardHeader: function () {
        return this.board && this.board.getEl().down('.fixed-header-card-board-header-container');
    },

    _getCardBucketKey: function (card) {
        let record = card.getRecord();
        return this._getRecordBucketKey(record);
    },

    _getRecordBucketKey: function (record) {
        let iterationKey = this._getIterationKey(record.get('Iteration'));
        let projectId = record.get('Project').ObjectID;
        let featureId = record.get('Feature').ObjectID;
        return [featureId, projectId, iterationKey].join('-');
    },

    _getIterationKey: function (iteration) {
        let result = '';
        if (iteration) {
            if (iteration.get) {
                result = iteration.get('Name') + iteration.get('StartDate').toISOString() + iteration.get('EndDate').toISOString();
            }
            else {
                result = iteration.Name + iteration.StartDate + iteration.EndDate;
            }
        }
        return result;
    },


    _isCardHidden: function (card) {
        let result = false;
        let key = this._getCardBucketKey(card);
        if (this.buckets.hasOwnProperty(key)) {
            this.buckets[key].push(card);
            result = true;
        }
        else {
            this.buckets[key] = [card];
        }
        return result;
    },

    _getCardsForCard: function (card) {
        let key = this._getCardBucketKey(card);
        let result = this.buckets[key];

        return result;
    },

    getModelScopedStateId: function (modelName, id) {
        return this.getContext().getScopedStateId(modelName + '-' + id);
    },

    getSettingsFields: function () {
        return [
            {
                xtype: 'textarea',
                fieldLabel: 'Feature Query',
                name: 'query',
                anchor: '100%',
                cls: 'query-field',
                margin: '0 70 0 0',
                plugins: [
                    {
                        ptype: 'rallyhelpfield',
                        helpId: 194
                    },
                    'rallyfieldvalidationui'
                ],
                validateOnBlur: false,
                validateOnChange: false,
                validator: function (value) {
                    try {
                        if (value) {
                            Rally.data.wsapi.Filter.fromQueryString(value);
                        }
                        return true;
                    } catch (e) {
                        return e.message;
                    }
                }
            }
        ];
    },

    searchAllProjects: function () {
        return this.ancestorFilterPlugin.getIgnoreProjectScope();
    },

    onCardboardResize: function () {
        let board = this.down('#releaseCardboard');

        if (board) {
            this.removeDependencyLines();

            if (this.previousCancelIcon) {
                this.previousDepIcon.setStyle('display', 'inline');
                this.previousCancelIcon.setStyle('display', 'none');
                this.previousDepIcon = null;
                this.previousCancelIcon = null;
            }

            if (this._shouldShowStoryDependencies()) {
                // With many dependencies drawn, the loading mask doesn't properly display
                // and it looks like the app freezes... Not an ideal user experience.
                // A timeout helps everything render properly before redrawing the dependencies
                setTimeout(() => {
                    this.showAllStoryDependencyLines().then({
                        scope: this,
                        success: function () {
                            this.setLoading(false);
                        }
                    });
                }, 500);
            }
        }
    },

    removeDependencyLines: function () {
        if (this.drawComponent) {
            Ext.destroy(this.drawComponent);
        }
    },

    _shouldShowStoryDependencies: function () {
        return this.down('#storyDependencyCheckbox').getValue();
    },

    onTimeboxScopeChange: function (newTimeboxScope) {
        this.callParent(arguments);
        this._onTimeboxScopeChange(newTimeboxScope);
        this._update();
    },

    _onTimeboxScopeChange: function (timeboxScope) {
        if (timeboxScope) {
            this.timeboxType = timeboxScope.getType();
            this.timebox = timeboxScope.getRecord();
            if (this.timeboxType === 'release') {
                this.timeboxStart = this.timebox ? this.timebox.get('ReleaseStartDate') : new Date();
                this.timeboxEnd = this.timebox ? this.timebox.get('ReleaseDate') : new Date();
            }
            else if (this.timeboxType === 'milestone') {
                this.timeboxStart = this.timebox ? this.timebox.get('TargetDate') : new Date();
                this.timeboxEnd = this.timebox ? this.timebox.get('TargetDate') : new Date();
            }
            else if (this.timeboxType === 'iteration') {
                this.timeboxStart = this.timebox ? this.timebox.get('StartDate') : new Date();
                this.timeboxEnd = this.timebox ? this.timebox.get('EndDate') : new Date();
            }
        }
        else {
            this.timeboxStart = new Date();
            this.timeboxEnd = new Date();
        }

        this._updateDateControls();
    },

    _updateDateControls: function () {
        let startDatePicker = this.down('#start-date-picker');
        startDatePicker.suspendEvents();
        startDatePicker.setValue(this.timeboxStart);
        startDatePicker.resumeEvents();
        let endDatePicker = this.down('#end-date-picker');
        endDatePicker.suspendEvents();
        endDatePicker.setValue(this.timeboxEnd);
        endDatePicker.resumeEvents();
    },

    onHelpClicked() {
        CustomAgile.ui.tutorial.ReleaseTrackingTutorial.showWelcomeDialog(this);
    }
});


                Rally.launchApp('release-tracking-with-filters', {
                    name: 'release-tracking-with-filters'
                });
        });
    </script>

    <style type="text/css">
        
.tsinfolink {
    position: absolute;
    right: 0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.ts-page-label {
    font-weight: bold;
    font-size: medium;
}

.iteration-name {
    font-size: medium;
}

.iteration-dates {
    font-size: x-small;
    font-weight: normal;
}

.cardboard-column-header {
    margin-left: unset;
    margin-right: unset;
}

.date-label {
    font-size: 13px;
    font-weight: bold;
    font-family: ProximaNova, Helvetica, Arial;
    text-transform: uppercase;
}

.control-label {
    width: 100%;
    text-align: center;
    padding-bottom: 4px;
}

.dependency-label {
    margin-top: 0 !important;
    margin-left: 20px !important;
}

.dependency-checkbox input {
    margin-top: 1px;
}

.grid-area {
    background-color: rgb(244, 244, 244);
    padding: 10px;
    border: rgb(213, 213, 213);
    border-width: thin;
    border-style: solid;
    border-radius: 4px;
}

.ts-panel-header {
    background-color: rgb(244, 244, 244);
}

.x-panel-header-collapsed {
    background-color: rgb(244, 244, 244);
    padding: 10px;
    border: rgb(213, 213, 213);
    border-width: thin;
    border-style: solid;
    border-radius: 4px;
}

.ts-panel-header .x-panel-header-text {
    font-weight: bold;
}

.ts-artifact-color {
    width: 5px;
    height: 20px;
}

.ts-card-table div {
    font-weight: bold;
    font-size: 1.1em;
    color: #666;
}

.ts-scope-control {
    margin-top: 3px;
    margin-right: 9px;
}

.line {
    z-index: 10000;
    border-bottom-width: 2px;
    border-color: #000000;
    border-bottom-style: solid;
}

.line.predecessor {
    border-color: #FF0000;
    border-bottom-style: solid;
}

.line.successor {
    border-color: #00FF00;
    border-bottom-style: dashed;
}

.dependency-row.ts-dependent-story {
    padding-left: 40px !important;
}

.ts-dependent-story .icon-story {
    display: none;
}

.ts-card-content.ts-card-icons {
    min-width: 50px;
    text-align: center;
    cursor: pointer;
}

.ts-card-content.ts-accepted-count {
    width: 100%;
    color: #888;
    text-align: right;
    cursor: pointer;
}

.x-border-layout-ct {
    background-color: white;
}

.x-tip {
    border: 1px solid rgb(212, 212, 212);
    border-radius: 3px;
}

.x-tip .x-tip-body {
    background-color: white;
    padding: 10px;
    color: black;
    border-radius: 2px;
}

.help .x-btn-button {
    height: 18px !important;
    width: 18px !important;
  }

.icon-help {
    font-size: 16px;
    text-align: center;
    color: #327c98 !important;
}

.icon-help:hover {
    color: #21516d !important;
}

li {
    line-height: 18px;
}

.customagile-button.help {
    padding: 0;
}

#storyDependencyHelp {
    position: absolute !important;
    right: 20px !important;
    left: auto !important;
}

#board-area { 
    height: 100%; 
    overflow-y: scroll !important;
}

#board-area>.rui-gridboard {
    height: 100%;
    overflow-y: hidden;
}

.fixed-header-card-board-body-container {
    position: relative;
}

.ts-card-table {
    width: 100%;
    margin: 4px 1px;
    table-layout: auto !important;
}

.ts-card-table tr {
    width: 100%;
}

.dependency-filter-btn {
    position: relative;
}

.dep-checkbox-container {
    background-color: white;
    border-radius: 1px;
    color: black;
    width: 100% !important;
    margin-top: 5px;
}

.dependency-filter-count {
    position: absolute;
    right: 1px;
    bottom: 1px;
    font-size: 8px;
    color: white;
    background-color: #00a9e0;
    border-radius: 5px;
    width: 10px;
    height: 10px;
    font-weight: bold;
    padding-left: 3px;
}

.story-popover-feature-text {
    color: white;
    font-family: ProximaNova,Helvetica,Arial;
    font-size: 16px;
    font-weight: normal;
    line-height: 16px;
    text-transform: none;
    padding-top: 5px;
}

.tutorial-example-btn {
    background-color: white;
    border-color: #00a9e0;
    color: #00a9e0;
    height: 13px;
    width: 15px !important;
    border-radius: 1px;
    display: inline-grid !important;
    position: relative;
    padding-top: 1px;
}

.tutorial-popover-body {
    font-size: 12px;
    font-weight: normal;
    font-family: NotoSans, Helvetica, Arial;
}
.blue-tabs .x-tab-bar .x-tab-default {
  background-color: white;
  border-radius: 4px 4px 0 0;
}

.blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
  color: #00a9e0;
}

.blue-tabs .x-tab-bar .x-tab-active {
  background-color: #00a9e0;
}

.blue-tabs .x-tab-bar .x-tab-active .x-tab-inner {
  color: white;
}

.blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
  text-overflow: initial;
  -o-text-overflow: initial;
  overflow: initial;
}

.blue-tabs .x-tab-bar .x-tab-inner {
  width: 100%;
}

.blue-tabs .x-tab-bar .x-tab-default .x-tab-icon-el {
  color: white;
}

.filter-help { 
  border-color: #d6d6d6 !important;
}

.icon-help {
  font-size: 16px;
  text-align: center;
  color: #327c98 !important;
}

.icon-help:hover {
  color: #21516d !important;
}

.filter-help .x-btn-button {
  height: 18px !important;
  width: 18px !important;
}

.filter-help-list li{
  padding-bottom: 6px;
}
    </style>

</head>

<body></body>

</html>